## API Report File for "@siteimprove/alfa-command"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Functor } from '@siteimprove/alfa-functor';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Option } from '@siteimprove/alfa-option';
import * as parser from '@siteimprove/alfa-parser';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Result } from '@siteimprove/alfa-result';
import { Serializable } from '@siteimprove/alfa-json';
import { Thunk } from '@siteimprove/alfa-thunk';

// @public (undocumented)
export class Argument<T = unknown> implements Functor<T>, Serializable<Argument.JSON> {
    // (undocumented)
    choices<U extends T>(...choices: Array<U>): Argument<U>;
    // (undocumented)
    default(value: T, label?: string): Argument<T>;
    // (undocumented)
    get description(): string;
    // (undocumented)
    filter<U extends T>(refinement: Refinement<T, U>, ifError?: Thunk<string>): Argument<U>;
    // (undocumented)
    filter(predicate: Predicate<T>, ifError?: Thunk<string>): Argument<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Argument<U>;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of<T>(name: string, description: string, parse: Argument.Parser<T>): Argument<T>;
    // (undocumented)
    optional(): Argument<Option<T>>;
    // (undocumented)
    get options(): Argument.Options;
    // (undocumented)
    get parse(): Argument.Parser<T>;
    // (undocumented)
    repeatable(): Argument<Iterable<T>>;
    // (undocumented)
    toJSON(): Argument.JSON;
}

// @public (undocumented)
export namespace Argument {
    // (undocumented)
    export function boolean(name: string, description: string): Argument<boolean>;
    // (undocumented)
    export function integer(name: string, description: string): Argument<number>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        description: string;
        // (undocumented)
        name: string;
        // (undocumented)
        options: {
            [key: string]: json.JSON;
            optional: boolean;
            repeatable: boolean;
            default: string | null;
        };
    }
    // (undocumented)
    export function number(name: string, description: string): Argument<number>;
    // (undocumented)
    export interface Options {
        // (undocumented)
        default: Option<string>;
        // (undocumented)
        optional: boolean;
        // (undocumented)
        repeatable: boolean;
    }
    // (undocumented)
    export type Parser<T> = parser.Parser<Array<string>, T, string>;
    // (undocumented)
    export function string(name: string, description: string): Argument<string>;
}

// @public (undocumented)
export class Command<F extends Command.Flags = {}, A extends Command.Arguments = {}, S extends Command.Subcommands = {}> implements Serializable<Command.JSON> {
    // (undocumented)
    get arguments(): A;
    // (undocumented)
    get description(): string;
    // (undocumented)
    get flags(): F;
    // (undocumented)
    get name(): string;
    // (undocumented)
    run(input: Array<string> | Command.Input<F, A>): Command.Output;
    // (undocumented)
    get subcommands(): S;
    // (undocumented)
    toJSON(): Command.JSON;
    // (undocumented)
    get version(): string;
    // (undocumented)
    static withArguments<F extends Command.Flags, A extends Command.Arguments>(name: string, version: string, description: string, flags: F, args: A, parent?: Option<Command>, run?: (command: Command<F, A, {}>) => Command.Runner<F, A>): Command<F, A, {}>;
    // (undocumented)
    static withSubcommands<F extends Command.Flags, S extends Command.Subcommands>(name: string, version: string, description: string, flags: F, subcommands: Mapper<Command, S>, parent?: Option<Command>, run?: (command: Command<F, {}, S>) => Command.Runner<F, {}>): Command<F, {}, S>;
}

// @public (undocumented)
export namespace Command {
    // (undocumented)
    export interface Arguments {
        // (undocumented)
        [name: string]: Argument<any>;
    }
    // (undocumented)
    export namespace Arguments {
        // (undocumented)
        export type Values<A extends Arguments> = {
            [N in keyof A]: A[N] extends Argument<infer T> ? T : never;
        };
    }
    // (undocumented)
    export interface Flags {
        // (undocumented)
        [name: string]: Flag<any>;
    }
    // (undocumented)
    export namespace Flags {
        // (undocumented)
        export type Values<F extends Flags> = {
            [N in keyof F]: F[N] extends Flag<infer T> ? T : never;
        };
    }
    // (undocumented)
    export interface Input<F extends Flags, A extends Arguments> {
        // (undocumented)
        args: Arguments.Values<A>;
        // (undocumented)
        flags: Flags.Values<F>;
    }
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        arguments: Array<Argument.JSON>;
        // (undocumented)
        description: string;
        // (undocumented)
        flags: Array<Flag.JSON>;
        // (undocumented)
        name: string;
        // (undocumented)
        subcommands: Array<Command.JSON>;
    }
    // (undocumented)
    export type Output = Promise<Result<string>>;
    // (undocumented)
    export type Runner<F extends Flags, A extends Arguments> = (input: Input<F, A>) => Output;
    // (undocumented)
    export interface Subcommands {
        // (undocumented)
        [name: string]: Command<any, any, any>;
    }
}

// @public (undocumented)
export class Flag<T = unknown> implements Functor<T>, Serializable<Flag.JSON> {
    // (undocumented)
    alias(alias: string): Flag<T>;
    // (undocumented)
    choices<U extends T>(...choices: Array<U>): Flag<U>;
    // (undocumented)
    default(value: T, label?: string): Flag<T>;
    // (undocumented)
    get description(): string;
    // (undocumented)
    filter<U extends T>(refinement: Refinement<T, U>, ifError?: Thunk<string>): Flag<U>;
    // (undocumented)
    filter(predicate: Predicate<T>, ifError?: Thunk<string>): Flag<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Flag<U>;
    // (undocumented)
    matches(name: string): boolean;
    // (undocumented)
    get name(): string;
    // (undocumented)
    negatable(mapper: Mapper<T>): Flag<T>;
    // (undocumented)
    static of<T>(name: string, description: string, parse: Flag.Parser<T, [Predicate<string>]>): Flag<T>;
    // (undocumented)
    optional(): Flag<Option<T>>;
    // (undocumented)
    get options(): Flag.Options;
    // (undocumented)
    get parse(): Flag.Parser<T>;
    // (undocumented)
    repeatable(): Flag<Iterable<T>>;
    // (undocumented)
    toJSON(): Flag.JSON;
    // (undocumented)
    type(type: string): Flag<T>;
}

// @public (undocumented)
export namespace Flag {
    // (undocumented)
    export function boolean(name: string, description: string): Flag<boolean>;
    // (undocumented)
    export function empty(name: string, description: string): Flag<void>;
    // (undocumented)
    export function help(description: string): Flag<Option<symbol>>;
    // (undocumented)
    export function integer(name: string, description: string): Flag<number>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        description: string;
        // (undocumented)
        name: string;
        // (undocumented)
        options: {
            [key: string]: json.JSON;
            type: string | null;
            aliases: Array<string>;
            default: json.JSON | null;
            optional: boolean;
            repeatable: boolean;
        };
    }
    // (undocumented)
    export function number(name: string, description: string): Flag<number>;
    // (undocumented)
    export interface Options {
        // (undocumented)
        readonly aliases: Array<string>;
        // (undocumented)
        readonly default: Option<string>;
        // (undocumented)
        readonly negatable: boolean;
        // (undocumented)
        readonly optional: boolean;
        // (undocumented)
        readonly repeatable: boolean;
        // (undocumented)
        readonly type: Option<string>;
    }
    // (undocumented)
    export type Parser<T, A extends Array<unknown> = []> = parser.Parser<Array<string>, Set<T>, string, A>;
    export class Set<T> implements Functor<T> {
        // (undocumented)
        map<U>(mapper: Mapper<T, U>): Set<U>;
        // (undocumented)
        static of<T>(value: T, parse: Flag.Parser<T>): Set<T>;
        // (undocumented)
        get parse(): Flag.Parser<T>;
        // (undocumented)
        get value(): T;
        }
    const // (undocumented)
    Help: unique symbol;
    // (undocumented)
    export function string(name: string, description: string): Flag<string>;
    const // (undocumented)
    Version: unique symbol;
    // (undocumented)
    export function version(description: string): Flag<Option<symbol>>;
}

// Warning: (ae-internal-missing-underscore) The name "Text" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export namespace Text {
    // (undocumented)
    export function indent(text: string, indent?: string | number): string;
    // (undocumented)
    export function wrap(text: string, length?: number): string;
}


// (No @packageDocumentation comment for this package)

```
