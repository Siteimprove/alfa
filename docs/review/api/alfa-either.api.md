## API Report File for "@siteimprove/alfa-either"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Equatable } from '@siteimprove/alfa-equatable';
import { Foldable } from '@siteimprove/alfa-foldable';
import { Functor } from '@siteimprove/alfa-functor';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Monad } from '@siteimprove/alfa-monad';
import { None } from '@siteimprove/alfa-option';
import { Option } from '@siteimprove/alfa-option';
import { Reducer } from '@siteimprove/alfa-reducer';
import { Serializable } from '@siteimprove/alfa-json';

// @public (undocumented)
export interface Either<L, R = L> extends Functor<L | R>, Monad<L | R>, Foldable<L | R>, Iterable<L | R>, Equatable, Hashable, Serializable<Either.JSON<L, R>> {
    // (undocumented)
    either<T>(left: Mapper<L, T>, right: Mapper<R, T>): T;
    // (undocumented)
    flatMap<T>(mapper: Mapper<L | R, Either<T, T>>): Either<T, T>;
    // (undocumented)
    get(): L | R;
    // (undocumented)
    isLeft(): this is Left<L>;
    // (undocumented)
    isRight(): this is Right<R>;
    // (undocumented)
    left(): Option<L>;
    // (undocumented)
    map<T>(mapper: Mapper<L | R, T>): Either<T, T>;
    // (undocumented)
    reduce<T>(reducer: Reducer<L | R, T>, accumulator: T): T;
    // (undocumented)
    right(): Option<R>;
    // (undocumented)
    toJSON(): Either.JSON<L, R>;
}

// @public (undocumented)
export namespace Either {
    // (undocumented)
    export function isEither<L, R>(value: Iterable<L | R>): value is Either<L, R>;
    // (undocumented)
    export function isEither<L, R>(value: unknown): value is Either<L, R>;
    // (undocumented)
    export type JSON<L, R = L> = Left.JSON<L> | Right.JSON<R>;
    // (undocumented)
    export function left<L, R = never>(value: L): Either<L, R>;
    // (undocumented)
    export function right<R, L = never>(value: R): Either<L, R>;
}

// @public (undocumented)
export class Left<L> implements Either<L, never> {
    // (undocumented)
    [Symbol.iterator](): Iterator<L>;
    // (undocumented)
    either<T>(left: Mapper<L, T>): T;
    // (undocumented)
    equals<L>(value: Left<L>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    flatMap<T>(mapper: Mapper<L, Either<T, T>>): Either<T, T>;
    // (undocumented)
    get(): L;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    isLeft(): this is Left<L>;
    // (undocumented)
    isRight(): this is Right<never>;
    // (undocumented)
    left(): Option<L>;
    // (undocumented)
    map<T>(mapper: Mapper<L, T>): Either<T, T>;
    // (undocumented)
    static of<L>(value: L): Left<L>;
    // (undocumented)
    reduce<T>(reducer: Reducer<L, T>, accumulator: T): T;
    // (undocumented)
    right(): None;
    // (undocumented)
    toJSON(): Left.JSON<L>;
    // (undocumented)
    toString(): string;
    }

// @public (undocumented)
export namespace Left {
    // (undocumented)
    export function isLeft<L>(value: Iterable<L>): value is Left<L>;
    // (undocumented)
    export function isLeft<L>(value: unknown): value is Left<L>;
    // (undocumented)
    export interface JSON<L> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "left";
        // (undocumented)
        value: Serializable.ToJSON<L>;
    }
}

// @public (undocumented)
export class Right<R> implements Either<never, R> {
    // (undocumented)
    [Symbol.iterator](): Iterator<R>;
    // (undocumented)
    either<T>(left: unknown, right: Mapper<R, T>): T;
    // (undocumented)
    equals<R>(value: Right<R>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    flatMap<T>(mapper: Mapper<R, Either<T, T>>): Either<T, T>;
    // (undocumented)
    get(): R;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    isLeft(): this is Left<never>;
    // (undocumented)
    isRight(): this is Right<R>;
    // (undocumented)
    left(): None;
    // (undocumented)
    map<T>(mapper: Mapper<R, T>): Either<T, T>;
    // (undocumented)
    static of<R>(value: R): Right<R>;
    // (undocumented)
    reduce<T>(reducer: Reducer<R, T>, accumulator: T): T;
    // (undocumented)
    right(): Option<R>;
    // (undocumented)
    toJSON(): Right.JSON<R>;
    // (undocumented)
    toString(): string;
    }

// @public (undocumented)
export namespace Right {
    // (undocumented)
    export function isRight<R>(value: Iterable<R>): value is Right<R>;
    // (undocumented)
    export function isRight<R>(value: unknown): value is Right<R>;
    // (undocumented)
    export interface JSON<R> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "right";
        // (undocumented)
        value: Serializable.ToJSON<R>;
    }
}


// (No @packageDocumentation comment for this package)

```
