## API Report File for "@siteimprove/alfa-either"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Applicative } from '@siteimprove/alfa-applicative';
import type { Callback } from '@siteimprove/alfa-callback';
import type { Equatable } from '@siteimprove/alfa-equatable';
import type { Foldable } from '@siteimprove/alfa-foldable';
import type { Functor } from '@siteimprove/alfa-functor';
import type { Hash } from '@siteimprove/alfa-hash';
import type { Hashable } from '@siteimprove/alfa-hash';
import type * as json from '@siteimprove/alfa-json';
import type { Mapper } from '@siteimprove/alfa-mapper';
import type { Monad } from '@siteimprove/alfa-monad';
import { None } from '@siteimprove/alfa-option';
import { Option } from '@siteimprove/alfa-option';
import type { Reducer } from '@siteimprove/alfa-reducer';
import { Serializable } from '@siteimprove/alfa-json';

// @public (undocumented)
export interface Either<L, R = L> extends Functor<R>, Applicative<R>, Monad<R>, Foldable<R>, Iterable<L | R>, Equatable, Hashable, Serializable<Either.JSON<L, R>> {
    // (undocumented)
    apply<T>(mapper: Either<L, Mapper<R, T>>): Either<L, T>;
    // (undocumented)
    either<T>(left: Mapper<L, T>, right: Mapper<R, T>): T;
    // (undocumented)
    flatMap<T>(mapper: Mapper<R, Either<L, T>>): Either<L, T>;
    // (undocumented)
    flatten<L, R>(this: Either<L, Either<L, R>>): Either<L, R>;
    // (undocumented)
    get(): L | R;
    // (undocumented)
    isLeft(): this is Left<L>;
    // (undocumented)
    isRight(): this is Right<R>;
    // (undocumented)
    left(): Option<L>;
    // (undocumented)
    map<T>(mapper: Mapper<R, T>): Either<L, T>;
    // (undocumented)
    reduce<T>(reducer: Reducer<R, T>, accumulator: T): T;
    // (undocumented)
    right(): Option<R>;
    // (undocumented)
    teeLeft(callback: Callback<L>): Either<L, R>;
    // (undocumented)
    teeRight(callback: Callback<R>): Either<L, R>;
    // (undocumented)
    toJSON(): Either.JSON<L, R>;
}

// @public (undocumented)
export namespace Either {
    // (undocumented)
    export function isEither<L, R>(value: Iterable<L | R>): value is Either<L, R>;
    // (undocumented)
    export function isEither<L, R>(value: unknown): value is Either<L, R>;
    // (undocumented)
    export function isLeft<L>(value: Iterable<L>): value is Left<L>;
    // (undocumented)
    export function isLeft<L>(value: unknown): value is Left<L>;
    // (undocumented)
    export function isRight<R>(value: Iterable<R>): value is Right<R>;
    // (undocumented)
    export function isRight<R>(value: unknown): value is Right<R>;
    // (undocumented)
    export type JSON<L, R = L> = Left.JSON<L> | Right.JSON<R>;
    // (undocumented)
    export function left<L, R = never>(value: L): Either<L, R>;
    // (undocumented)
    export function right<R, L = never>(value: R): Either<L, R>;
}

// @public (undocumented)
export class Left<L> implements Either<L, never> {
    // (undocumented)
    [Symbol.iterator](): Iterator<L>;
    // (undocumented)
    apply(): Left<L>;
    // (undocumented)
    either<T>(left: Mapper<L, T>): T;
    // (undocumented)
    equals<L>(value: Left<L>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    flatMap(): Left<L>;
    // (undocumented)
    flatten<L, R>(this: Either<L, never>): Either<L, R>;
    // (undocumented)
    get(): L;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    isLeft(): this is Left<L>;
    // (undocumented)
    isRight(): this is Right<never>;
    // (undocumented)
    left(): Option<L>;
    // (undocumented)
    map(): Left<L>;
    // (undocumented)
    static of<L>(value: L): Left<L>;
    // (undocumented)
    reduce<T>(reducer: unknown, accumulator: T): T;
    // (undocumented)
    right(): None;
    // (undocumented)
    teeLeft(callback: Callback<L>): Left<L>;
    // (undocumented)
    teeRight(): Left<L>;
    // (undocumented)
    toJSON(): Left.JSON<L>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Left {
    // (undocumented)
    export function isLeft<L>(value: Iterable<L>): value is Left<L>;
    // (undocumented)
    export function isLeft<L>(value: unknown): value is Left<L>;
    // (undocumented)
    export interface JSON<L> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "left";
        // (undocumented)
        value: Serializable.ToJSON<L>;
    }
}

// @public (undocumented)
export class Right<R> implements Either<never, R> {
    // (undocumented)
    [Symbol.iterator](): Iterator<R>;
    // (undocumented)
    apply<L, T>(mapper: Either<L, Mapper<R, T>>): Either<L, T>;
    // (undocumented)
    either<T>(left: unknown, right: Mapper<R, T>): T;
    // (undocumented)
    equals<R>(value: Right<R>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    flatMap<L, T>(mapper: Mapper<R, Either<L, T>>): Either<L, T>;
    // (undocumented)
    flatten<L, R>(this: Right<Either<L, R>>): Either<L, R>;
    // (undocumented)
    get(): R;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    isLeft(): this is Left<never>;
    // (undocumented)
    isRight(): this is Right<R>;
    // (undocumented)
    left(): None;
    // (undocumented)
    map<T>(mapper: Mapper<R, T>): Right<T>;
    // (undocumented)
    static of<R>(value: R): Right<R>;
    // (undocumented)
    reduce<T>(reducer: Reducer<R, T>, accumulator: T): T;
    // (undocumented)
    right(): Option<R>;
    // (undocumented)
    teeLeft(): Right<R>;
    // (undocumented)
    teeRight(callback: Callback<R>): Right<R>;
    // (undocumented)
    toJSON(): Right.JSON<R>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Right {
    // (undocumented)
    export function isRight<R>(value: Iterable<R>): value is Right<R>;
    // (undocumented)
    export function isRight<R>(value: unknown): value is Right<R>;
    // (undocumented)
    export interface JSON<R> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "right";
        // (undocumented)
        value: Serializable.ToJSON<R>;
    }
}

// (No @packageDocumentation comment for this package)

```
