## API Report File for "@siteimprove/alfa-wcag"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Branched } from '@siteimprove/alfa-branched';
import { Option } from '@siteimprove/alfa-option';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Requirement } from '@siteimprove/alfa-act';

// @public
export namespace Conformance {
    export type A<V extends Criterion.Version = Criterion.Version.Recommendation> = Criterion.Level.A<V>;
    export type AA<V extends Criterion.Version = Criterion.Version.Recommendation> = Criterion.Level.A<V> | Criterion.Level.AA<V>;
    export type AAA<V extends Criterion.Version = Criterion.Version.Recommendation> = Criterion.Level.A<V> | Criterion.Level.AA<V> | Criterion.Level.AAA<V>;
    export function isA<V extends Criterion.Version = Criterion.Version.Recommendation>(version?: V): Refinement<Criterion, Criterion<A<V>>>;
    export function isAA<V extends Criterion.Version = Criterion.Version.Recommendation>(version?: V): Refinement<Criterion, Criterion<AA<V>>>;
    export function isAAA<V extends Criterion.Version = Criterion.Version.Recommendation>(version?: V): Refinement<Criterion, Criterion<AAA<V>>>;
}

// @public (undocumented)
export class Criterion<C extends Criterion.Chapter = Criterion.Chapter> extends Requirement {
    get chapter(): C;
    get level(): Branched<Criterion.Level, Criterion.Version>;
    // (undocumented)
    static of<C extends Criterion.Chapter>(chapter: C): Criterion<C>;
    get title(): Criterion.Title<C>;
    // (undocumented)
    toEARL(): Criterion.EARL;
    // (undocumented)
    toJSON(): Criterion.JSON;
    get uri(): Criterion.URI<C, "2.1" | "2.2">;
    get versions(): Iterable<Criterion.Version>;
}

// @public (undocumented)
export namespace Criterion {
    // Warning: (ae-forgotten-export) The symbol "Criteria" needs to be exported by the entry point index.d.ts
    export type Chapter = keyof Criteria;
    // (undocumented)
    export interface EARL extends Requirement.EARL {
        // (undocumented)
        "@context": {
            earl: "http://www.w3.org/ns/earl#";
            dct: "http://purl.org/dc/terms/";
        };
        // (undocumented)
        "dct:isPartOf": "https://www.w3.org/TR/WCAG/";
        // (undocumented)
        "dct:title": string;
    }
    // (undocumented)
    export function fromURI(uri: string): Option<Criterion>;
    // (undocumented)
    export function isChapter(value: string): value is Chapter;
    // (undocumented)
    export function isCriterion(value: unknown): value is Criterion;
    // (undocumented)
    export interface JSON extends Requirement.JSON {
        // (undocumented)
        chapter: Chapter;
        // (undocumented)
        title: string;
    }
    export type Level<C extends Chapter = Chapter, V extends Version = Version> = Criteria[C]["versions"] extends Iterable<infer T> ? T extends readonly [V, {
        readonly level: infer L;
    }] ? L : never : never;
    // (undocumented)
    export namespace Level {
        export type A<V extends Version = Version.Recommendation> = Of<"A", V>;
        export type AA<V extends Version = Version.Recommendation> = Of<"AA", V>;
        export type AAA<V extends Version = Version.Recommendation> = Of<"AAA", V>;
        export type Of<L extends Level, V extends Version = Version.Recommendation> = {
            [C in Chapter]: L extends Level<C, V> ? C : never;
        }[Chapter];
            {};
    }
    export type Title<C extends Chapter = Chapter> = Criteria[C]["title"];
    export type URI<C extends Chapter = Chapter, V extends Version = Version> = Criteria[C]["versions"] extends Iterable<infer T> ? T extends readonly [V, {
        readonly uri: infer U;
    }] ? U : never : never;
    export type Version = "2.0" | "2.1" | "2.2";
    // (undocumented)
    export namespace Version {
        const Recommendation = "2.1";
        export type Draft = typeof Draft;
        const Draft = "2.2";
        export type Recommendation = typeof Recommendation;
    }
}

// @public (undocumented)
export class Technique<N extends Technique.Name = Technique.Name> extends Requirement {
    get name(): N;
    // (undocumented)
    static of<N extends Technique.Name>(name: N): Technique<N>;
    get title(): Technique.Title<N>;
    // (undocumented)
    toEARL(): Technique.EARL;
    // (undocumented)
    toJSON(): Technique.JSON;
    get uri(): Technique.URI<N>;
}

// @public (undocumented)
export namespace Technique {
    // (undocumented)
    export interface EARL extends Requirement.EARL {
        // (undocumented)
        "@context": {
            earl: "http://www.w3.org/ns/earl#";
            dct: "http://purl.org/dc/terms/";
        };
        // (undocumented)
        "dct:isPartOf": "https://www.w3.org/WAI/WCAG21/Techniques/";
        // (undocumented)
        "dct:title": string;
    }
    // (undocumented)
    export function isName(value: string): value is Name;
    // (undocumented)
    export function isTechnique(value: unknown): value is Technique;
    // (undocumented)
    export interface JSON extends Requirement.JSON {
        // (undocumented)
        name: Name;
        // (undocumented)
        title: Title;
        // (undocumented)
        uri: URI;
    }
    // Warning: (ae-forgotten-export) The symbol "Techniques" needs to be exported by the entry point index.d.ts
    export type Name = keyof Techniques;
    export type Title<N extends Name = Name> = Techniques[N]["title"];
    export type URI<N extends Name = Name> = Techniques[N]["uri"];
}

// (No @packageDocumentation comment for this package)

```
