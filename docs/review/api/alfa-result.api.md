## API Report File for "@siteimprove/alfa-result"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Callback } from '@siteimprove/alfa-callback';
import type { Equatable } from '@siteimprove/alfa-equatable';
import type { Foldable } from '@siteimprove/alfa-foldable';
import type { Hash } from '@siteimprove/alfa-hash';
import type { Hashable } from '@siteimprove/alfa-hash';
import type * as json from '@siteimprove/alfa-json';
import type { Mapper } from '@siteimprove/alfa-mapper';
import type { Monad } from '@siteimprove/alfa-monad';
import { None } from '@siteimprove/alfa-option';
import { Option } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import type { Reducer } from '@siteimprove/alfa-reducer';
import type { Refinement } from '@siteimprove/alfa-refinement';
import { Serializable } from '@siteimprove/alfa-json';
import type { Thunk } from '@siteimprove/alfa-thunk';

// @public (undocumented)
export class Err<E> implements Result<never, E> {
    // (undocumented)
    [Symbol.iterator](): Generator<never, void, unknown>;
    protected constructor(error: E);
    // (undocumented)
    and(): Err<E>;
    // (undocumented)
    andThen(): Err<E>;
    // (undocumented)
    apply(): Err<E>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    err(): Option<E>;
    // (undocumented)
    every(): this is Err<E>;
    // (undocumented)
    everyErr<F extends E>(refinement: Refinement<E, F>): this is Result<never, F>;
    // (undocumented)
    everyErr(predicate: Predicate<E>): boolean;
    // (undocumented)
    flatMap(): Err<E>;
    // (undocumented)
    flatten<T, E>(this: Result<never, E>): Result<T, E>;
    // (undocumented)
    getErr(): E;
    // (undocumented)
    getErrOr(): E;
    // (undocumented)
    getErrOrElse(): E;
    // @internal (undocumented)
    getErrUnsafe(): E;
    // (undocumented)
    getOr<U>(value: U): U;
    // (undocumented)
    getOrElse<U>(value: Callback<E, U>): U;
    // @internal (undocumented)
    getUnsafe(message?: string): never;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    includes(): this is never;
    // (undocumented)
    includesErr(error: E): boolean;
    // (undocumented)
    isErr(): this is Err<E>;
    // (undocumented)
    isOk(): this is never;
    // (undocumented)
    map(): Err<E>;
    // (undocumented)
    mapErr<F>(mapper: Mapper<E, F>): Err<F>;
    // (undocumented)
    mapOrElse<U>(ok: unknown, err: Mapper<E, U>): U;
    // (undocumented)
    none(): this is Err<E>;
    // (undocumented)
    noneErr<F extends E>(refinement: Refinement<E, F>): this is Result<never, Exclude<E, F>>;
    // (undocumented)
    noneErr(predicate: Predicate<E>): boolean;
    // (undocumented)
    static of<E>(error: E): Err<E>;
    // (undocumented)
    ok(): None;
    // (undocumented)
    or<U, F>(result: Result<U, F>): Result<U, F>;
    // (undocumented)
    orElse<U, F>(result: Thunk<Result<U, F>>): Result<U, F>;
    // (undocumented)
    reduce<U>(reducer: unknown, accumulator: U): U;
    // (undocumented)
    some(): this is never;
    // (undocumented)
    someErr<F extends E>(refinement: Refinement<E, F>): this is Err<F>;
    // (undocumented)
    someErr(predicate: Predicate<E>): boolean;
    // (undocumented)
    tee(): Err<E>;
    // (undocumented)
    teeErr(callback: Callback<E>): Err<E>;
    // (undocumented)
    toJSON(options?: Serializable.Options): Err.JSON<E>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Err {
    // (undocumented)
    export function isErr<T, E>(value: Iterable<T>): value is Err<E>;
    // (undocumented)
    export function isErr<E>(value: unknown): value is Err<E>;
    // (undocumented)
    export interface JSON<E> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        error: Serializable.ToJSON<E>;
        // (undocumented)
        type: "err";
    }
}

// @public (undocumented)
export class Ok<T> implements Result<T, never> {
    // (undocumented)
    [Symbol.iterator](): Generator<T, void, unknown>;
    protected constructor(value: T);
    // (undocumented)
    and<U, F>(result: Result<U, F>): Result<U, F>;
    // (undocumented)
    andThen<U, F>(result: Mapper<T, Result<U, F>>): Result<U, F>;
    // (undocumented)
    apply<E, U>(mapper: Result<Mapper<T, U>, E>): Result<U, E>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    err(): None;
    // (undocumented)
    every<U extends T>(refinement: Refinement<T, U>): this is Result<U, never>;
    // (undocumented)
    every(predicate: Predicate<T>): boolean;
    // (undocumented)
    everyErr(): this is this;
    // (undocumented)
    flatMap<U, F>(mapper: Mapper<T, Result<U, F>>): Result<U, F>;
    // (undocumented)
    flatten<T, E>(this: Ok<Result<T, E>>): Result<T, E>;
    // (undocumented)
    get(): T;
    // (undocumented)
    getErrOr<F>(error: F): F;
    // (undocumented)
    getErrOrElse<F>(error: Callback<T, F>): F;
    // @internal (undocumented)
    getErrUnsafe(message?: string): never;
    // (undocumented)
    getOr(): T;
    // (undocumented)
    getOrElse(): T;
    // @internal (undocumented)
    getUnsafe(): T;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    includesErr(): this is never;
    // (undocumented)
    isErr(): this is never;
    // (undocumented)
    isOk(): this is Ok<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Ok<U>;
    // (undocumented)
    mapErr(): Ok<T>;
    // (undocumented)
    mapOrElse<U>(ok: Mapper<T, U>): U;
    // (undocumented)
    none<U extends T>(refinement: Refinement<T, U>): this is Result<Exclude<T, U>, never>;
    // (undocumented)
    none(predicate: Predicate<T>): boolean;
    // (undocumented)
    noneErr(): this is this;
    // (undocumented)
    static of<T>(value: T): Ok<T>;
    // (undocumented)
    ok(): Option<T>;
    // (undocumented)
    or(): Ok<T>;
    // (undocumented)
    orElse(): Ok<T>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    some<U extends T>(refinement: Refinement<T, U>): this is Ok<U>;
    // (undocumented)
    some(predicate: Predicate<T>): boolean;
    // (undocumented)
    someErr(): this is never;
    // (undocumented)
    tee(callback: Callback<T>): Ok<T>;
    // (undocumented)
    teeErr(): Ok<T>;
    // (undocumented)
    toJSON(options?: Serializable.Options): Ok.JSON<T>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Ok {
    // (undocumented)
    export function isOk<T>(value: Iterable<T>): value is Ok<T>;
    // (undocumented)
    export function isOk<T>(value: unknown): value is Ok<T>;
    // (undocumented)
    export interface JSON<T> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "ok";
        // (undocumented)
        value: Serializable.ToJSON<T>;
    }
}

// @public (undocumented)
export interface Result<T, E = T> extends Monad<T>, Foldable<T>, Iterable<T>, Equatable, Hashable, Serializable<Result.JSON<T, E>> {
    // (undocumented)
    and<U, F>(result: Result<U, F>): Result<U, E | F>;
    // (undocumented)
    andThen<U, F>(result: Mapper<T, Result<U, F>>): Result<U, E | F>;
    // (undocumented)
    apply<U>(mapper: Result<Mapper<T, U>, E>): Result<U, E>;
    // (undocumented)
    err(): Option<E>;
    // (undocumented)
    every<U extends T>(refinement: Refinement<T, U>): this is Result<U, E>;
    // (undocumented)
    every(predicate: Predicate<T>): boolean;
    // (undocumented)
    everyErr<F extends E>(refinement: Refinement<E, F>): this is Result<T, F>;
    // (undocumented)
    everyErr(predicate: Predicate<E>): boolean;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Result<U, E>>): Result<U, E>;
    // (undocumented)
    flatten<T, E>(this: Result<Result<T, E>, E>): Result<T, E>;
    // (undocumented)
    getErrOr<F>(error: F): E | F;
    // (undocumented)
    getErrOrElse<F>(error: Callback<T, F>): E | F;
    // @internal
    getErrUnsafe(message?: string): E;
    // (undocumented)
    getOr<U>(value: U): T | U;
    // (undocumented)
    getOrElse<U>(value: Callback<E, U>): T | U;
    // @internal
    getUnsafe(message?: string): T;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    includesErr(error: E): boolean;
    // (undocumented)
    isErr(): this is Err<E>;
    // (undocumented)
    isOk(): this is Ok<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Result<U, E>;
    // (undocumented)
    mapErr<F>(mapper: Mapper<E, F>): Result<T, F>;
    // (undocumented)
    mapOrElse<U>(ok: Mapper<T, U>, err: Mapper<E, U>): U;
    // (undocumented)
    none<U extends T>(refinement: Refinement<T, U>): this is Result<Exclude<T, U>, E>;
    // (undocumented)
    none(predicate: Predicate<T>): boolean;
    // (undocumented)
    noneErr<F extends E>(refinement: Refinement<E, F>): this is Result<T, Exclude<E, F>>;
    // (undocumented)
    noneErr(predicate: Predicate<E>): boolean;
    // (undocumented)
    ok(): Option<T>;
    // (undocumented)
    or<U, F>(result: Result<U, F>): Result<T | U, F>;
    // (undocumented)
    orElse<U, F>(result: Thunk<Result<U, F>>): Result<T | U, F>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    some<U extends T>(refinement: Refinement<T, U>): this is Ok<U>;
    // (undocumented)
    some(predicate: Predicate<T>): boolean;
    // (undocumented)
    someErr<F extends E>(refinement: Refinement<E, F>): this is Err<F>;
    // (undocumented)
    someErr(predicate: Predicate<E>): boolean;
    // (undocumented)
    tee(callback: Callback<T>): Result<T, E>;
    // (undocumented)
    teeErr(callback: Callback<E>): Result<T, E>;
    // (undocumented)
    toJSON(options?: Serializable.Options): Result.JSON<T, E>;
}

// @public (undocumented)
export namespace Result {
    // (undocumented)
    export function from<T, E = unknown>(thunk: Thunk<Promise<T>>): Promise<Result<T, E>>;
    // (undocumented)
    export function from<T, E = unknown>(thunk: Thunk<T>): Result<T, E>;
    // (undocumented)
    export function isErr<T, E>(value: Iterable<T>): value is Err<E>;
    // (undocumented)
    export function isErr<E>(value: unknown): value is Err<E>;
    // (undocumented)
    export function isOk<T>(value: Iterable<T>): value is Ok<T>;
    // (undocumented)
    export function isOk<T>(value: unknown): value is Ok<T>;
    // (undocumented)
    export function isResult<T, E>(value: Iterable<T>): value is Result<T, E>;
    // (undocumented)
    export function isResult<T, E>(value: unknown): value is Result<T, E>;
    // (undocumented)
    export type JSON<T, E = T> = Ok.JSON<T> | Err.JSON<E>;
    // (undocumented)
    export function of<T, E>(value: T): Result<T, E>;
}

// (No @packageDocumentation comment for this package)

```
