## API Report File for "@siteimprove/alfa-slice"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Callback } from '@siteimprove/alfa-callback';
import { Collection } from '@siteimprove/alfa-collection';
import { Comparer } from '@siteimprove/alfa-comparable';
import { Comparison } from '@siteimprove/alfa-comparable';
import { Hash } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Option } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Reducer } from '@siteimprove/alfa-reducer';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Serializable } from '@siteimprove/alfa-json';

// @public (undocumented)
export class Slice<T> implements Collection.Indexed<T> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    // (undocumented)
    append(value: T): Slice<T>;
    // (undocumented)
    apply<U>(mapper: Slice<Mapper<T, U>>): Slice<U>;
    // (undocumented)
    get array(): ReadonlyArray<T>;
    // (undocumented)
    collect<U>(mapper: Mapper<T, Option<U>, [index: number]>): Slice<U>;
    // (undocumented)
    collectFirst<U>(mapper: Mapper<T, Option<U>, [index: number]>): Option<U>;
    // (undocumented)
    compareWith(iterable: Iterable_2<T>, comparer: Comparer<T>): Comparison;
    // (undocumented)
    concat(iterable: Iterable_2<T>): Slice<T>;
    // (undocumented)
    count(predicate: Predicate<T, [index: number]>): number;
    // (undocumented)
    distinct(): Slice<T>;
    // (undocumented)
    static empty<T>(): Slice<T>;
    // (undocumented)
    equals<T>(value: Slice<T>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    every(predicate: Predicate<T, [index: number]>): boolean;
    // (undocumented)
    filter<U extends T>(refinement: Refinement<T, U, [index: number]>): Slice<U>;
    // (undocumented)
    filter(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    find<U extends T>(refinement: Refinement<T, U, [index: number]>): Option<U>;
    // (undocumented)
    find(predicate: Predicate<T, [index: number]>): Option<T>;
    // (undocumented)
    first(): Option<T>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Slice<U>, [index: number]>): Slice<U>;
    // (undocumented)
    forEach(callback: Callback<T, void, [index: number]>): void;
    // (undocumented)
    get(index: number): Option<T>;
    // (undocumented)
    has(index: number): boolean;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    insert(index: number, value: T): Slice<T>;
    // (undocumented)
    intersect(iterable: Iterable_2<T>): Slice<T>;
    // (undocumented)
    isEmpty(): this is Slice<never>;
    // (undocumented)
    iterator(): Iterator<T>;
    // (undocumented)
    join(separator: string): string;
    // (undocumented)
    last(): Option<T>;
    // (undocumented)
    get length(): number;
    // (undocumented)
    map<U>(mapper: Mapper<T, U, [index: number]>): Slice<U>;
    // (undocumented)
    none(predicate: Predicate<T, [index: number]>): boolean;
    // (undocumented)
    static of<T>(array: ReadonlyArray<T>, start?: number, end?: number): Slice<T>;
    // (undocumented)
    get offset(): number;
    // (undocumented)
    prepend(value: T): Slice<T>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    // (undocumented)
    reduceUntil<U>(predicate: Predicate<T, [index: number]>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    // (undocumented)
    reduceWhile<U>(predicate: Predicate<T, [index: number]>, reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
    // (undocumented)
    reject<U extends T>(refinement: Refinement<T, U, [index: number]>): Slice<Exclude<T, U>>;
    // (undocumented)
    reject(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    rest(): Slice<T>;
    // (undocumented)
    reverse(): Slice<T>;
    // (undocumented)
    set(index: number, value: T): Slice<T>;
    // (undocumented)
    get size(): number;
    // (undocumented)
    skip(count: number): Slice<T>;
    // (undocumented)
    skipLast(count: number): Slice<T>;
    // (undocumented)
    skipLastUntil(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    skipLastWhile(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    skipUntil(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    skipWhile(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    slice(start: number, end?: number): Slice<T>;
    // (undocumented)
    some(predicate: Predicate<T, [index: number]>): boolean;
    // (undocumented)
    sortWith(comparer: Comparer<T>): Slice<T>;
    // (undocumented)
    subtract(iterable: Iterable_2<T>): Slice<T>;
    // (undocumented)
    take(count: number): Slice<T>;
    // (undocumented)
    takeLast(count: number): Slice<T>;
    // (undocumented)
    takeLastUntil(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    takeLastWhile<U extends T>(refinement: Refinement<T, U, [index: number]>): Slice<U>;
    // (undocumented)
    takeLastWhile(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    takeUntil(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    takeWhile<U extends T>(refinement: Refinement<T, U, [index: number]>): Slice<U>;
    // (undocumented)
    takeWhile(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    toArray(): Array_2<T>;
    // (undocumented)
    toJSON(): Slice.JSON<T>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    trim(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    trimLeading(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    trimTrailing(predicate: Predicate<T, [index: number]>): Slice<T>;
    // (undocumented)
    zip<U>(iterable: Iterable_2<U>): Slice<[T, U]>;
}

// @public (undocumented)
export namespace Slice {
    // (undocumented)
    export function from<T>(iterable: Iterable_2<T>): Slice<T>;
    // (undocumented)
    export function isSlice<T>(value: Iterable_2<T>): value is Slice<T>;
    // (undocumented)
    export function isSlice<T>(value: unknown): value is Slice<T>;
    // (undocumented)
    export type JSON<T> = Array_2<Serializable.ToJSON<T>>;
}

// (No @packageDocumentation comment for this package)

```
