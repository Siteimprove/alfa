## API Report File for "@siteimprove/alfa-aria"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Attribute as Attribute_2 } from '@siteimprove/alfa-dom';
import { Context } from '@siteimprove/alfa-selector';
import { Device } from '@siteimprove/alfa-device';
import * as dom_2 from '@siteimprove/alfa-dom';
import { Element as Element_2 } from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Flags } from '@siteimprove/alfa-flags';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Namespace } from '@siteimprove/alfa-dom';
import { Node as Node_2 } from '@siteimprove/alfa-dom';
import { Option } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';
import { Text as Text_2 } from '@siteimprove/alfa-dom';
import { Thunk } from '@siteimprove/alfa-thunk';
import * as tree from '@siteimprove/alfa-tree';

// @public (undocumented)
export class Attribute<N extends Attribute.Name = Attribute.Name> implements Equatable, Serializable {
    // (undocumented)
    get default(): Option<Attribute.Default<N>>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    isGlobal(): this is Attribute<Attribute.Global>;
    // (undocumented)
    get kind(): Attribute.Kind<N>;
    // (undocumented)
    get name(): N;
    // (undocumented)
    static of<N extends Attribute.Name>(name: N, value: string): Attribute<N>;
    // (undocumented)
    get options(): Sequence<Attribute.Option<N>>;
    // (undocumented)
    toJSON(): Attribute.JSON;
    // (undocumented)
    get type(): Attribute.Type<N>;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
export namespace Attribute {
    export type Default<N extends Name = Name> = Exclude<Attributes[N]["default"], null>;
    // Warning: (ae-forgotten-export) The symbol "Members" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "Roles" needs to be exported by the entry point index.d.ts
    export type Global = Members<Roles["roletype"]["attributes"]>[0];
    // (undocumented)
    export function isName(value: string): value is Name;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        name: Name;
        // (undocumented)
        value: string;
    }
    export type Kind<N extends Name = Name> = Attributes[N]["kind"];
    // Warning: (ae-forgotten-export) The symbol "Attributes" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export type Name = keyof Attributes;
    export type Option<N extends Name = Name> = Members<Attributes[N]["options"]>;
    export type Type<N extends Name = Name> = Attributes[N]["type"];
}

// @public (undocumented)
export class Container extends Node<"container"> {
    // (undocumented)
    clone(parent?: Option<Node>): Container;
    // (undocumented)
    isIgnored(): boolean;
    // (undocumented)
    static of(owner: dom_2.Node, children?: Iterable<Node>): Container;
    // (undocumented)
    toString(): string;
}

// @public
export namespace DOM {
    const // Warning: (ae-forgotten-export) The symbol "dom" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasAccessibleName: typeof dom.hasAccessibleName, // (undocumented)
    hasExplicitRole: typeof dom.hasExplicitRole, // (undocumented)
    hasHeadingLevel: typeof dom.hasHeadingLevel, // (undocumented)
    hasImplicitRole: typeof dom.hasImplicitRole, // (undocumented)
    hasIncorrectRoleWithoutName: typeof dom.hasIncorrectRoleWithoutName, // (undocumented)
    hasNonDefaultRole: typeof dom.hasNonDefaultRole, // (undocumented)
    hasNonEmptyAccessibleName: typeof dom.hasNonEmptyAccessibleName, // (undocumented)
    hasRole: typeof dom.hasRole, // (undocumented)
    isIgnored: typeof dom.isIgnored, // (undocumented)
    isIncludedInTheAccessibilityTree: typeof dom.isIncludedInTheAccessibilityTree, // (undocumented)
    isMarkedDecorative: Predicate<Element_2<string>, []>, // (undocumented)
    isPerceivableForAll: typeof dom.isPerceivableForAll, // (undocumented)
    isProgrammaticallyHidden: typeof dom.isProgrammaticallyHidden, // (undocumented)
    isSemanticallyDisabled: Predicate<Element_2<string>, []>;
}

// @public (undocumented)
export class Element extends Node<"element"> {
    // (undocumented)
    attribute<N extends Attribute.Name>(refinement: Refinement<Attribute, Attribute<N>>): Option<Attribute<N>>;
    // (undocumented)
    attribute(predicate: Predicate<Attribute>): Option<Attribute>;
    // (undocumented)
    attribute<N extends Attribute.Name>(predicate: N): Option<Attribute<N>>;
    // (undocumented)
    get attributes(): ReadonlyArray<Attribute>;
    // (undocumented)
    clone(): Element;
    // (undocumented)
    isIgnored(): boolean;
    // (undocumented)
    get name(): Option<Name>;
    // (undocumented)
    static of(owner: dom_2.Node, role?: Option<Role>, name?: Option<Name>, attributes?: Iterable_2<Attribute>, children?: Iterable_2<Node>): Element;
    // (undocumented)
    get role(): Option<Role>;
    // (undocumented)
    toJSON(): Element.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Element {
    // (undocumented)
    export interface JSON extends Node.JSON<"element"> {
        // (undocumented)
        attributes: Array<Attribute.JSON>;
        // (undocumented)
        name: string | null;
        // (undocumented)
        role: string | null;
    }
}

// Warning: (ae-internal-missing-underscore) The name "Feature" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Feature {
    // (undocumented)
    get attributes(): Feature.AttributesAspect;
    // (undocumented)
    get name(): Feature.NameAspect;
    // (undocumented)
    static of(role?: Feature.RoleAspect, attributes?: Feature.AttributesAspect, name?: Feature.NameAspect): Feature;
    // (undocumented)
    get role(): Feature.RoleAspect;
}

// @internal (undocumented)
export namespace Feature {
    // (undocumented)
    export type Aspect<T, A extends Array<unknown> = []> = Mapper<Element_2, T, A>;
    // (undocumented)
    export type AttributesAspect = Aspect<Iterable_2<Attribute>>;
    // (undocumented)
    export function from(namespace: Namespace, name: string): Option<Feature>;
    // (undocumented)
    export type NameAspect = Aspect<Option<Name>, [Device, Name.State]>;
    // (undocumented)
    export type RoleAspect = Aspect<Iterable_2<Role>>;
}

// @public (undocumented)
function hasAccessibleName<T extends Element_2 | Text_2>(device: Device, predicate?: Predicate<Name>): Predicate<T>;

// @public (undocumented)
function hasAccessibleName<T extends Element_2 | Text_2>(device: Device, name: string, ...rest: Array<string>): Predicate<T>;

// @public (undocumented)
function hasExplicitRole(predicate?: Predicate<Role>): Predicate<Element_2>;

// @public (undocumented)
function hasExplicitRole<N extends Role.Name>(name: N, ...rest: Array<N>): Predicate<Element_2>;

// @public (undocumented)
function hasHeadingLevel(device: Device, predicate?: Predicate<number>): Predicate<Element_2>;

// @public (undocumented)
function hasImplicitRole(predicate?: Predicate<Role>): Predicate<Element_2>;

// @public (undocumented)
function hasImplicitRole<N extends Role.Name>(name: N, ...rest: Array<N>): Predicate<Element_2>;

// @public (undocumented)
function hasIncorrectRoleWithoutName(device: Device): Predicate<Element_2>;

// @public (undocumented)
function hasName<N extends Role.Name>(refinement: Refinement<Role.Name, N>): Refinement<Role, Role<N>>;

// @public (undocumented)
function hasName(predicate: Predicate<Role.Name>): Predicate<Role>;

// @public (undocumented)
function hasName<N extends Role.Name>(name: N, ...rest: Array<N>): Refinement<Role, Role<N>>;

// @public (undocumented)
function hasName_2(predicate?: Predicate<Name>): Predicate<Node>;

// @public (undocumented)
function hasName_2(name: string, ...rest: Array<string>): Predicate<Node>;

// @public (undocumented)
function hasNonDefaultRole(element: Element_2): boolean;

// @public (undocumented)
function hasNonEmptyAccessibleName<T extends Element_2 | Text_2>(device: Device): Predicate<T>;

// @public (undocumented)
function hasRole(device: Device, predicate?: Predicate<Role>): Predicate<Element_2>;

// @public (undocumented)
function hasRole<N extends Role.Name>(device: Device, name: N, ...rest: Array<N>): Predicate<Element_2>;

// @public (undocumented)
function hasValue(predicate: Predicate<string>): Predicate<Name>;

// @public (undocumented)
function hasValue(value: string, ...rest: Array<string>): Predicate<Name>;

// @public (undocumented)
export class Inert extends Node<"inert"> {
    // (undocumented)
    clone(): Inert;
    // (undocumented)
    isIgnored(): boolean;
    // (undocumented)
    static of(owner: dom_2.Node): Inert;
    // (undocumented)
    toJSON(): Node.JSON<"inert">;
    // (undocumented)
    toString(): string;
}

// @public
function isIgnored<T extends Node_2>(device: Device): Predicate<T>;

// @public
function isIncludedInTheAccessibilityTree<T extends Node_2>(device: Device): Predicate<T>;

// @public
const isMarkedDecorative: Predicate<Element_2>;

// @public
function isPerceivableForAll<T extends Node_2>(device: Device): Predicate<T>;

// @public
function isProgrammaticallyHidden(device: Device, context?: Context): Predicate<Element_2>;

// @public
const isSemanticallyDisabled: Predicate<Element_2>;

// @public (undocumented)
export class Name implements Equatable, Serializable<Name.JSON> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    static of(value: string, sources?: Iterable_2<Name.Source>): Name;
    // (undocumented)
    get source(): ReadonlyArray<Name.Source>;
    // (undocumented)
    sourceNodes(): Iterable_2<Node_2>;
    // (undocumented)
    toJSON(): Name.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
export namespace Name {
    // (undocumented)
    export function from(node: Element_2 | Text_2, device: Device): Option<Name>;
    // @internal (undocumented)
    export function fromData(text: Text_2): Option<Name>;
    // @internal (undocumented)
    export function fromDescendants(element: Element_2, device: Device, state: State): Option<Name>;
    // @internal (undocumented)
    export function fromElement(element: Element_2, device: Device, state: State): Option<Name>;
    // @internal (undocumented)
    export function fromLabel(attribute: Attribute_2): Option<Name>;
    // @internal (undocumented)
    export function fromNode(node: Element_2 | Text_2, device: Device, state: State): Option<Name>;
    // @internal (undocumented)
    export function fromReferences(attribute: Attribute_2, referrer: Element_2, device: Device, state: State): Option<Name>;
    // @internal (undocumented)
    export function fromSteps(...steps: Array_2<Thunk<Option<Name>>>): Option<Name>;
    // @internal (undocumented)
    export function fromText(text: Text_2): Option<Name>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        sources: Array_2<Source.JSON>;
        // (undocumented)
        value: string;
    }
    // (undocumented)
    export type Source = Source.Data | Source.Descendant | Source.Ancestor | Source.Label | Source.Reference;
    // (undocumented)
    export namespace Source {
        // (undocumented)
        export class Ancestor implements Equatable, Serializable<Ancestor.JSON> {
            // (undocumented)
            [Symbol.iterator](): Iterator<Node_2>;
            // (undocumented)
            get element(): Element_2;
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get name(): Name;
            // (undocumented)
            static of(element: Element_2, name: Name): Ancestor;
            // (undocumented)
            toJSON(): Ancestor.JSON;
            // (undocumented)
            get type(): "ancestor";
        }
        // (undocumented)
        export namespace Ancestor {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                element: string;
                // (undocumented)
                name: Name.JSON;
                // (undocumented)
                type: "ancestor";
            }
        }
        // (undocumented)
        export function ancestor(element: Element_2, name: Name): Ancestor;
        // (undocumented)
        export class Data implements Equatable, Serializable<Data.JSON> {
            // (undocumented)
            [Symbol.iterator](): Iterator<Node_2>;
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            static of(text: Text_2): Data;
            // (undocumented)
            get text(): Text_2;
            // (undocumented)
            toJSON(): Data.JSON;
            // (undocumented)
            get type(): "data";
        }
        // (undocumented)
        export namespace Data {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                text: string;
                // (undocumented)
                type: "data";
            }
        }
        // (undocumented)
        export function data(text: Text_2): Data;
        // (undocumented)
        export class Descendant implements Equatable, Serializable<Descendant.JSON> {
            // (undocumented)
            [Symbol.iterator](): Iterator<Node_2>;
            // (undocumented)
            get element(): Element_2;
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get name(): Name;
            // (undocumented)
            static of(element: Element_2, name: Name): Descendant;
            // (undocumented)
            toJSON(): Descendant.JSON;
            // (undocumented)
            get type(): "descendants";
        }
        // (undocumented)
        export namespace Descendant {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                element: string;
                // (undocumented)
                name: Name.JSON;
                // (undocumented)
                type: "descendant";
            }
        }
        // (undocumented)
        export function descendant(element: Element_2, name: Name): Descendant;
        // (undocumented)
        export type JSON = Data.JSON | Descendant.JSON | Ancestor.JSON | Label.JSON | Reference.JSON;
        // (undocumented)
        export class Label implements Equatable, Serializable<Label.JSON> {
            // (undocumented)
            [Symbol.iterator](): Iterator<Node_2>;
            // (undocumented)
            get attribute(): Attribute_2;
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            static of(attribute: Attribute_2): Label;
            // (undocumented)
            toJSON(): Label.JSON;
            // (undocumented)
            get type(): "label";
        }
        // (undocumented)
        export namespace Label {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                attribute: string;
                // (undocumented)
                type: "label";
            }
        }
        // (undocumented)
        export function label(attribute: Attribute_2): Label;
        // (undocumented)
        export class Reference implements Equatable, Serializable<Reference.JSON> {
            // (undocumented)
            [Symbol.iterator](): Iterator<Node_2>;
            // (undocumented)
            get attribute(): Attribute_2;
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get name(): Name;
            // (undocumented)
            static of(attribute: Attribute_2, name: Name): Reference;
            // (undocumented)
            toJSON(): Reference.JSON;
            // (undocumented)
            get type(): "reference";
        }
        // (undocumented)
        export namespace Reference {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                attribute: string;
                // (undocumented)
                name: Name.JSON;
                // (undocumented)
                type: "reference";
            }
        }
        // (undocumented)
        export function reference(attribute: Attribute_2, name: Name): Reference;
    }
    // @internal (undocumented)
    export class State implements Equatable, Serializable<State.JSON> {
        // (undocumented)
        descend(isDescending: boolean): State;
        // (undocumented)
        static empty(): State;
        // (undocumented)
        equals(state: State): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasVisited(element: Element_2): boolean;
        get isDescending(): boolean;
        get isRecursing(): boolean;
        get isReferencing(): boolean;
        // (undocumented)
        recurse(isRecursing: boolean): State;
        // (undocumented)
        reference(referrer: Option<Element_2>): State;
        get referrer(): Option<Element_2>;
        // (undocumented)
        toJSON(): State.JSON;
        // (undocumented)
        visit(element: Element_2): State;
        get visited(): Iterable_2<Element_2>;
    }
    // (undocumented)
    export namespace State {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            isDescending: boolean;
            // (undocumented)
            isRecursing: boolean;
            // (undocumented)
            referrer: string | null;
            // (undocumented)
            visited: Array_2<string>;
        }
    }
    const // Warning: (ae-forgotten-export) The symbol "predicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasValue: typeof predicate.hasValue;
}

// @public (undocumented)
export abstract class Node<T extends string = string> extends tree.Node<Node.Traversal.Flag, T> implements Serializable<Node.JSON<T>> {
    protected constructor(owner: dom_2.Node, children: Array<Node>, type: T);
    // (undocumented)
    attribute<N extends Attribute.Name>(refinement: Refinement<Attribute, Attribute<N>>): Option<Attribute<N>>;
    // (undocumented)
    attribute(predicate: Predicate<Attribute>): Option<Attribute>;
    // (undocumented)
    attribute<N extends Attribute.Name>(name: N): Option<Attribute<N>>;
    // (undocumented)
    children(options?: Node.Traversal): Sequence<Node>;
    // (undocumented)
    abstract clone(parent?: Option<Node>): Node;
    // (undocumented)
    abstract isIgnored(): boolean;
    // (undocumented)
    get name(): Option<Name>;
    // (undocumented)
    get node(): dom_2.Node;
    // (undocumented)
    protected readonly _node: dom_2.Node;
    // (undocumented)
    parent(options?: Node.Traversal): Option<Node>;
    // (undocumented)
    get role(): Option<Role>;
    // (undocumented)
    toJSON(): Node.JSON<T>;
}

// @public (undocumented)
export interface Node {
    // (undocumented)
    ancestors(options?: Node.Traversal): Sequence<Node>;
    // (undocumented)
    closest<T extends Node>(refinement: Refinement<Node, T>, options?: Node.Traversal): Option<T>;
    // (undocumented)
    closest(predicate: Predicate<Node>, options?: Node.Traversal): Option<Node>;
    // (undocumented)
    descendants(options?: Node.Traversal): Sequence<Node>;
    // (undocumented)
    first(options?: Node.Traversal): Option<Node>;
    // (undocumented)
    following(options?: Node.Traversal): Sequence<Node>;
    // (undocumented)
    inclusiveAncestors(options?: Node.Traversal): Sequence<Node>;
    // (undocumented)
    inclusiveDescendants(options?: Node.Traversal): Sequence<Node>;
    // (undocumented)
    inclusiveSiblings(options?: Node.Traversal): Sequence<Node>;
    // (undocumented)
    index(options?: Node.Traversal): number;
    // (undocumented)
    isAncestorOf(node: Node, options?: Node.Traversal): boolean;
    // (undocumented)
    isChildOf(node: Node, options?: Node.Traversal): boolean;
    // (undocumented)
    isDescendantOf(node: Node, options?: Node.Traversal): boolean;
    // (undocumented)
    isInclusiveAncestorOf(node: Node, options?: Node.Traversal): boolean;
    // (undocumented)
    isInclusiveDescendantsOf(node: Node, options?: Node.Traversal): boolean;
    // (undocumented)
    isInclusiveSiblingOf(node: Node, options?: Node.Traversal): boolean;
    // (undocumented)
    isParentOf(node: Node, options?: Node.Traversal): boolean;
    // (undocumented)
    isRootOf(node: Node, options?: Node.Traversal): boolean;
    // (undocumented)
    isSiblingOf(node: Node, options?: Node.Traversal): boolean;
    // (undocumented)
    last(options?: Node.Traversal): Option<Node>;
    // (undocumented)
    next(options?: Node.Traversal): Option<Node>;
    // (undocumented)
    preceding(options?: Node.Traversal): Sequence<Node>;
    // (undocumented)
    previous(options?: Node.Traversal): Option<Node>;
    // (undocumented)
    root(options?: Node.Traversal): Node;
    // (undocumented)
    siblings(options?: Node.Traversal): Sequence<Node>;
}

// @public (undocumented)
export namespace Node {
    // (undocumented)
    export function from(node: dom_2.Node, device: Device): Node;
    // (undocumented)
    export interface JSON<T extends string = string> extends tree.Node.JSON<T> {
        // (undocumented)
        node: string;
    }
    // (undocumented)
    export class Traversal extends Flags<Traversal.Flag> {
        // (undocumented)
        static of(...flags: Array<Traversal.Flag>): Traversal;
    }
    const includeIgnored: Traversal;
    // (undocumented)
    export namespace Traversal {
        // (undocumented)
        export type Flag = 0 | 1;
        const // (undocumented)
        none: Flag;
        const ignored: Flag;
        const // (undocumented)
        empty: Traversal;
    }
    const // Warning: (ae-forgotten-export) The symbol "predicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasName: typeof predicate_3.hasName;
}

// @public (undocumented)
export class Role<N extends Role.Name = Role.Name> implements Equatable, Hashable, Serializable {
    get attributes(): ReadonlyArray<Attribute.Name>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    hasName<N extends Role.Name>(name: N): this is Role<N>;
    hasPresentationalChildren(): boolean;
    hasRequiredChildren(): boolean;
    hasRequiredParent(): boolean;
    implicitAttributeValue(name: Attribute.Name): Option<string>;
    is<N extends Role.Name>(name: N): this is Role<N | Role.SubclassOf<N>>;
    isAbstract(): this is Role<Role.Abstract>;
    isAttributeRequired(name: Attribute.Name): boolean;
    isAttributeSupported(name: Attribute.Name): boolean;
    isConcrete(): this is Role<Role.Concrete>;
    isLandmark(): this is Role<Role.Landmark>;
    isNamedBy(method: Role.NamedBy): boolean;
    isNameProhibited(): boolean;
    isPresentational(): this is Role<Role.Presentational>;
    isSubclassOf<N extends Role.Name>(name: N): this is Role<Role.SubclassOf<N>>;
    isSuperclassOf<N extends Role.Name>(name: N): this is Role<Role.SuperclassOf<N>>;
    isWidget(): this is Role<Role.Widget>;
    // (undocumented)
    get name(): N;
    // (undocumented)
    static of<N extends Role.Name>(name: N): Role<N>;
    get requiredChildren(): ReadonlyArray<ReadonlyArray<Role.Name>>;
    get requiredParent(): ReadonlyArray<ReadonlyArray<Role.Name>>;
    // (undocumented)
    toJSON(): Role.JSON;
}

// @public (undocumented)
export namespace Role {
    export type Abstract = {
        [N in Name]: Roles[N]["abstract"] extends true ? N : never;
    }[Name];
    export type Concrete = Exclude<Name, Abstract>;
    export function from(element: Element_2): Option<Role>;
    export function fromExplicit(element: Element_2): Option<Role>;
    export function fromImplicit(element: Element_2): Option<Role>;
    // Warning: (ae-forgotten-export) The symbol "Members" needs to be exported by the entry point index.d.ts
    export type Inherited<N extends Name> = N extends "roletype" | "none" ? never : Members_2<Roles[N]["inherited"]>;
    // (undocumented)
    export function isName(value: string): value is Name;
    // (undocumented)
    export function isRole<N extends Name>(value: unknown, name?: N): value is Role<Name>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        name: Name;
    }
    export type Landmark = SubclassOf<"landmark">;
    // (undocumented)
    export type Name = keyof Roles;
    export type NamedBy<N extends Name = Name> = Members_2<Roles[N]["name"]["from"]>;
    export type Presentational = "presentation" | "none";
    export type SubclassOf<N extends Name> = {
        [M in Name]: N extends SuperclassOf<M> ? M : never;
    }[Name];
    export type SuperclassOf<N extends Name> = N extends "roletype" | "none" ? never : Inherited<N> | {
        [M in Inherited<N>]: SuperclassOf<M>;
    }[Inherited<N>];
    export type Widget = SubclassOf<"widget">;
    const // Warning: (ae-forgotten-export) The symbol "predicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasName: typeof predicate_2.hasName;
}

// @public (undocumented)
export class Text extends Node<"text"> {
    // (undocumented)
    clone(): Text;
    // (undocumented)
    isIgnored(): boolean;
    // (undocumented)
    get name(): Option<Name>;
    // (undocumented)
    static of(owner: dom_2.Node, name: Option<Name>): Text;
    // (undocumented)
    toJSON(): Text.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Text {
    // (undocumented)
    export interface JSON extends Node.JSON<"text"> {
        // (undocumented)
        name: string | null;
    }
}

```
