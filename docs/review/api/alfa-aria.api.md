## API Report File for "@siteimprove/alfa-aria"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Attribute as Attribute_2 } from '@siteimprove/alfa-dom';
import { Context } from '@siteimprove/alfa-selector';
import { Device } from '@siteimprove/alfa-device';
import * as dom_2 from '@siteimprove/alfa-dom';
import { Element as Element_3 } from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Flags } from '@siteimprove/alfa-flags';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Namespace } from '@siteimprove/alfa-dom';
import { Node as Node_3 } from '@siteimprove/alfa-dom';
import { Option as Option_2 } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';
import { Text as Text_3 } from '@siteimprove/alfa-dom';
import { Thunk } from '@siteimprove/alfa-thunk';
import * as tree from '@siteimprove/alfa-tree';

// @public (undocumented)
export class Attribute<N extends Attribute.Name = Attribute.Name> implements Equatable, Serializable {
    // (undocumented)
    get default(): Option_2<Attribute.Default<N>>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    isGlobal(): this is Attribute<Attribute.Global>;
    // (undocumented)
    get kind(): Attribute.Kind<N>;
    // (undocumented)
    get name(): N;
    // (undocumented)
    static of<N extends Attribute.Name>(name: N, value: string): Attribute<N>;
    // (undocumented)
    get options(): Sequence<Attribute.Option<N>>;
    // (undocumented)
    toJSON(): Attribute.JSON;
    // (undocumented)
    get type(): Attribute.Type<N>;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
export namespace Attribute {
    export type Default<N extends Name = Name> = Exclude<Attributes[N]["default"], null>;
    // Warning: (ae-forgotten-export) The symbol "Members" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "Roles" needs to be exported by the entry point index.d.ts
    export type Global = Members<Roles["roletype"]["attributes"]>[0];
    // (undocumented)
    export function isName(value: string): value is Name;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        name: Name;
        // (undocumented)
        value: string;
    }
    export type Kind<N extends Name = Name> = Attributes[N]["kind"];
    // Warning: (ae-forgotten-export) The symbol "Attributes" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export type Name = keyof Attributes;
    export type Option<N extends Name = Name> = Members<Attributes[N]["options"]>;
    export type Type<N extends Name = Name> = Attributes[N]["type"];
}

// @public (undocumented)
export class Container extends Node_2<"container"> {
    // (undocumented)
    clone(parent?: Option_2<Node_2>): Container;
    // (undocumented)
    isIgnored(): boolean;
    // (undocumented)
    static of(owner: dom_2.Node, children?: Iterable<Node_2>, role?: Option_2<Role>): Container;
    // (undocumented)
    get role(): Option_2<Role>;
    // (undocumented)
    toJSON(): Container.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Container {
    // (undocumented)
    export interface JSON extends Node_2.JSON<"container"> {
        // (undocumented)
        role: Role.Name | null;
    }
}

// @public
export namespace DOM {
    const // Warning: (ae-forgotten-export) The symbol "dom" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasAccessibleName: typeof dom.hasAccessibleName, // (undocumented)
    hasExplicitRole: typeof dom.hasExplicitRole, // (undocumented)
    hasHeadingLevel: typeof dom.hasHeadingLevel, // (undocumented)
    hasImplicitRole: typeof dom.hasImplicitRole, // (undocumented)
    hasIncorrectRoleWithoutName: typeof dom.hasIncorrectRoleWithoutName, // (undocumented)
    hasNonDefaultRole: typeof dom.hasNonDefaultRole, // (undocumented)
    hasNonEmptyAccessibleName: typeof dom.hasNonEmptyAccessibleName, // (undocumented)
    hasRole: typeof dom.hasRole, // (undocumented)
    isIgnored: typeof dom.isIgnored, // (undocumented)
    isIncludedInTheAccessibilityTree: typeof dom.isIncludedInTheAccessibilityTree, // (undocumented)
    isMarkedDecorative: Predicate<Element_3<string>>, // (undocumented)
    isPerceivableForAll: typeof dom.isPerceivableForAll, // (undocumented)
    isProgrammaticallyHidden: typeof dom.isProgrammaticallyHidden, // (undocumented)
    isSemanticallyDisabled: Predicate<Element_3<string>>;
}

// @public (undocumented)
class Element_2 extends Node_2<"element"> {
    // (undocumented)
    attribute<N extends Attribute.Name>(refinement: Refinement<Attribute, Attribute<N>>): Option_2<Attribute<N>>;
    // (undocumented)
    attribute(predicate: Predicate<Attribute>): Option_2<Attribute>;
    // (undocumented)
    attribute<N extends Attribute.Name>(predicate: N): Option_2<Attribute<N>>;
    // (undocumented)
    get attributes(): ReadonlyArray<Attribute>;
    // (undocumented)
    clone(): Element_2;
    // (undocumented)
    isIgnored(): boolean;
    // (undocumented)
    get name(): Option_2<Name>;
    // (undocumented)
    static of(owner: dom_2.Node, role?: Option_2<Role>, name?: Option_2<Name>, attributes?: Iterable_2<Attribute>, children?: Iterable_2<Node_2>): Element_2;
    // (undocumented)
    get role(): Option_2<Role>;
    // (undocumented)
    toJSON(): Element_2.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Element_2 {
    // (undocumented)
    interface JSON extends Node_2.JSON<"element"> {
        // (undocumented)
        attributes: Array<Attribute.JSON>;
        // (undocumented)
        name: string | null;
        // (undocumented)
        role: Role.Name | null;
    }
}
export { Element_2 as Element }

// Warning: (ae-internal-missing-underscore) The name "Feature" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Feature {
    // (undocumented)
    get attributes(): Feature.AttributesAspect;
    // (undocumented)
    get name(): Feature.NameAspect;
    // (undocumented)
    static of(role?: Role.Name | Feature.Aspect<Role.Name | Iterable_2<Role>>, attributes?: Feature.AttributesAspect, name?: Feature.NameAspect): Feature;
    // (undocumented)
    get role(): Feature.RoleAspect;
}

// @internal (undocumented)
export namespace Feature {
    // (undocumented)
    export type Aspect<T, A extends Array<unknown> = []> = Mapper<Element_3, T, A>;
    // (undocumented)
    export type AttributesAspect = Aspect<Iterable_2<Attribute>>;
    // (undocumented)
    export function from(namespace: Namespace, name: string): Option_2<Feature>;
    // (undocumented)
    export type NameAspect = Aspect<Option_2<Name>, [Device, State]>;
    // (undocumented)
    export type RoleAspect = Aspect<Iterable_2<Role>>;
    const // (undocumented)
    generic: Feature;
}

// @public (undocumented)
export function hasValue(predicate: Predicate<string>): Predicate<Name>;

// @public (undocumented)
export function hasValue(value: string, ...rest: Array<string>): Predicate<Name>;

// @public (undocumented)
export class Inert extends Node_2<"inert"> {
    // (undocumented)
    clone(): Inert;
    // (undocumented)
    isIgnored(): boolean;
    // (undocumented)
    static of(owner: dom_2.Node): Inert;
    // (undocumented)
    toJSON(): Node_2.JSON<"inert">;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export class Name implements Equatable, Serializable<Name.JSON> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get hasSpaces(): boolean;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    static join(...names: Array_2<Name>): Name;
    normalize(): Name;
    // (undocumented)
    static of(value: string, sources?: Iterable_2<Source>, spaces?: {
        before?: boolean;
        after?: boolean;
    }): Name;
    // (undocumented)
    get source(): ReadonlyArray<Source>;
    // (undocumented)
    sourceNodes(): Iterable_2<Node_3>;
    spaced(spaceBefore: boolean, spaceAfter?: boolean): Name;
    // (undocumented)
    get spaces(): {
        before: boolean;
        after: boolean;
    };
    // (undocumented)
    toJSON(): Name.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
export namespace Name {
    // (undocumented)
    export function from(node: Element_3 | Text_3, device: Device): Option_2<Name>;
    // @internal (undocumented)
    export function fromDescendants(element: Element_3, device: Device, state: State): Option_2<Name>;
    // @internal (undocumented)
    export function fromElement(element: Element_3, device: Device, state: State): Option_2<Name>;
    // @internal (undocumented)
    export function fromLabel(attribute: Attribute_2): Option_2<Name>;
    // @internal (undocumented)
    export function fromNode(node: Element_3 | Text_3, device: Device, state: State): Option_2<Name>;
    // @internal (undocumented)
    export function fromReferences(attribute: Attribute_2, referrer: Element_3, device: Device, state: State): Option_2<Name>;
    // @internal (undocumented)
    export function fromSteps(...steps: Array_2<Thunk<Option_2<Name>>>): Option_2<Name>;
    // @internal (undocumented)
    export function fromText(text: Text_3): Option_2<Name>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        sources: Array_2<Source.JSON>;
        // (undocumented)
        spaces: {
            before: boolean;
            after: boolean;
        };
        // (undocumented)
        value: string;
    }
    const // Warning: (ae-forgotten-export) The symbol "predicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasValue: typeof predicate.hasValue;
}

// @public (undocumented)
abstract class Node_2<T extends string = string> extends tree.Node<Node_2.Traversal.Flag, T> implements Serializable<Node_2.JSON<T>> {
    protected constructor(owner: dom_2.Node, children: Array<Node_2>, type: T);
    // (undocumented)
    attribute<N extends Attribute.Name>(refinement: Refinement<Attribute, Attribute<N>>): Option_2<Attribute<N>>;
    // (undocumented)
    attribute(predicate: Predicate<Attribute>): Option_2<Attribute>;
    // (undocumented)
    attribute<N extends Attribute.Name>(name: N): Option_2<Attribute<N>>;
    // (undocumented)
    children(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    abstract clone(parent?: Option_2<Node_2>): Node_2;
    // (undocumented)
    abstract isIgnored(): boolean;
    // (undocumented)
    get name(): Option_2<Name>;
    // (undocumented)
    get node(): dom_2.Node;
    // (undocumented)
    protected readonly _node: dom_2.Node;
    // (undocumented)
    parent(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    get role(): Option_2<Role>;
    // (undocumented)
    toJSON(): Node_2.JSON<T>;
}

// @public (undocumented)
interface Node_2 {
    // (undocumented)
    ancestors(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    closest<T extends Node_2>(refinement: Refinement<Node_2, T>, options?: Node_2.Traversal): Option_2<T>;
    // (undocumented)
    closest(predicate: Predicate<Node_2>, options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    descendants(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    first(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    following(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    inclusiveAncestors(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    inclusiveDescendants(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    inclusiveSiblings(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    index(options?: Node_2.Traversal): number;
    // (undocumented)
    isAncestorOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isChildOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isDescendantOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isInclusiveAncestorOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isInclusiveDescendantsOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isInclusiveSiblingOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isParentOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isRootOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isSiblingOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    last(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    next(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    preceding(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    previous(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    root(options?: Node_2.Traversal): Node_2;
    // (undocumented)
    siblings(options?: Node_2.Traversal): Sequence<Node_2>;
}

// @public (undocumented)
namespace Node_2 {
    // (undocumented)
    function from(node: dom_2.Node, device: Device): Node_2;
    // (undocumented)
    interface JSON<T extends string = string> extends tree.Node.JSON<T> {
        // (undocumented)
        node: string;
    }
    // (undocumented)
    class Traversal extends Flags<Traversal.Flag> {
        // (undocumented)
        static of(...flags: Array<Traversal.Flag>): Traversal;
    }
    const includeIgnored: Traversal;
    // (undocumented)
    namespace Traversal {
        // (undocumented)
        type Flag = 0 | 1;
        const // (undocumented)
        none: Flag;
        const ignored: Flag;
        const // (undocumented)
        empty: Traversal;
    }
    const // Warning: (ae-forgotten-export) The symbol "predicate_3" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasAttribute: typeof predicate_3.hasAttribute, // (undocumented)
    hasName: typeof predicate_3.hasName, // (undocumented)
    hasRole: typeof predicate_3.hasRole;
}
export { Node_2 as Node }

// @public (undocumented)
export class Role<N extends Role.Name = Role.Name> implements Equatable, Hashable, Serializable {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    hasName<N extends Role.Name>(name: N): this is Role<N>;
    hasPresentationalChildren(): boolean;
    hasRequiredChildren(): boolean;
    hasRequiredParent(): boolean;
    implicitAttributeValue(name: Attribute.Name): Option_2<string>;
    is<N extends Role.Name>(name: N): this is Role<N | Role.SubclassOf<N>>;
    isAbstract(): this is Role<Role.Abstract>;
    isAttributeProhibited(name: Attribute.Name): boolean;
    isAttributeRequired(name: Attribute.Name): boolean;
    isAttributeSupported(name: Attribute.Name): boolean;
    isConcrete(): this is Role<Role.Concrete>;
    isLandmark(): this is Role<Role.Landmark>;
    isNamedBy(method: Role.NamedBy): boolean;
    isNameProhibited(): boolean;
    isPresentational(): this is Role<Role.Presentational>;
    isSubclassOf<N extends Role.Name>(name: N): this is Role<Role.SubclassOf<N>>;
    isSuperclassOf<N extends Role.Name>(name: N): this is Role<Role.SuperclassOf<N>>;
    isWidget(): this is Role<Role.Widget>;
    // (undocumented)
    get name(): N;
    // (undocumented)
    static of<N extends Role.Name>(name: N): Role<N>;
    get prohibitedAttributes(): ReadonlyArray<Attribute.Name>;
    get requiredAttributes(): ReadonlyArray<Attribute.Name>;
    get requiredChildren(): ReadonlyArray<ReadonlyArray<Role.Name>>;
    get requiredParent(): ReadonlyArray<ReadonlyArray<Role.Name>>;
    get supportedAttributes(): ReadonlyArray<Attribute.Name>;
    // (undocumented)
    toJSON(): Role.JSON;
}

// @public (undocumented)
export namespace Role {
    export type Abstract = {
        [N in Name]: Roles[N]["abstract"] extends true ? N : never;
    }[Name];
    export type Concrete = Exclude<Name, Abstract>;
    export function from(element: Element_3): Option_2<Role>;
    export function fromExplicit(element: Element_3): Option_2<Role>;
    export function fromImplicit(element: Element_3): Option_2<Role>;
    // Warning: (ae-forgotten-export) The symbol "Members_2" needs to be exported by the entry point index.d.ts
    export type Inherited<N extends Name> = N extends "roletype" | "none" ? never : Members_2<Roles[N]["inherited"]>;
    // (undocumented)
    export function isName(value: string): value is Name;
    // (undocumented)
    export function isRole<N extends Name>(value: unknown, name?: N): value is Role<Name>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        name: Name;
    }
    export type Landmark = SubclassOf<"landmark">;
    // (undocumented)
    export type Name = keyof Roles;
    export type NamedBy<N extends Name = Name> = Members_2<Roles[N]["name"]["from"]>;
    export type Presentational = "presentation" | "none";
    export type SubclassOf<N extends Name> = {
        [M in Name]: N extends SuperclassOf<M> ? M : never;
    }[Name];
    export type SuperclassOf<N extends Name> = N extends "roletype" | "none" ? never : Inherited<N> | {
        [M in Inherited<N>]: SuperclassOf<M>;
    }[Inherited<N>];
    export type Widget = SubclassOf<"widget">;
    const // Warning: (ae-forgotten-export) The symbol "predicate_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasName: typeof predicate_2.hasName;
}

// @public (undocumented)
export type Source = Source.Data | Source.Descendant | Source.Ancestor | Source.Label | Source.Reference;

// @public (undocumented)
export namespace Source {
    // (undocumented)
    export class Ancestor implements Equatable, Serializable<Ancestor.JSON> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Node_3>;
        // (undocumented)
        get element(): Element_3;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get name(): Name;
        // (undocumented)
        static of(element: Element_3, name: Name): Ancestor;
        // (undocumented)
        toJSON(): Ancestor.JSON;
        // (undocumented)
        get type(): "ancestor";
    }
    // (undocumented)
    export namespace Ancestor {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            element: string;
            // (undocumented)
            name: Name.JSON;
            // (undocumented)
            type: "ancestor";
        }
    }
    // (undocumented)
    export function ancestor(element: Element_3, name: Name): Ancestor;
    // (undocumented)
    export class Data implements Equatable, Serializable<Data.JSON> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Node_3>;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(text: Text_3): Data;
        // (undocumented)
        get text(): Text_3;
        // (undocumented)
        toJSON(): Data.JSON;
        // (undocumented)
        get type(): "data";
    }
    // (undocumented)
    export namespace Data {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            text: string;
            // (undocumented)
            type: "data";
        }
    }
    // (undocumented)
    export function data(text: Text_3): Data;
    // (undocumented)
    export class Descendant implements Equatable, Serializable<Descendant.JSON> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Node_3>;
        // (undocumented)
        get element(): Element_3;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get name(): Name;
        // (undocumented)
        static of(element: Element_3, name: Name): Descendant;
        // (undocumented)
        toJSON(): Descendant.JSON;
        // (undocumented)
        get type(): "descendants";
    }
    // (undocumented)
    export namespace Descendant {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            element: string;
            // (undocumented)
            name: Name.JSON;
            // (undocumented)
            type: "descendant";
        }
    }
    // (undocumented)
    export function descendant(element: Element_3, name: Name): Descendant;
    // (undocumented)
    export type JSON = Data.JSON | Descendant.JSON | Ancestor.JSON | Label.JSON | Reference.JSON;
    // (undocumented)
    export class Label implements Equatable, Serializable<Label.JSON> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Node_3>;
        // (undocumented)
        get attribute(): Attribute_2;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(attribute: Attribute_2): Label;
        // (undocumented)
        toJSON(): Label.JSON;
        // (undocumented)
        get type(): "label";
    }
    // (undocumented)
    export namespace Label {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            attribute: string;
            // (undocumented)
            type: "label";
        }
    }
    // (undocumented)
    export function label(attribute: Attribute_2): Label;
    // (undocumented)
    export class Reference implements Equatable, Serializable<Reference.JSON> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Node_3>;
        // (undocumented)
        get attribute(): Attribute_2;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get name(): Name;
        // (undocumented)
        static of(attribute: Attribute_2, name: Name): Reference;
        // (undocumented)
        toJSON(): Reference.JSON;
        // (undocumented)
        get type(): "reference";
    }
    // (undocumented)
    export namespace Reference {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            attribute: string;
            // (undocumented)
            name: Name.JSON;
            // (undocumented)
            type: "reference";
        }
    }
    // (undocumented)
    export function reference(attribute: Attribute_2, name: Name): Reference;
}

// Warning: (ae-internal-missing-underscore) The name "State" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class State implements Equatable, Serializable<State.JSON> {
    // (undocumented)
    descend(isDescending: boolean): State;
    // (undocumented)
    static empty(): State;
    // (undocumented)
    equals(state: State): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hasVisited(element: Element_3): boolean;
    get isDescending(): boolean;
    get isRecursing(): boolean;
    get isReferencing(): boolean;
    // (undocumented)
    recurse(isRecursing: boolean): State;
    // (undocumented)
    reference(referrer: Element_3, referred: Element_3): State;
    get referred(): Option_2<Element_3>;
    get referrer(): Option_2<Element_3>;
    // (undocumented)
    toJSON(): State.JSON;
    // (undocumented)
    visit(element: Element_3): State;
    get visited(): Iterable_2<Element_3>;
}

// @internal (undocumented)
export namespace State {
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        isDescending: boolean;
        // (undocumented)
        isRecursing: boolean;
        // (undocumented)
        referred: string | null;
        // (undocumented)
        referrer: string | null;
        // (undocumented)
        visited: Array_2<string>;
    }
}

// @public (undocumented)
class Text_2 extends Node_2<"text"> {
    // (undocumented)
    clone(): Text_2;
    // (undocumented)
    isIgnored(): boolean;
    // (undocumented)
    get name(): Option_2<Name>;
    // (undocumented)
    static of(owner: dom_2.Node, name: Option_2<Name>): Text_2;
    // (undocumented)
    toJSON(): Text_2.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Text_2 {
    // (undocumented)
    interface JSON extends Node_2.JSON<"text"> {
        // (undocumented)
        name: string | null;
    }
}
export { Text_2 as Text }

```
