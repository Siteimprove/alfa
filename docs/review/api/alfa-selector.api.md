## API Report File for "@siteimprove/alfa-selector"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import * as dom from '@siteimprove/alfa-dom';
import { Element } from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Nth } from '@siteimprove/alfa-css';
import { Option } from '@siteimprove/alfa-option';
import { Result } from '@siteimprove/alfa-result';
import { Serializable } from '@siteimprove/alfa-json';
import { Token } from '@siteimprove/alfa-css';

// @public (undocumented)
export class Context {
    // (undocumented)
    active(element: Element): Context;
    // (undocumented)
    static active(element: Element): Context;
    // (undocumented)
    addState(element: Element, state: Context.State): Context;
    // (undocumented)
    static empty(): Context;
    // (undocumented)
    focus(element: Element): Context;
    // (undocumented)
    static focus(element: Element): Context;
    // (undocumented)
    getState(element: Element): Context.State;
    // (undocumented)
    hasState(element: Element, state: Context.State): boolean;
    // (undocumented)
    hover(element: Element): Context;
    // (undocumented)
    static hover(element: Element): Context;
    // (undocumented)
    isActive(element: Element): boolean;
    // (undocumented)
    isFocused(element: Element): boolean;
    // (undocumented)
    isHovered(element: Element): boolean;
    // (undocumented)
    isVisited(element: Element): boolean;
    // (undocumented)
    static of(state: Iterable<[Element, Context.State]>): Context;
    // (undocumented)
    setState(element: Element, state: Context.State): Context;
    // (undocumented)
    visit(element: Element): Context;
    // (undocumented)
    static visit(element: Element): Context;
}

// @public (undocumented)
export namespace Context {
    // (undocumented)
    export enum State {
        // (undocumented)
        Active = 2,
        // (undocumented)
        Focus = 4,
        // (undocumented)
        Hover = 1,
        // (undocumented)
        None = 0,
        // (undocumented)
        Visited = 8
    }
}

// @public (undocumented)
export type Selector = Selector.Simple | Selector.Compound | Selector.Complex | Selector.Relative | Selector.List;

// @public (undocumented)
export namespace Selector {
    // (undocumented)
    export class Active extends Pseudo.Class<"active"> {
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(): Active;
    }
    // (undocumented)
    export class After extends Pseudo.Element<"after"> {
        // (undocumented)
        static of(): After;
    }
    // (undocumented)
    export class Attribute extends Selector<"attribute"> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Attribute>;
        // (undocumented)
        equals(value: Attribute): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get matcher(): Option<Attribute.Matcher>;
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        get modifier(): Option<Attribute.Modifier>;
        // (undocumented)
        get name(): string;
        // (undocumented)
        get namespace(): Option<string>;
        // (undocumented)
        static of(namespace: Option<string>, name: string, value?: Option<string>, matcher?: Option<Attribute.Matcher>, modifier?: Option<Attribute.Modifier>): Attribute;
        // (undocumented)
        toJSON(): Attribute.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "attribute";
        // (undocumented)
        get value(): Option<string>;
    }
    // (undocumented)
    export namespace Attribute {
        // (undocumented)
        export interface JSON extends Selector.JSON<"attribute"> {
            // (undocumented)
            matcher: string | null;
            // (undocumented)
            modifier: string | null;
            // (undocumented)
            name: string;
            // (undocumented)
            namespace: string | null;
            // (undocumented)
            value: string | null;
        }
        // (undocumented)
        export enum Matcher {
            // (undocumented)
            DashMatch = "|=",
            // (undocumented)
            Equal = "=",
            // (undocumented)
            Includes = "~=",
            // (undocumented)
            Prefix = "^=",
            // (undocumented)
            Substring = "*=",
            // (undocumented)
            Suffix = "$="
        }
        // (undocumented)
        export enum Modifier {
            // (undocumented)
            CaseInsensitive = "i",
            // (undocumented)
            CaseSensitive = "s"
        }
    }
    // (undocumented)
    export class Backdrop extends Pseudo.Element<"backdrop"> {
        // (undocumented)
        static of(): Backdrop;
    }
    // (undocumented)
    export class Before extends Pseudo.Element<"before"> {
        // (undocumented)
        static of(): Before;
    }
    // (undocumented)
    export class Class extends Selector<"class"> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Class>;
        // (undocumented)
        equals(value: Class): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        get name(): string;
        // (undocumented)
        static of(name: string): Class;
        // (undocumented)
        toJSON(): Class.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "class";
    }
    // (undocumented)
    export namespace Class {
        // (undocumented)
        export interface JSON extends Selector.JSON<"class"> {
            // (undocumented)
            name: string;
        }
    }
    // (undocumented)
    export enum Combinator {
        // (undocumented)
        Descendant = " ",
        // (undocumented)
        DirectDescendant = ">",
        // (undocumented)
        DirectSibling = "+",
        // (undocumented)
        Sibling = "~"
    }
    // (undocumented)
    export class Complex extends Selector<"complex"> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Complex>;
        // (undocumented)
        get combinator(): Combinator;
        // (undocumented)
        equals(value: Complex): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get left(): Simple | Compound | Complex;
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(combinator: Combinator, left: Simple | Compound | Complex, right: Simple | Compound): Complex;
        // (undocumented)
        get right(): Simple | Compound;
        // (undocumented)
        toJSON(): Complex.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "complex";
    }
    // (undocumented)
    export namespace Complex {
        // (undocumented)
        export interface JSON extends Selector.JSON<"complex"> {
            // (undocumented)
            combinator: string;
            // (undocumented)
            left: Simple.JSON | Compound.JSON | JSON;
            // (undocumented)
            right: Simple.JSON | Compound.JSON;
        }
    }
    // (undocumented)
    export class Compound extends Selector<"compound"> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Compound>;
        // (undocumented)
        equals(value: Compound): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get left(): Simple;
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(left: Simple, right: Simple | Compound): Compound;
        // (undocumented)
        get right(): Simple | Compound;
        // (undocumented)
        toJSON(): Compound.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "compound";
    }
    // (undocumented)
    export namespace Compound {
        // (undocumented)
        export interface JSON extends Selector.JSON<"compound"> {
            // (undocumented)
            left: Simple.JSON;
            // (undocumented)
            right: Simple.JSON | JSON;
        }
    }
    // (undocumented)
    export namespace Cue {
        // (undocumented)
        export interface JSON extends Pseudo.Element.JSON<"cue"> {
            // (undocumented)
            selector: Option.JSON<Selector>;
        }
    }
    // (undocumented)
    export namespace CueRegion {
        // (undocumented)
        export interface JSON extends Pseudo.Element.JSON<"cue-region"> {
            // (undocumented)
            selector: Option.JSON<Selector>;
        }
    }
    // (undocumented)
    export class Empty extends Pseudo.Class<"empty"> {
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(): Empty;
    }
    // (undocumented)
    export class FileSelectorButton extends Pseudo.Element<"file-selector-button"> {
        // (undocumented)
        static of(): FileSelectorButton;
    }
    // (undocumented)
    export class FirstChild extends Pseudo.Class<"first-child"> {
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(): FirstChild;
    }
    const // (undocumented)
    isPseudoClass: typeof Pseudo.isClass, // (undocumented)
    isPseudoElement: typeof Pseudo.isElement;
    // (undocumented)
    export class FirstLetter extends Pseudo.Element<"first-letter"> {
        // (undocumented)
        static of(): FirstLetter;
    }
    // (undocumented)
    export class FirstLine extends Pseudo.Element<"first-line"> {
        // (undocumented)
        static of(): FirstLine;
    }
    // (undocumented)
    export class FirstOfType extends Pseudo.Class<"first-of-type"> {
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(): FirstOfType;
    }
    // (undocumented)
    export class Focus extends Pseudo.Class<"focus"> {
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(): Focus;
    }
    // (undocumented)
    export class FocusVisible extends Pseudo.Class<"focus-visible"> {
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(): FocusVisible;
    }
    // (undocumented)
    export class FocusWithin extends Pseudo.Class<"focus-within"> {
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(): FocusWithin;
    }
    // (undocumented)
    export class GrammarError extends Pseudo.Element<"grammar-error"> {
        // (undocumented)
        static of(): GrammarError;
    }
    // (undocumented)
    export class Has extends Pseudo.Class<"has"> {
        // (undocumented)
        equals(value: Has): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(selector: Simple | Compound | Complex | List<Simple | Compound | Complex>): Has;
        // (undocumented)
        get selector(): Simple | Compound | Complex | List<Simple | Compound | Complex>;
        // (undocumented)
        toJSON(): Has.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace Has {
        // (undocumented)
        export interface JSON extends Pseudo.Class.JSON<"has"> {
            // (undocumented)
            selector: Simple.JSON | Compound.JSON | Complex.JSON | List.JSON;
        }
    }
    // (undocumented)
    export class Hover extends Pseudo.Class<"hover"> {
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(): Hover;
    }
    // (undocumented)
    export class Id extends Selector<"id"> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Id>;
        // (undocumented)
        equals(value: Id): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        get name(): string;
        // (undocumented)
        static of(name: string): Id;
        // (undocumented)
        toJSON(): Id.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "id";
    }
    // (undocumented)
    export namespace Id {
        // (undocumented)
        export interface JSON extends Selector.JSON<"id"> {
            // (undocumented)
            name: string;
        }
    }
    // (undocumented)
    export class Is extends Pseudo.Class<"is"> {
        // (undocumented)
        equals(value: Is): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(selector: Simple | Compound | Complex | List<Simple | Compound | Complex>): Is;
        // (undocumented)
        get selector(): Simple | Compound | Complex | List<Simple | Compound | Complex>;
        // (undocumented)
        toJSON(): Is.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace Is {
        // (undocumented)
        export interface JSON extends Pseudo.Class.JSON<"is"> {
            // (undocumented)
            selector: Simple.JSON | Compound.JSON | Complex.JSON | List.JSON;
        }
    }
    // (undocumented)
    export function isAttribute(value: unknown): value is Attribute;
    // (undocumented)
    export function isClass(value: unknown): value is Class;
    // (undocumented)
    export function isComplex(value: unknown): value is Complex;
    // (undocumented)
    export function isCompound(value: unknown): value is Compound;
    // (undocumented)
    export function isId(value: unknown): value is Id;
    // (undocumented)
    export function isPseudo(value: unknown): value is Pseudo;
    // (undocumented)
    export function isSimple(value: unknown): value is Simple;
    // (undocumented)
    export function isType(value: unknown): value is Type;
    // (undocumented)
    export interface JSON<T extends string = string> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: T;
    }
    // (undocumented)
    export class LastChild extends Pseudo.Class<"last-child"> {
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(): LastChild;
    }
    // (undocumented)
    export class LastOfType extends Pseudo.Class<"last-of-type"> {
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(): LastOfType;
    }
    // (undocumented)
    export class Link extends Pseudo.Class<"link"> {
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(): Link;
    }
    // (undocumented)
    export class List<T extends Simple | Compound | Complex | Relative = Simple | Compound | Complex | Relative> extends Selector<"list"> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Simple | Compound | Complex | Relative>;
        // (undocumented)
        equals(value: List): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get left(): T;
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of<T extends Simple | Compound | Complex | Relative>(left: T, right: T | List<T>): List<T>;
        // (undocumented)
        get right(): T | List<T>;
        // (undocumented)
        toJSON(): List.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "list";
    }
    // (undocumented)
    export namespace List {
        // (undocumented)
        export interface JSON extends Selector.JSON<"list"> {
            // (undocumented)
            left: Simple.JSON | Compound.JSON | Complex.JSON | Relative.JSON;
            // (undocumented)
            right: Simple.JSON | Compound.JSON | Complex.JSON | Relative.JSON | JSON;
        }
    }
    // (undocumented)
    export class Marker extends Pseudo.Element<"marker"> {
        // (undocumented)
        static of(): Marker;
    }
    // (undocumented)
    export class Not extends Pseudo.Class<"not"> {
        // (undocumented)
        equals(value: Not): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(selector: Simple | Compound | Complex | List<Simple | Compound | Complex>): Not;
        // (undocumented)
        get selector(): Simple | Compound | Complex | List<Simple | Compound | Complex>;
        // (undocumented)
        toJSON(): Not.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace Not {
        // (undocumented)
        export interface JSON extends Pseudo.Class.JSON<"not"> {
            // (undocumented)
            selector: Simple.JSON | Compound.JSON | Complex.JSON | List.JSON;
        }
    }
    // (undocumented)
    export class NthChild extends Pseudo.Class<"nth-child"> {
        // (undocumented)
        equals(value: NthChild): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(index: Nth): NthChild;
        // (undocumented)
        toJSON(): NthChild.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace NthChild {
        // (undocumented)
        export interface JSON extends Pseudo.Class.JSON<"nth-child"> {
            // (undocumented)
            index: Nth.JSON;
        }
    }
    // (undocumented)
    export class NthLastChild extends Pseudo.Class<"nth-last-child"> {
        // (undocumented)
        equals(value: NthLastChild): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(index: Nth): NthLastChild;
        // (undocumented)
        toJSON(): NthLastChild.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace NthLastChild {
        // (undocumented)
        export interface JSON extends Pseudo.Class.JSON<"nth-last-child"> {
            // (undocumented)
            index: Nth.JSON;
        }
    }
    // (undocumented)
    export class NthLastOfType extends Pseudo.Class<"nth-last-of-type"> {
        // (undocumented)
        equals(value: NthLastOfType): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(index: Nth): NthLastOfType;
        // (undocumented)
        toJSON(): NthLastOfType.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace NthLastOfType {
        // (undocumented)
        export interface JSON extends Pseudo.Class.JSON<"nth-last-of-type"> {
            // (undocumented)
            index: Nth.JSON;
        }
    }
    // (undocumented)
    export class NthOfType extends Pseudo.Class<"nth-of-type"> {
        // (undocumented)
        equals(value: NthOfType): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(index: Nth): NthOfType;
        // (undocumented)
        toJSON(): NthOfType.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace NthOfType {
        // (undocumented)
        export interface JSON extends Pseudo.Class.JSON<"nth-of-type"> {
            // (undocumented)
            index: Nth.JSON;
        }
    }
    // (undocumented)
    export class OnlyChild extends Pseudo.Class<"only-child"> {
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(): OnlyChild;
    }
    // (undocumented)
    export class OnlyOfType extends Pseudo.Class<"only-of-type"> {
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(): OnlyOfType;
    }
    export function parseCSSSelector(selector: string): Result<Simple | Compound | Complex | List<Simple | Compound | Complex>, string>;
    // (undocumented)
    export class Part extends Pseudo.Element<"part"> {
        // (undocumented)
        equals(value: Part): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get idents(): Iterable_2<Token.Ident>;
        // (undocumented)
        static of(idents: Iterable_2<Token.Ident>): Part;
        // (undocumented)
        toJSON(): Part.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace Part {
        // (undocumented)
        export interface JSON extends Pseudo.Element.JSON<"part"> {
            // (undocumented)
            idents: Array_2<Token.Ident.JSON>;
        }
    }
    // (undocumented)
    export class Placeholder extends Pseudo.Element<"placeholder"> {
        // (undocumented)
        static of(): Placeholder;
    }
    // (undocumented)
    export namespace Pseudo {
        // (undocumented)
        export abstract class Class<N extends string = string> extends Selector<"pseudo-class"> {
            // (undocumented)
            [Symbol.iterator](): Iterator<Class>;
            protected constructor(name: N);
            // (undocumented)
            equals(value: Class): boolean;
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            matches(element: dom.Element, context?: Context): boolean;
            // (undocumented)
            get name(): N;
            // (undocumented)
            protected readonly _name: N;
            // (undocumented)
            toJSON(): Class.JSON<N>;
            // (undocumented)
            toString(): string;
            // (undocumented)
            get type(): "pseudo-class";
        }
        // (undocumented)
        export namespace Class {
            // (undocumented)
            export interface JSON<N extends string = string> extends Selector.JSON<"pseudo-class"> {
                // (undocumented)
                name: N;
            }
        }
        // (undocumented)
        export abstract class Element<N extends string = string> extends Selector<"pseudo-element"> {
            // (undocumented)
            [Symbol.iterator](): Iterator<Element>;
            protected constructor(name: N);
            // (undocumented)
            equals(value: Element): boolean;
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            matches(element: dom.Element, context?: Context): boolean;
            // (undocumented)
            get name(): N;
            // (undocumented)
            protected readonly _name: N;
            // (undocumented)
            toJSON(): Element.JSON<N>;
            // (undocumented)
            toString(): string;
            // (undocumented)
            get type(): "pseudo-element";
        }
        // (undocumented)
        export namespace Element {
            // (undocumented)
            export interface JSON<N extends string = string> extends Selector.JSON<"pseudo-element"> {
                // (undocumented)
                name: N;
            }
        }
        // (undocumented)
        export function isClass(value: unknown): value is Class;
        // (undocumented)
        export function isElement(value: unknown): value is Element;
        // (undocumented)
        export type JSON = Class.JSON | Element.JSON;
    }
    // (undocumented)
    export type Pseudo = Pseudo.Class | Pseudo.Element;
    // (undocumented)
    export class Relative extends Selector<"relative"> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Relative>;
        // (undocumented)
        get combinator(): Combinator;
        // (undocumented)
        equals(value: Relative): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(): boolean;
        // (undocumented)
        static of(combinator: Combinator, selector: Simple | Compound | Complex): Relative;
        // (undocumented)
        get selector(): Simple | Compound | Complex;
        // (undocumented)
        toJSON(): Relative.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "relative";
    }
    // (undocumented)
    export namespace Relative {
        // (undocumented)
        export interface JSON extends Selector.JSON<"relative"> {
            // (undocumented)
            combinator: string;
            // (undocumented)
            selector: Simple.JSON | Compound.JSON | Complex.JSON;
        }
    }
    // (undocumented)
    export class Root extends Pseudo.Class<"root"> {
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        static of(): Root;
    }
    // (undocumented)
    export class Selection extends Pseudo.Element<"selection"> {
        // (undocumented)
        static of(): Selection;
    }
    // (undocumented)
    export abstract class Selector<T extends string = string> implements Iterable_2<Simple | Compound | Complex | Relative>, Equatable, Serializable {
        // (undocumented)
        abstract [Symbol.iterator](): Iterator<Simple | Compound | Complex | Relative>;
        // (undocumented)
        abstract equals(value: Selector): boolean;
        // (undocumented)
        abstract equals(value: unknown): value is this;
        // (undocumented)
        abstract matches(element: Element, context?: Context): boolean;
        // (undocumented)
        abstract toJSON(): JSON;
        // (undocumented)
        abstract get type(): T;
    }
    // (undocumented)
    export type Simple = Type | Universal | Attribute | Class | Id | Pseudo;
    // (undocumented)
    export namespace Simple {
        // (undocumented)
        export type JSON = Type.JSON | Universal.JSON | Attribute.JSON | Class.JSON | Id.JSON | Pseudo.JSON;
    }
    // (undocumented)
    export class Slotted extends Pseudo.Element<"slotted"> {
        // (undocumented)
        equals(value: Slotted): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(selectors: Iterable_2<Simple | Compound>): Slotted;
        // (undocumented)
        get selectors(): Iterable_2<Simple | Compound>;
        // (undocumented)
        toJSON(): Slotted.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace Slotted {
        // (undocumented)
        export interface JSON extends Pseudo.Element.JSON<"slotted"> {
            // (undocumented)
            selectors: Array_2<Simple.JSON | Compound.JSON>;
        }
    }
    // (undocumented)
    export class SpellingError extends Pseudo.Element<"spelling-error"> {
        // (undocumented)
        static of(): SpellingError;
    }
    // (undocumented)
    export class TargetText extends Pseudo.Element<"target-text"> {
        // (undocumented)
        static of(): TargetText;
    }
    // (undocumented)
    export class Type extends Selector<"type"> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Type>;
        // (undocumented)
        equals(value: Type): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        get name(): string;
        // (undocumented)
        get namespace(): Option<string>;
        // (undocumented)
        static of(namespace: Option<string>, name: string): Type;
        // (undocumented)
        toJSON(): Type.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "type";
    }
    // (undocumented)
    export namespace Type {
        // (undocumented)
        export interface JSON extends Selector.JSON<"type"> {
            // (undocumented)
            name: string;
            // (undocumented)
            namespace: string | null;
        }
    }
    // (undocumented)
    export class Universal extends Selector<"universal"> {
        // (undocumented)
        [Symbol.iterator](): Iterator<Universal>;
        // (undocumented)
        static empty(): Universal;
        // (undocumented)
        equals(value: Universal): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        matches(element: Element): boolean;
        // (undocumented)
        get namespace(): Option<string>;
        // (undocumented)
        static of(namespace: Option<string>): Universal;
        // (undocumented)
        toJSON(): Universal.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "universal";
    }
    // (undocumented)
    export namespace Universal {
        // (undocumented)
        export interface JSON extends Selector.JSON<"universal"> {
            // (undocumented)
            namespace: string | null;
        }
    }
    // (undocumented)
    export class Visited extends Pseudo.Class<"visited"> {
        // (undocumented)
        matches(element: Element, context?: Context): boolean;
        // (undocumented)
        static of(): Visited;
    }
        {};
}

// (No @packageDocumentation comment for this package)

```
