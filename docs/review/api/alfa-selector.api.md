## API Report File for "@siteimprove/alfa-selector"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Element } from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Nth } from '@siteimprove/alfa-css';
import { Option } from '@siteimprove/alfa-option';
import { Parser } from '@siteimprove/alfa-parser';
import { Parser as Parser_2 } from '@siteimprove/alfa-css';
import { Serializable } from '@siteimprove/alfa-json';
import { Slice } from '@siteimprove/alfa-slice';
import { Thunk } from '@siteimprove/alfa-thunk';
import { Token } from '@siteimprove/alfa-css';

// Warning: (ae-internal-missing-underscore) The name "Absolute" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type Absolute = Simple | Compound | Complex | List<Simple | Compound | Complex>;

// @internal (undocumented)
export namespace Absolute {
    // (undocumented)
    export type JSON = Simple.JSON | Compound.JSON | Complex.JSON | List.JSON<Simple | Compound | Complex>;
}

// Warning: (ae-forgotten-export) The symbol "WithName" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class Attribute extends WithName<"attribute"> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Attribute>;
    // (undocumented)
    equals(value: Attribute): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get matcher(): Option<Attribute.Matcher>;
    // (undocumented)
    matches(element: Element): boolean;
    // (undocumented)
    get modifier(): Option<Attribute.Modifier>;
    // (undocumented)
    get namespace(): Option<string>;
    // (undocumented)
    static of(namespace: Option<string>, name: string, value?: Option<string>, matcher?: Option<Attribute.Matcher>, modifier?: Option<Attribute.Modifier>): Attribute;
    // (undocumented)
    toJSON(): Attribute.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): Option<string>;
}

// @public (undocumented)
export namespace Attribute {
    // (undocumented)
    export function isAttribute(value: unknown): value is Attribute;
    // (undocumented)
    export interface JSON extends WithName.JSON<"attribute"> {
        // (undocumented)
        matcher: string | null;
        // (undocumented)
        modifier: string | null;
        // (undocumented)
        namespace: string | null;
        // (undocumented)
        value: string | null;
    }
    // (undocumented)
    export enum Matcher {
        // (undocumented)
        DashMatch = "|=",
        // (undocumented)
        Equal = "=",
        // (undocumented)
        Includes = "~=",
        // (undocumented)
        Prefix = "^=",
        // (undocumented)
        Substring = "*=",
        // (undocumented)
        Suffix = "$="
    }
    // (undocumented)
    export enum Modifier {
        // (undocumented)
        CaseInsensitive = "i",
        // (undocumented)
        CaseSensitive = "s"
    }
    const // @internal (undocumented)
    parse: Parser<Slice<Token>, Attribute, string, []>;
}

// @public (undocumented)
export class Class extends WithName<"class"> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Class>;
    // (undocumented)
    equals(value: Class): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    protected readonly _key: Option<Class>;
    // (undocumented)
    matches(element: Element): boolean;
    // (undocumented)
    static of(name: string): Class;
    // (undocumented)
    toJSON(): Class.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Class {
    // (undocumented)
    export function isClass(value: unknown): value is Class;
    // (undocumented)
    export interface JSON extends WithName.JSON<"class"> {
    }
    const // @internal (undocumented)
    parse: Parser<Slice<Token>, Class, string, []>;
}

// @public (undocumented)
export enum Combinator {
    // (undocumented)
    Descendant = " ",
    // (undocumented)
    DirectDescendant = ">",
    // (undocumented)
    DirectSibling = "+",
    // (undocumented)
    Sibling = "~"
}

// @public (undocumented)
export namespace Combinator {
    const // @internal (undocumented)
    parseCombinator: Parser_2<Combinator>;
}

// Warning: (ae-forgotten-export) The symbol "Selector_2" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class Complex extends Selector_2<"complex"> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Complex>;
    // (undocumented)
    get combinator(): Combinator;
    // (undocumented)
    equals(value: Complex): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    protected readonly _key: Option<Id | Class | Type>;
    // (undocumented)
    get left(): Simple | Compound | Complex;
    // (undocumented)
    matches(element: Element, context?: Context): boolean;
    // (undocumented)
    static of(combinator: Combinator, left: Simple | Compound | Complex, right: Simple | Compound): Complex;
    // (undocumented)
    get right(): Simple | Compound;
    // (undocumented)
    toJSON(): Complex.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Complex {
    // (undocumented)
    export function isComplex(value: unknown): value is Complex;
    // (undocumented)
    export interface JSON extends Selector_2.JSON<"complex"> {
        // (undocumented)
        combinator: Combinator;
        // (undocumented)
        left: Simple.JSON | Compound.JSON | Complex.JSON;
        // (undocumented)
        right: Simple.JSON | Compound.JSON;
    }
    const // @internal (undocumented)
    parseComplex: (parseSelector: Thunk<Parser_2<Absolute>>) => Parser<Slice<Token>, Compound | Simple | Complex, string, []>;
}

// @public (undocumented)
export class Compound extends Selector_2<"compound"> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Compound>;
    // (undocumented)
    equals(value: Compound): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    protected readonly _key: Option<Id | Class | Type>;
    // (undocumented)
    get length(): number;
    // (undocumented)
    matches(element: Element, context?: Context): boolean;
    // (undocumented)
    static of(...selectors: Array_2<Simple>): Compound;
    // (undocumented)
    get selectors(): Iterable_2<Simple>;
    // (undocumented)
    toJSON(): Compound.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Compound {
    // (undocumented)
    export function isCompound(value: unknown): value is Compound;
    // (undocumented)
    export interface JSON extends Selector_2.JSON<"compound"> {
        // (undocumented)
        selectors: Array_2<Simple.JSON>;
    }
    const // @internal (undocumented)
    parseCompound: (parseSelector: () => Parser<Slice<Token>, Absolute, string>) => Parser<Slice<Token>, Compound | Simple, string, []>;
}

// @public (undocumented)
export class Context {
    // (undocumented)
    active(element: Element): Context;
    // (undocumented)
    static active(element: Element): Context;
    // (undocumented)
    addState(element: Element, state: Context.State): Context;
    // (undocumented)
    static empty(): Context;
    // (undocumented)
    focus(element: Element): Context;
    // (undocumented)
    static focus(element: Element): Context;
    // (undocumented)
    getState(element: Element): Context.State;
    // (undocumented)
    hasState(element: Element, state: Context.State): boolean;
    // (undocumented)
    hover(element: Element): Context;
    // (undocumented)
    static hover(element: Element): Context;
    // (undocumented)
    isActive(element: Element): boolean;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    isFocused(element: Element): boolean;
    // (undocumented)
    isHovered(element: Element): boolean;
    // (undocumented)
    isVisited(element: Element): boolean;
    // (undocumented)
    static of(state: Iterable<[Element, Context.State]>): Context;
    // (undocumented)
    setState(element: Element, state: Context.State): Context;
    // (undocumented)
    visit(element: Element): Context;
    // (undocumented)
    static visit(element: Element): Context;
    // (undocumented)
    withState(state: Context.State): Iterable<Element>;
}

// @public (undocumented)
export namespace Context {
    // (undocumented)
    export enum State {
        // (undocumented)
        Active = 2,
        // (undocumented)
        Focus = 4,
        // (undocumented)
        Hover = 1,
        // (undocumented)
        None = 0,
        // (undocumented)
        Visited = 8
    }
}

// @public (undocumented)
export class Id extends WithName<"id"> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Id>;
    // (undocumented)
    equals(value: Id): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    protected readonly _key: Option<Id>;
    // (undocumented)
    matches(element: Element): boolean;
    // (undocumented)
    static of(name: string): Id;
    // (undocumented)
    toJSON(): Id.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Id {
    // (undocumented)
    export function isId(value: unknown): value is Id;
    // (undocumented)
    export interface JSON extends WithName.JSON<"id"> {
    }
    const // @internal (undocumented)
    parse: Parser<Slice<Token>, Id, string, []>;
}

// Warning: (ae-forgotten-export) The symbol "Item" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class List<T extends Item = Item> extends Selector_2<"list"> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    // (undocumented)
    equals(value: List): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get length(): number;
    // (undocumented)
    matches(element: Element, context?: Context): boolean;
    // (undocumented)
    static of<T extends Item>(...selectors: Array_2<T>): List<T>;
    // (undocumented)
    get selectors(): Iterable_2<T>;
    // (undocumented)
    toJSON(): List.JSON<T>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace List {
    // (undocumented)
    export interface JSON<T extends Item = Item> extends Selector_2.JSON<"list"> {
        // (undocumented)
        selectors: Array_2<Serializable.ToJSON<T>>;
    }
    const // @internal (undocumented)
    parseList: (parseSelector: Thunk<Parser_2<Absolute>>) => Parser<Slice<Token>, List<Compound | Simple | Complex>, string, []>;
}

// Warning: (ae-forgotten-export) The symbol "Active" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Disabled" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Empty" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Enabled" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FirstChild" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FirstOfType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Focus" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FocusVisible" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FocusWithin" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Has" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Host" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Hover" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Is" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "LastChild" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "LastOfType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Link" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Not" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NthChild" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NthLastChild" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NthLastOfType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NthOfType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "OnlyChild" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "OnlyOfType" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Root" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Visited" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Where" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type PseudoClass = Active | Disabled | Empty | Enabled | FirstChild | FirstOfType | Focus | FocusVisible | FocusWithin | Has | Host | Hover | Is | LastChild | LastOfType | Link | Not | NthChild | NthLastChild | NthLastOfType | NthOfType | OnlyChild | OnlyOfType | Root | Visited | Where;

// @public (undocumented)
export namespace PseudoClass {
    // (undocumented)
    export function isPseudoClass(value: unknown): value is PseudoClass;
    // (undocumented)
    export type JSON = Active.JSON | Disabled.JSON | Empty.JSON | Enabled.JSON | FirstChild.JSON | FirstOfType.JSON | Focus.JSON | FocusVisible.JSON | FocusWithin.JSON | Has.JSON | Host.JSON | Hover.JSON | Is.JSON | LastChild.JSON | LastOfType.JSON | Link.JSON | Not.JSON | NthChild.JSON | NthLastChild.JSON | NthLastOfType.JSON | NthOfType.JSON | OnlyChild.JSON | OnlyOfType.JSON | Root.JSON | Visited.JSON | Where.JSON;
    // Warning: (ae-incompatible-release-tags) The symbol "parse" is marked as @public, but its signature references "Absolute" which is marked as @internal
    //
    // (undocumented)
    export function parse(parseSelector: Thunk<Parser_2<Absolute>>): Parser_2<PseudoClass>;
}

// Warning: (ae-forgotten-export) The symbol "After" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Backdrop" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Before" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Cue" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "CueRegion" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FileSelectorButton" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FirstLetter" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FirstLine" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "GrammarError" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Marker" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Part" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Placeholder" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Selection" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Slotted" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "SpellingError" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TargetText" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type PseudoElement = After | Backdrop | Before | Cue | CueRegion | FileSelectorButton | FirstLetter | FirstLine | GrammarError | Marker | Part | Placeholder | Selection | Slotted | SpellingError | TargetText;

// @public (undocumented)
export namespace PseudoElement {
    // (undocumented)
    export function isPseudoElement(value: unknown): value is PseudoElementSelector;
    // Warning: (ae-forgotten-export) The symbol "PseudoElementSelector" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export type JSON = PseudoElementSelector.JSON;
    // Warning: (ae-incompatible-release-tags) The symbol "parse" is marked as @public, but its signature references "Absolute" which is marked as @internal
    //
    // (undocumented)
    export function parse(parseSelector: Thunk<Parser_2<Absolute>>): Parser_2<PseudoElement>;
}

// @public (undocumented)
export class Relative extends Selector_2<"relative"> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Relative>;
    // (undocumented)
    get combinator(): Combinator;
    // (undocumented)
    equals(value: Relative): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    matches(): boolean;
    // (undocumented)
    static of(combinator: Combinator, selector: Simple | Compound | Complex): Relative;
    // (undocumented)
    get selector(): Simple | Compound | Complex;
    // (undocumented)
    toJSON(): Relative.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Relative {
    // (undocumented)
    export interface JSON extends Selector_2.JSON<"relative"> {
        // (undocumented)
        combinator: string;
        // (undocumented)
        selector: Simple.JSON | Compound.JSON | Complex.JSON;
    }
}

// @public (undocumented)
export type Selector = Simple | Compound | Complex | Relative | List;

// @public (undocumented)
export namespace Selector {
    // (undocumented)
    export type JSON = Simple.JSON | Compound.JSON | Complex.JSON | Relative.JSON | List.JSON;
    const // Warning: (ae-incompatible-release-tags) The symbol "parse" is marked as @public, but its signature references "Absolute" which is marked as @internal
    //
    // (undocumented)
    parse: Parser_2<Absolute>;
}

// @public (undocumented)
export type Simple = Type | Universal | Attribute | Class | Id | PseudoClass | PseudoElement;

// @public (undocumented)
export namespace Simple {
    // (undocumented)
    export function isSimple(value: unknown): value is Simple;
    // (undocumented)
    export type JSON = Type.JSON | Universal.JSON | Attribute.JSON | Class.JSON | Id.JSON | PseudoClass.JSON | PseudoElement.JSON;
    const // @internal (undocumented)
    parse: (parseSelector: Thunk<Parser_2<Absolute>>) => Parser<Slice<Token>, Simple, string, []>;
}

// @public (undocumented)
export class Type extends WithName<"type"> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Type>;
    // (undocumented)
    equals(value: Type): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    protected readonly _key: Option<Type>;
    // (undocumented)
    matches(element: Element): boolean;
    // (undocumented)
    get namespace(): Option<string>;
    // (undocumented)
    static of(namespace: Option<string>, name: string): Type;
    // (undocumented)
    toJSON(): Type.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Type {
    // (undocumented)
    export function isType(value: unknown): value is Type;
    // (undocumented)
    export interface JSON extends WithName.JSON<"type"> {
        // (undocumented)
        namespace: string | null;
    }
    const // @internal (undocumented)
    parse: Parser<Slice<Token>, Type, string, []>;
}

// @public (undocumented)
export class Universal extends Selector_2<"universal"> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Universal>;
    // (undocumented)
    static empty(): Universal;
    // (undocumented)
    equals(value: Universal): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    matches(element: Element): boolean;
    // (undocumented)
    get namespace(): Option<string>;
    // (undocumented)
    static of(namespace: Option<string>): Universal;
    // (undocumented)
    toJSON(): Universal.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Universal {
    // (undocumented)
    export function isUniversal(value: unknown): value is Universal;
    // (undocumented)
    export interface JSON extends Selector_2.JSON<"universal"> {
        // (undocumented)
        namespace: string | null;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Universal, string, []>;
}

// (No @packageDocumentation comment for this package)

```
