## API Report File for "@siteimprove/alfa-collection"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Applicative } from '@siteimprove/alfa-applicative';
import { Callback } from '@siteimprove/alfa-callback';
import { Comparable } from '@siteimprove/alfa-comparable';
import { Comparer } from '@siteimprove/alfa-comparable';
import { Comparison } from '@siteimprove/alfa-comparable';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Foldable } from '@siteimprove/alfa-foldable';
import { Functor } from '@siteimprove/alfa-functor';
import { Hashable } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Monad } from '@siteimprove/alfa-monad';
import { Option } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Reducer } from '@siteimprove/alfa-reducer';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Serializable } from '@siteimprove/alfa-json';

// @public (undocumented)
export interface Collection<T> extends Functor<T>, Monad<T>, Foldable<T>, Applicative<T>, Equatable, Hashable {
    // (undocumented)
    apply<U>(mapper: Collection<Mapper<T, U>>): Collection<U>;
    // (undocumented)
    collect<U>(mapper: Mapper<T, Option<U>>): Collection<U>;
    // (undocumented)
    collectFirst<U>(mapper: Mapper<T, Option<U>>): Option<U>;
    // (undocumented)
    count(predicate: Predicate<T>): number;
    // (undocumented)
    distinct(): Collection<T>;
    // (undocumented)
    every(predicate: Predicate<T>): boolean;
    // (undocumented)
    filter<U extends T>(refinement: Refinement<T, U>): Collection<U>;
    // (undocumented)
    filter(predicate: Predicate<T>): Collection<T>;
    // (undocumented)
    find<U extends T>(refinement: Refinement<T, U>): Option<U>;
    // (undocumented)
    find(predicate: Predicate<T>): Option<T>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Collection<U>>): Collection<U>;
    // (undocumented)
    forEach(callback: Callback<T>): void;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    isEmpty(): this is Collection<never>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Collection<U>;
    // (undocumented)
    none(predicate: Predicate<T>): boolean;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    reject<U extends T>(refinement: Refinement<T, U>): Collection<Exclude<T, U>>;
    // (undocumented)
    reject(predicate: Predicate<T>): Collection<T>;
    // (undocumented)
    readonly size: number;
    // (undocumented)
    some(predicate: Predicate<T>): boolean;
}

// @public (undocumented)
export namespace Collection {
    // (undocumented)
    export function compare<T extends Comparable<T>>(a: Indexed<T>, b: Iterable_2<T>): Comparison;
    // (undocumented)
    export interface Indexed<T> extends Collection<T>, Iterable_2<T>, Serializable<Indexed.JSON<T>> {
        // (undocumented)
        append(value: T): Indexed<T>;
        // (undocumented)
        apply<U>(mapper: Indexed<Mapper<T, U>>): Indexed<U>;
        // (undocumented)
        collect<U>(mapper: Mapper<T, Option<U>, [index: number]>): Indexed<U>;
        // (undocumented)
        collectFirst<U>(mapper: Mapper<T, Option<U>, [index: number]>): Option<U>;
        // (undocumented)
        compareWith(iterable: Iterable_2<T>, comparer: Comparer<T>): Comparison;
        // (undocumented)
        concat(iterable: Iterable_2<T>): Indexed<T>;
        // (undocumented)
        count(predicate: Predicate<T, [index: number]>): number;
        // (undocumented)
        distinct(): Indexed<T>;
        // (undocumented)
        every(predicate: Predicate<T, [index: number]>): boolean;
        // (undocumented)
        filter<U extends T>(refinement: Refinement<T, U, [index: number]>): Indexed<U>;
        // (undocumented)
        filter(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        find<U extends T>(refinement: Refinement<T, U, [index: number]>): Option<U>;
        // (undocumented)
        find(predicate: Predicate<T, [index: number]>): Option<T>;
        // (undocumented)
        first(): Option<T>;
        // (undocumented)
        flatMap<U>(mapper: Mapper<T, Indexed<U>, [index: number]>): Indexed<U>;
        // (undocumented)
        forEach(callback: Callback<T, void, [index: number]>): void;
        // (undocumented)
        get(index: number): Option<T>;
        // (undocumented)
        has(index: number): boolean;
        // (undocumented)
        includes(value: T): boolean;
        // (undocumented)
        insert(index: number, value: T): Indexed<T>;
        // (undocumented)
        intersect(iterable: Iterable_2<T>): Indexed<T>;
        // (undocumented)
        isEmpty(): this is Indexed<never>;
        // (undocumented)
        join(separator: string): string;
        // (undocumented)
        last(): Option<T>;
        // (undocumented)
        map<U>(mapper: Mapper<T, U, [index: number]>): Indexed<U>;
        // (undocumented)
        none(predicate: Predicate<T, [index: number]>): boolean;
        // (undocumented)
        prepend(value: T): Indexed<T>;
        // (undocumented)
        reduce<U>(reducer: Reducer<T, U, [index: number]>, accumulator: U): U;
        // (undocumented)
        reject<U extends T>(refinement: Refinement<T, U, [index: number]>): Indexed<Exclude<T, U>>;
        // (undocumented)
        reject(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        rest(): Indexed<T>;
        // (undocumented)
        reverse(): Indexed<T>;
        // (undocumented)
        set(index: number, value: T): Indexed<T>;
        // (undocumented)
        skip(count: number): Indexed<T>;
        // (undocumented)
        skipLast(count: number): Indexed<T>;
        // (undocumented)
        skipLastUntil(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        skipLastWhile(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        skipUntil(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        skipWhile(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        slice(start: number, end?: number): Indexed<T>;
        // (undocumented)
        some(predicate: Predicate<T, [index: number]>): boolean;
        // (undocumented)
        sortWith(comparer: Comparer<T>): Indexed<T>;
        // (undocumented)
        subtract(iterable: Iterable_2<T>): Indexed<T>;
        // (undocumented)
        take(count: number): Indexed<T>;
        // (undocumented)
        takeLast(count: number): Indexed<T>;
        // (undocumented)
        takeLastUntil(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        takeLastWhile(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        takeUntil(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        takeWhile(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        trim(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        trimLeading(predicate: Predicate<T, [index: number]>): Indexed<T>;
        // (undocumented)
        trimTrailing(predicate: Predicate<T, [index: number]>): Indexed<T>;
    }
    // (undocumented)
    export namespace Indexed {
        // (undocumented)
        export type JSON<T> = Array<Serializable.ToJSON<T>>;
    }
    // (undocumented)
    export interface Keyed<K, V> extends Collection<V>, Iterable_2<[K, V]>, Serializable<Keyed.JSON<K, V>> {
        // (undocumented)
        apply<U>(mapper: Keyed<K, Mapper<V, U>>): Keyed<K, U>;
        // (undocumented)
        collect<U>(mapper: Mapper<V, Option<U>, [key: K]>): Keyed<K, U>;
        // (undocumented)
        collectFirst<U>(mapper: Mapper<V, Option<U>, [key: K]>): Option<U>;
        // (undocumented)
        concat(iterable: Iterable_2<readonly [K, V]>): Keyed<K, V>;
        // (undocumented)
        count(predicate: Predicate<V, [key: K]>): number;
        // (undocumented)
        delete(key: K, value: V): Keyed<K, V>;
        // (undocumented)
        distinct(): Keyed<K, V>;
        // (undocumented)
        every(predicate: Predicate<V, [key: K]>): boolean;
        // (undocumented)
        filter<U extends V>(refinement: Refinement<V, U, [key: K]>): Keyed<K, U>;
        // (undocumented)
        filter(predicate: Predicate<V, [key: K]>): Keyed<K, V>;
        // (undocumented)
        find<U extends V>(refinement: Refinement<V, U, [key: K]>): Option<U>;
        // (undocumented)
        find(predicate: Predicate<V, [key: K]>): Option<V>;
        // (undocumented)
        flatMap<U>(mapper: Mapper<V, Keyed<K, U>, [key: K]>): Keyed<K, U>;
        // (undocumented)
        forEach(callback: Callback<V, void, [key: K]>): void;
        // (undocumented)
        get(key: K): Option<V>;
        // (undocumented)
        has(key: K): boolean;
        // (undocumented)
        includes(value: V): boolean;
        // (undocumented)
        intersect(iterable: Iterable_2<readonly [K, V]>): Keyed<K, V>;
        // (undocumented)
        isEmpty(): this is Keyed<K, never>;
        // (undocumented)
        map<U>(mapper: Mapper<V, U, [key: K]>): Keyed<K, U>;
        // (undocumented)
        none(predicate: Predicate<V, [key: K]>): boolean;
        // (undocumented)
        reduce<U>(reducer: Reducer<V, U, [key: K]>, accumulator: U): U;
        // (undocumented)
        reject<U extends V>(refinement: Refinement<V, U, [key: K]>): Keyed<K, Exclude<V, U>>;
        // (undocumented)
        reject(predicate: Predicate<V, [key: K]>): Keyed<K, V>;
        // (undocumented)
        set(key: K, value: V): Keyed<K, V>;
        // (undocumented)
        some(predicate: Predicate<V, [key: K]>): boolean;
        // (undocumented)
        subtract(iterable: Iterable_2<readonly [K, V]>): Keyed<K, V>;
    }
    // (undocumented)
    export namespace Keyed {
        // (undocumented)
        export type JSON<K, V> = Array<[
            Serializable.ToJSON<K>,
            Serializable.ToJSON<V>
        ]>;
    }
    // (undocumented)
    export function sort<T extends Comparable<T>>(collection: Indexed<T>): Indexed<T>;
    // (undocumented)
    export interface Unkeyed<T> extends Collection<T>, Iterable_2<T>, Serializable<Unkeyed.JSON<T>> {
        // (undocumented)
        add(value: T): Unkeyed<T>;
        // (undocumented)
        apply<U>(mapper: Unkeyed<Mapper<T, U>>): Unkeyed<U>;
        // (undocumented)
        collect<U>(mapper: Mapper<T, Option<U>>): Unkeyed<U>;
        // (undocumented)
        collectFirst<U>(mapper: Mapper<T, Option<U>>): Option<U>;
        // (undocumented)
        concat(iterable: Iterable_2<T>): Unkeyed<T>;
        // (undocumented)
        count(predicate: Predicate<T>): number;
        // (undocumented)
        delete(value: T): Unkeyed<T>;
        // (undocumented)
        distinct(): Unkeyed<T>;
        // (undocumented)
        every(predicate: Predicate<T>): boolean;
        // (undocumented)
        filter<U extends T>(refinement: Refinement<T, U>): Unkeyed<U>;
        // (undocumented)
        filter(predicate: Predicate<T>): Unkeyed<T>;
        // (undocumented)
        find<U extends T>(refinement: Refinement<T, U>): Option<U>;
        // (undocumented)
        find(predicate: Predicate<T>): Option<T>;
        // (undocumented)
        flatMap<U>(mapper: Mapper<T, Unkeyed<U>>): Unkeyed<U>;
        // (undocumented)
        forEach(callback: Callback<T>): void;
        // (undocumented)
        get(value: T): Option<T>;
        // (undocumented)
        has(value: T): boolean;
        // (undocumented)
        includes(value: T): boolean;
        // (undocumented)
        intersect(iterable: Iterable_2<T>): Unkeyed<T>;
        // (undocumented)
        isEmpty(): this is Unkeyed<never>;
        // (undocumented)
        map<U>(mapper: Mapper<T, U>): Unkeyed<U>;
        // (undocumented)
        none(predicate: Predicate<T>): boolean;
        // (undocumented)
        reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
        // (undocumented)
        reject<U extends T>(refinement: Refinement<T, U>): Unkeyed<Exclude<T, U>>;
        // (undocumented)
        reject(predicate: Predicate<T>): Unkeyed<T>;
        // (undocumented)
        some(predicate: Predicate<T>): boolean;
        // (undocumented)
        subtract(iterable: Iterable_2<T>): Unkeyed<T>;
    }
    // (undocumented)
    export namespace Unkeyed {
        // (undocumented)
        export type JSON<T> = Array<Serializable.ToJSON<T>>;
    }
}


// (No @packageDocumentation comment for this package)

```
