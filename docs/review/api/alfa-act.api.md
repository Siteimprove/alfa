## API Report File for "@siteimprove/alfa-act"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Applicative } from '@siteimprove/alfa-applicative';
import { Array as Array_2 } from '@siteimprove/alfa-array';
import * as earl from '@siteimprove/alfa-earl';
import { Either } from '@siteimprove/alfa-either';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Functor } from '@siteimprove/alfa-functor';
import { Future } from '@siteimprove/alfa-future';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Monad } from '@siteimprove/alfa-monad';
import { Option } from '@siteimprove/alfa-option';
import { Performance } from '@siteimprove/alfa-performance';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Record as Record_2 } from '@siteimprove/alfa-record';
import { Result } from '@siteimprove/alfa-result';
import * as sarif from '@siteimprove/alfa-sarif';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';
import type { Thunk } from '@siteimprove/alfa-thunk';
import { Tuple } from '@siteimprove/alfa-tuple';

// @public
export class Audit<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> {
    // (undocumented)
    evaluate(performance?: Performance<Rule.Event<I, T, Q, S>>): Future<Iterable_2<Outcome<I, T, Q, S>>>;
    // (undocumented)
    static of<I, T extends Hashable, Q extends Question.Metadata = {}, S = T>(input: I, rules: Iterable_2<Rule<I, T, Q, S>>, oracle?: Oracle<I, T, Q, S>): Audit<I, T, Q, S>;
}

// @public (undocumented)
export class Cache {
    // (undocumented)
    static empty(): Cache;
    // (undocumented)
    get<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, ifMissing: Thunk<Future<Iterable<Outcome<I, T, Q, S>>>>): Future<Iterable<Outcome<I, T, Q, S>>>;
}

// @public (undocumented)
export class Diagnostic implements Equatable, Hashable, Serializable<Diagnostic.JSON> {
    protected constructor(message: string);
    // (undocumented)
    equals(value: Diagnostic): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get message(): string;
    // (undocumented)
    protected readonly _message: string;
    // (undocumented)
    static of(message: string): Diagnostic;
    // (undocumented)
    toJSON(): Diagnostic.JSON;
}

// @public (undocumented)
export namespace Diagnostic {
    // (undocumented)
    export function isDiagnostic(value: unknown): value is Diagnostic;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        message: string;
    }
    const // (undocumented)
    empty: Diagnostic;
}

// Warning: (ae-forgotten-export) The symbol "Depths" needs to be exported by the entry point index.d.ts
//
// @public
export type Interview<QUESTION extends Question.Metadata, SUBJECT, CONTEXT, ANSWER, D extends number = Interview.MaxDepth> = ANSWER | {
    [URI in keyof QUESTION]: Question<QUESTION[URI][0], SUBJECT, CONTEXT, QUESTION[URI][1], D extends -1 ? ANSWER : Interview<QUESTION, SUBJECT, CONTEXT, ANSWER, Depths[D]>, URI extends string ? URI : never>;
}[keyof QUESTION];

// @public (undocumented)
export namespace Interview {
    export function conduct<INPUT, TARGET extends Hashable, QUESTION extends Question.Metadata, SUBJECT, ANSWER>(interview: Interview<QUESTION, SUBJECT, TARGET, ANSWER>, rule: Rule<INPUT, TARGET, QUESTION, SUBJECT>, oracle: Oracle<INPUT, TARGET, QUESTION, SUBJECT>, oracleUsed?: boolean): Future<Either<Tuple<[ANSWER, boolean]>, Tuple<[Diagnostic, boolean]>>>;
    // @internal (undocumented)
    export type MaxDepth = 3;
}

// @public
export type Oracle<INPUT, TARGET extends Hashable, QUESTION extends Question.Metadata, SUBJECT> = (rule: Rule<INPUT, TARGET, QUESTION, SUBJECT>, question: {
    [URI in keyof QUESTION]: Question<QUESTION[URI][0], SUBJECT, TARGET, QUESTION[URI][1], unknown, URI extends string ? URI : never>;
}[keyof QUESTION]) => Future<Option<QUESTION[keyof QUESTION][1]>>;

// @public
export abstract class Outcome<I, T extends Hashable, Q extends Question.Metadata = {}, S = T, V extends Outcome.Value = Outcome.Value> implements Equatable, Hashable, json.Serializable<Outcome.JSON<V>>, earl.Serializable<Outcome.EARL>, sarif.Serializable<sarif.Result> {
    protected constructor(outcome: V, rule: Rule<I, T, Q, S>, mode: Outcome.Mode);
    // (undocumented)
    equals<I, T extends Hashable, Q extends Question.Metadata, S, V extends Outcome.Value = Outcome.Value>(value: Outcome<I, T, Q, S, V>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get isSemiAuto(): boolean;
    // (undocumented)
    get mode(): Outcome.Mode;
    // (undocumented)
    protected readonly _mode: Outcome.Mode;
    // (undocumented)
    get outcome(): V;
    get rule(): Rule<I, T, Q, S>;
    protected readonly _rule: Rule<I, T, Q, S>;
    // (undocumented)
    get target(): T | undefined;
    // (undocumented)
    toEARL(): Outcome.EARL;
    // (undocumented)
    toJSON(): Outcome.JSON<V>;
    // (undocumented)
    abstract toSARIF(): sarif.Result;
}

// @public (undocumented)
export namespace Outcome {
    // (undocumented)
    export type Applicable<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> = Passed<I, T, Q, S> | Failed<I, T, Q, S> | CantTell<I, T, Q, S>;
    // (undocumented)
    export namespace Applicable {
        // (undocumented)
        export function isApplicable<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is Applicable<I, T, Q, S>;
        // (undocumented)
        export function isApplicable<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Applicable<I, T, Q, S>;
    }
    // Warning: (ae-incompatible-release-tags) The symbol "CantTell" is marked as @public, but its signature references "Value" which is marked as @internal
    //
    // (undocumented)
    export class CantTell<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Outcome<I, T, Q, S, Value.CantTell> {
        // (undocumented)
        get diagnostic(): Diagnostic;
        // (undocumented)
        equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: CantTell<I, T, Q, S>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, target: T, diagnostic: Diagnostic, mode: Mode): CantTell<I, T, Q, S>;
        // (undocumented)
        get target(): T;
        // (undocumented)
        toEARL(): CantTell.EARL;
        // (undocumented)
        toJSON(): CantTell.JSON<T>;
        // (undocumented)
        toSARIF(): sarif.Result;
    }
    // (undocumented)
    export namespace CantTell {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:cantTell";
                };
                "earl:pointer"?: earl.EARL;
            };
        }
        // (undocumented)
        export function isCantTell<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is CantTell<I, T, Q, S>;
        // (undocumented)
        export function isCantTell<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is CantTell<I, T, Q, S>;
        // Warning: (ae-incompatible-release-tags) The symbol "JSON" is marked as @public, but its signature references "Value" which is marked as @internal
        //
        // (undocumented)
        export interface JSON<T> extends Outcome.JSON<Value.CantTell> {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            diagnostic: json.Serializable.ToJSON<Diagnostic>;
            // (undocumented)
            target: json.Serializable.ToJSON<T>;
        }
    }
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@type": "earl:Assertion";
        // (undocumented)
        "earl:mode": `earl:${Mode}`;
        // (undocumented)
        "earl:test": {
            "@id": string;
        };
    }
    // Warning: (ae-incompatible-release-tags) The symbol "Failed" is marked as @public, but its signature references "Value" which is marked as @internal
    //
    // (undocumented)
    export class Failed<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Outcome<I, T, Q, S, Value.Failed> {
        // (undocumented)
        equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: Failed<I, T, Q, S>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get expectations(): Record_2<{
            [key: string]: Result<Diagnostic>;
        }>;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, target: T, expectations: Record_2<{
            [key: string]: Result<Diagnostic>;
        }>, mode: Mode): Failed<I, T, Q, S>;
        // (undocumented)
        get target(): T;
        // (undocumented)
        toEARL(): Failed.EARL;
        // (undocumented)
        toJSON(): Failed.JSON<T>;
        // (undocumented)
        toSARIF(): sarif.Result;
    }
    const // (undocumented)
    passed: typeof Passed.of, // (undocumented)
    isPassed: typeof Passed.isPassed;
    // (undocumented)
    export namespace Failed {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:failed";
                };
                "earl:info": string;
                "earl:pointer"?: earl.EARL;
            };
        }
        // (undocumented)
        export function isFailed<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is Failed<I, T, Q, S>;
        // (undocumented)
        export function isFailed<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Failed<I, T, Q, S>;
        // Warning: (ae-incompatible-release-tags) The symbol "JSON" is marked as @public, but its signature references "Value" which is marked as @internal
        //
        // (undocumented)
        export interface JSON<T> extends Outcome.JSON<Value.Failed> {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            expectations: Array<[string, Result.JSON<Diagnostic.JSON>]>;
            // (undocumented)
            target: json.Serializable.ToJSON<T>;
        }
    }
    // (undocumented)
    export function from<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, target: T, expectations: Record_2<{
        [key: string]: Option<Result<Diagnostic>>;
    }>, mode: Mode): Outcome.Applicable<I, T, Q, S>;
    const // (undocumented)
    failed: typeof Failed.of, // (undocumented)
    isFailed: typeof Failed.isFailed;
    // Warning: (ae-incompatible-release-tags) The symbol "Inapplicable" is marked as @public, but its signature references "Value" which is marked as @internal
    //
    // (undocumented)
    export class Inapplicable<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Outcome<I, T, Q, S, Value.Inapplicable> {
        // (undocumented)
        equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: Inapplicable<I, T, Q, S>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, mode: Mode): Inapplicable<I, T, Q, S>;
        // (undocumented)
        toEARL(): Inapplicable.EARL;
        // (undocumented)
        toJSON(): Inapplicable.JSON;
        // (undocumented)
        toSARIF(): sarif.Result;
    }
    // (undocumented)
    export namespace Inapplicable {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:inapplicable";
                };
            };
        }
        // (undocumented)
        export function isInapplicable<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is Inapplicable<I, T, Q, S>;
        // (undocumented)
        export function isInapplicable<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Inapplicable<I, T, Q, S>;
        // Warning: (ae-incompatible-release-tags) The symbol "JSON" is marked as @public, but its signature references "Value" which is marked as @internal
        //
        // (undocumented)
        export interface JSON extends Outcome.JSON<Value.Inapplicable> {
        }
    }
    const // (undocumented)
    cantTell: typeof CantTell.of, // (undocumented)
    isCantTell: typeof CantTell.isCantTell;
    // Warning: (ae-incompatible-release-tags) The symbol "JSON" is marked as @public, but its signature references "Value" which is marked as @internal
    //
    // (undocumented)
    export interface JSON<V extends Value = Value> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        mode: Mode;
        // (undocumented)
        outcome: V;
        // (undocumented)
        rule: Rule.JSON;
    }
    // (undocumented)
    export enum Mode {
        // (undocumented)
        Automatic = "automatic",
        // (undocumented)
        SemiAuto = "semiAuto"
    }
    const // (undocumented)
    isApplicable: typeof Applicable.isApplicable;
    // Warning: (ae-incompatible-release-tags) The symbol "Passed" is marked as @public, but its signature references "Value" which is marked as @internal
    //
    // (undocumented)
    export class Passed<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Outcome<I, T, Q, S, Value.Passed> {
        // (undocumented)
        equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: Passed<I, T, Q, S>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get expectations(): Record_2<{
            [key: string]: Result<Diagnostic>;
        }>;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>, target: T, expectations: Record_2<{
            [key: string]: Result<Diagnostic>;
        }>, mode: Mode): Passed<I, T, Q, S>;
        // (undocumented)
        get target(): T;
        // (undocumented)
        toEARL(): Passed.EARL;
        // (undocumented)
        toJSON(): Passed.JSON<T>;
        // (undocumented)
        toSARIF(): sarif.Result;
    }
    // (undocumented)
    export namespace Passed {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:passed";
                };
                "earl:info": string;
                "earl:pointer"?: earl.EARL;
            };
        }
        // (undocumented)
        export function isPassed<I, T extends Hashable, Q extends Question.Metadata, S>(value: Outcome<I, T, Q, S>): value is Passed<I, T, Q, S>;
        // (undocumented)
        export function isPassed<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Passed<I, T, Q, S>;
        // Warning: (ae-incompatible-release-tags) The symbol "JSON" is marked as @public, but its signature references "Value" which is marked as @internal
        //
        // (undocumented)
        export interface JSON<T> extends Outcome.JSON<Value.Passed> {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            expectations: Array<[string, Result.JSON<Diagnostic.JSON>]>;
            // (undocumented)
            target: json.Serializable.ToJSON<T>;
        }
    }
    const // (undocumented)
    inapplicable: typeof Inapplicable.of, // (undocumented)
    isInapplicable: typeof Inapplicable.isInapplicable;
    // @internal (undocumented)
    export enum Value {
        // (undocumented)
        CantTell = "cantTell",
        // (undocumented)
        Failed = "failed",
        // (undocumented)
        Inapplicable = "inapplicable",
        // (undocumented)
        Passed = "passed"
    }
}

// @public
export class Question<TYPE, SUBJECT, CONTEXT, ANSWER, T = ANSWER, URI extends string = string> implements Functor<T>, Applicative<T>, Monad<T>, Serializable<Question.JSON<TYPE, SUBJECT, CONTEXT, ANSWER, URI>> {
    protected constructor(type: TYPE, uri: URI, message: string, diagnostic: Diagnostic, fallback: Option<ANSWER>, subject: SUBJECT, context: CONTEXT, quester: Mapper<ANSWER, T>);
    // (undocumented)
    answer(answer: ANSWER): T;
    // (undocumented)
    answerIf(condition: boolean, answer: ANSWER): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    // (undocumented)
    answerIf(predicate: Predicate<SUBJECT, [context: CONTEXT]>, answer: ANSWER): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    // (undocumented)
    answerIf(answer: Option<ANSWER>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    // (undocumented)
    answerIf(answer: Result<ANSWER, Diagnostic>, merger?: Mapper<Diagnostic, Diagnostic, [Diagnostic]>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    // (undocumented)
    answerIf(answer: Result<ANSWER, unknown>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    // (undocumented)
    apply<U>(mapper: Question<TYPE, SUBJECT, CONTEXT, ANSWER, Mapper<T, U>, URI>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>;
    // (undocumented)
    get context(): CONTEXT;
    // (undocumented)
    protected readonly _context: CONTEXT;
    // (undocumented)
    get diagnostic(): Diagnostic;
    // (undocumented)
    protected readonly _diagnostic: Diagnostic;
    // (undocumented)
    get fallback(): Option<ANSWER>;
    // (undocumented)
    protected readonly _fallback: Option<ANSWER>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Question<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>;
    // (undocumented)
    flatten<TYPE, SUBJECT, CONTEXT, ANSWER, T>(this: Question<TYPE, SUBJECT, CONTEXT, ANSWER, Question<TYPE, SUBJECT, CONTEXT, ANSWER, T>>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, T>;
    // (undocumented)
    isRhetorical(): this is Question.Rhetorical<TYPE, SUBJECT, CONTEXT, ANSWER, T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>;
    // (undocumented)
    get message(): string;
    // (undocumented)
    protected readonly _message: string;
    // (undocumented)
    static of<TYPE, SUBJECT, CONTEXT, ANSWER, URI extends string = string>(type: TYPE, uri: URI, message: string, subject: SUBJECT, context: CONTEXT, options?: Question.Options<ANSWER>): Question<TYPE, SUBJECT, CONTEXT, ANSWER, ANSWER, URI>;
    // (undocumented)
    protected readonly _quester: Mapper<ANSWER, T>;
    // (undocumented)
    get subject(): SUBJECT;
    // (undocumented)
    protected readonly _subject: SUBJECT;
    // (undocumented)
    toJSON(): Question.JSON<TYPE, SUBJECT, CONTEXT, ANSWER, URI>;
    // (undocumented)
    get type(): TYPE;
    // (undocumented)
    protected readonly _type: TYPE;
    // (undocumented)
    get uri(): URI;
    // (undocumented)
    protected readonly _uri: URI;
}

// @public (undocumented)
export namespace Question {
    // (undocumented)
    export function isQuestion<TYPE, SUBJECT, CONTEXT, ANSWER, T = ANSWER, URI extends string = string>(value: unknown): value is Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI>;
    // (undocumented)
    export interface JSON<TYPE, SUBJECT, CONTEXT, ANSWER, URI extends string = string> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        context: Serializable.ToJSON<CONTEXT>;
        // (undocumented)
        diagnostic: Diagnostic.JSON;
        // (undocumented)
        fallback: Option.JSON<ANSWER>;
        // (undocumented)
        message: string;
        // (undocumented)
        subject: Serializable.ToJSON<SUBJECT>;
        // (undocumented)
        type: Serializable.ToJSON<TYPE>;
        // (undocumented)
        uri: URI;
    }
    // (undocumented)
    export type Metadata = {
        [uri: string]: [unknown, unknown];
    };
    // (undocumented)
    export interface Options<A> {
        // (undocumented)
        readonly diagnostic?: Diagnostic;
        // (undocumented)
        readonly fallback?: Option<A>;
    }
    // @internal
    export class Rhetorical<TYPE, SUBJECT, CONTEXT, ANSWER, T = ANSWER, URI extends string = string> extends Question<TYPE, SUBJECT, CONTEXT, ANSWER, T, URI> {
        constructor(type: TYPE, uri: URI, message: string, diagnostic: Diagnostic, subject: SUBJECT, context: CONTEXT, answer: T);
        // (undocumented)
        answer(): T;
        // (undocumented)
        map<U>(mapper: Mapper<T, U>): Rhetorical<TYPE, SUBJECT, CONTEXT, ANSWER, U, URI>;
    }
}

// @public (undocumented)
export abstract class Requirement implements Equatable, json.Serializable<Requirement.JSON>, earl.Serializable<Requirement.EARL> {
    protected constructor();
    // (undocumented)
    equals(value: Requirement): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    toEARL(): Requirement.EARL;
    // (undocumented)
    toJSON(): Requirement.JSON;
    // (undocumented)
    abstract get uri(): string;
}

// @public (undocumented)
export namespace Requirement {
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            earl: "http://www.w3.org/ns/earl#";
        };
        // (undocumented)
        "@id": string;
        // (undocumented)
        "@type": ["earl:TestCriterion", "earl:TestRequirement"];
    }
    // (undocumented)
    export function isRequirement(value: unknown): value is Requirement;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        uri: string;
    }
}

// @public
export abstract class Rule<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> implements Equatable, Hashable, json.Serializable<Rule.JSON>, earl.Serializable<Rule.EARL>, sarif.Serializable<sarif.ReportingDescriptor> {
    protected constructor(uri: string, requirements: Array_2<Requirement>, tags: Array_2<Tag>, evaluator: Rule.Evaluate<I, T, Q, S>);
    // (undocumented)
    equals<I, T extends Hashable, Q extends Question.Metadata, S>(value: Rule<I, T, Q, S>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    evaluate(input: I, oracle?: {} extends Q ? any : Oracle<I, T, Q, S>, outcomes?: Cache, performance?: Performance<Rule.Event<I, T, Q, S>>): Future<Iterable_2<Outcome<I, T, Q, S>>>;
    // (undocumented)
    protected readonly _evaluate: Rule.Evaluate<I, T, Q, S>;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    hasRequirement(requirement: Requirement): boolean;
    // (undocumented)
    hasRequirement(predicate: Predicate<Requirement>): boolean;
    // (undocumented)
    hasTag(tag: Tag): boolean;
    // (undocumented)
    hasTag(predicate: Predicate<Tag>): boolean;
    // (undocumented)
    get requirements(): ReadonlyArray<Requirement>;
    // (undocumented)
    protected readonly _requirements: Array_2<Requirement>;
    // (undocumented)
    get tags(): ReadonlyArray<Tag>;
    // (undocumented)
    protected readonly _tags: Array_2<Tag>;
    // (undocumented)
    toEARL(): Rule.EARL;
    // (undocumented)
    abstract toJSON(): Rule.JSON;
    // (undocumented)
    toSARIF(): sarif.ReportingDescriptor;
    // (undocumented)
    get uri(): string;
    // (undocumented)
    protected readonly _uri: string;
}

// @public (undocumented)
export namespace Rule {
    // (undocumented)
    export class Atomic<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Rule<I, T, Q, S> {
        // (undocumented)
        static of<I, T extends Hashable, Q extends Question.Metadata = {}, S = T>(properties: {
            uri: string;
            requirements?: Iterable_2<Requirement>;
            tags?: Iterable_2<Tag>;
            evaluate: Atomic.Evaluate<I, T, Q, S>;
        }): Atomic<I, T, Q, S>;
        // (undocumented)
        toJSON(): Atomic.JSON;
    }
    // (undocumented)
    export namespace Atomic {
        // (undocumented)
        export interface Evaluate<I, T extends Hashable, Q extends Question.Metadata, S> {
            // (undocumented)
            (input: I, performance?: {
                mark: (name: string) => Performance.Mark<Event<I, T, Q, S>>;
                measure: (name: string, start?: number) => Performance.Measure<Event<I, T, Q, S>>;
            }): {
                applicability(): Iterable_2<Interview<Q, S, T, Option.Maybe<T>>>;
                expectations(target: T): {
                    [key: string]: Interview<Q, S, T, Option.Maybe<Result<Diagnostic>>>;
                };
            };
        }
        // (undocumented)
        export function isAtomic<I, T extends Hashable, Q extends Question.Metadata, S>(value: Rule<I, T, Q, S>): value is Atomic<I, T, Q, S>;
        // (undocumented)
        export function isAtomic<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Atomic<I, T, Q, S>;
        // (undocumented)
        export interface JSON extends Rule.JSON {
            // (undocumented)
            type: "atomic";
        }
    }
    // (undocumented)
    export class Composite<I, T extends Hashable, Q extends Question.Metadata = {}, S = T> extends Rule<I, T, Q, S> {
        // (undocumented)
        get composes(): ReadonlyArray<Rule<I, T, Q, S>>;
        // (undocumented)
        static of<I, T extends Hashable, Q extends Question.Metadata = {}, S = T>(properties: {
            uri: string;
            requirements?: Iterable_2<Requirement>;
            tags?: Iterable_2<Tag>;
            composes: Iterable_2<Rule<I, T, Q, S>>;
            evaluate: Composite.Evaluate<I, T, Q, S>;
        }): Composite<I, T, Q, S>;
        // (undocumented)
        toJSON(): Composite.JSON;
    }
    // (undocumented)
    export namespace Composite {
        // (undocumented)
        export interface Evaluate<I, T extends Hashable, Q extends Question.Metadata, S> {
            // (undocumented)
            (input: I, performance?: {
                mark: (name: string) => Performance.Mark<Event<I, T, Q, S>>;
                measure: (name: string, start?: number) => Performance.Measure<Event<I, T, Q, S>>;
            }): {
                expectations(outcomes: Sequence<Outcome.Applicable<I, T, Q, S>>): {
                    [key: string]: Interview<Q, S, T, Option.Maybe<Result<Diagnostic>>>;
                };
            };
        }
        // (undocumented)
        export function isComposite<I, T extends Hashable, Q extends Question.Metadata>(value: Rule<I, T, Q>): value is Composite<I, T, Q>;
        // (undocumented)
        export function isComposite<I, T extends Hashable, Q extends Question.Metadata>(value: unknown): value is Composite<I, T, Q>;
        // (undocumented)
        export interface JSON extends Rule.JSON {
            // (undocumented)
            composes: Array_2<Rule.JSON>;
            // (undocumented)
            type: "composite";
            // (undocumented)
            uri: string;
        }
    }
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            earl: "http://www.w3.org/ns/earl#";
            dct: "http://purl.org/dc/terms/";
        };
        // (undocumented)
        "@id": string;
        // (undocumented)
        "@type": ["earl:TestCriterion", "earl:TestCase"];
        // (undocumented)
        "dct:isPartOf": {
            "@set": Array_2<Requirement.EARL>;
        };
    }
    // (undocumented)
    export interface Evaluate<I, T extends Hashable, Q extends Question.Metadata, S> {
        // (undocumented)
        (input: Readonly<I>, oracle: {} extends Q ? any : Oracle<I, T, Q, S>, outcomes: Cache, performance?: Performance<Event<I, T, Q, S>>): Future<Iterable_2<Outcome<I, T, Q, S>>>;
    }
    // (undocumented)
    export class Event<INPUT, TARGET extends Hashable, QUESTION extends Question.Metadata, SUBJECT, TYPE extends Event.Type = Event.Type, NAME extends string = string> implements Serializable<Event.JSON<TYPE, NAME>> {
        constructor(type: TYPE, rule: Rule<INPUT, TARGET, QUESTION, SUBJECT>, name: NAME);
        // (undocumented)
        get name(): NAME;
        // (undocumented)
        static of<INPUT, TARGET extends Hashable, QUESTION extends Question.Metadata, SUBJECT, TYPE extends Event.Type, NAME extends string>(type: TYPE, rule: Rule<INPUT, TARGET, QUESTION, SUBJECT>, name: NAME): Event<INPUT, TARGET, QUESTION, SUBJECT, TYPE, NAME>;
        // (undocumented)
        get rule(): Rule<INPUT, TARGET, QUESTION, SUBJECT>;
        // (undocumented)
        toJSON(): Event.JSON<TYPE, NAME>;
        // (undocumented)
        get type(): TYPE;
    }
    // (undocumented)
    export namespace Event {
        // (undocumented)
        export function end<I, T extends Hashable, Q extends Question.Metadata, S, N extends string = string>(rule: Rule<I, T, Q, S>, name: N): Event<I, T, Q, S, "end", N>;
        // (undocumented)
        export function end<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "end", "total">;
        // (undocumented)
        export function endApplicability<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "end", "applicability">;
        // (undocumented)
        export function endExpectation<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "end", "expectation">;
        // (undocumented)
        export function isEvent<INPUT, TARGET extends Hashable, QUESTION extends Question.Metadata, SUBJECT, TYPE extends Event.Type = Event.Type, NAME extends string = string>(value: unknown): value is Event<INPUT, TARGET, QUESTION, SUBJECT, TYPE, NAME>;
        // (undocumented)
        export interface JSON<T extends Type = Type, N extends string = string> {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            name: N;
            // (undocumented)
            rule: Rule.JSON;
            // (undocumented)
            type: T;
        }
        // (undocumented)
        export function start<I, T extends Hashable, Q extends Question.Metadata, S, N extends string = string>(rule: Rule<I, T, Q, S>, name: N): Event<I, T, Q, S, "start", N>;
        // (undocumented)
        export function start<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "start", "total">;
        // (undocumented)
        export function startApplicability<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "start", "applicability">;
        // (undocumented)
        export function startExpectation<I, T extends Hashable, Q extends Question.Metadata, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S, "start", "expectation">;
        // (undocumented)
        export type Type = "start" | "end";
    }
    // (undocumented)
    export type Input<R> = R extends Rule<infer I, any, any, any> ? I : never;
    // (undocumented)
    export function isRule<I, T extends Hashable, Q extends Question.Metadata, S>(value: unknown): value is Rule<I, T, Q, S>;
    const // (undocumented)
    isAtomic: typeof Atomic.isAtomic;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        requirements: Array_2<Requirement.JSON>;
        // (undocumented)
        tags: Array_2<Tag.JSON>;
        // (undocumented)
        type: string;
        // (undocumented)
        uri: string;
    }
    // (undocumented)
    export type Question<R> = R extends Rule<any, any, infer Q, any> ? Q : never;
    const // (undocumented)
    isComposite: typeof Composite.isComposite;
    // (undocumented)
    export type Subject<R> = R extends Rule<any, any, any, infer S> ? S : never;
    // (undocumented)
    export type Target<R> = R extends Rule<any, infer T, any, any> ? T : never;
}

// @public (undocumented)
export abstract class Tag<T extends string = string> implements Equatable, Serializable<Tag.JSON> {
    protected constructor();
    // (undocumented)
    equals(value: Tag): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    toJSON(): Tag.JSON<T>;
    // (undocumented)
    abstract get type(): T;
}

// @public (undocumented)
export namespace Tag {
    // (undocumented)
    export function isTag<T extends string>(value: unknown, type?: T): value is Tag<T>;
    // (undocumented)
    export interface JSON<T extends string = string> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: T;
    }
}

```
