## API Report File for "@siteimprove/alfa-act"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Applicative } from '@siteimprove/alfa-applicative';
import * as earl from '@siteimprove/alfa-earl';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Functor } from '@siteimprove/alfa-functor';
import { Future } from '@siteimprove/alfa-future';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Monad } from '@siteimprove/alfa-monad';
import { Option } from '@siteimprove/alfa-option';
import { Performance } from '@siteimprove/alfa-performance';
import { Record as Record_2 } from '@siteimprove/alfa-record';
import { Result } from '@siteimprove/alfa-result';
import * as sarif from '@siteimprove/alfa-sarif';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';
import { Thunk } from '@siteimprove/alfa-thunk';

// @public (undocumented)
export class Audit<I, T = unknown, Q = never, S = T> {
    // (undocumented)
    evaluate(performance?: Performance<Audit.Event<I, T, Q, S>>): Future<Iterable_2<Outcome<I, T, Q, S>>>;
    // (undocumented)
    static of<I, T = unknown, Q = never, S = T>(input: I, rules: Iterable_2<Rule<I, T, Q, S>>, oracle?: Oracle<I, T, Q, S>): Audit<I, T, Q, S>;
}

// @public (undocumented)
export namespace Audit {
    // (undocumented)
    export class Event<I, T, Q, S> implements Serializable<Event.JSON> {
        // (undocumented)
        static end<I, T, Q, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S>;
        // (undocumented)
        get name(): Event.Name;
        // (undocumented)
        static of<I, T, Q, S>(name: Event.Name, rule: Rule<I, T, Q, S>): Event<I, T, Q, S>;
        // (undocumented)
        get rule(): Rule<I, T, Q, S>;
        // (undocumented)
        static start<I, T, Q, S>(rule: Rule<I, T, Q, S>): Event<I, T, Q, S>;
        // (undocumented)
        toJSON(): Event.JSON;
    }
    // (undocumented)
    export namespace Event {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            name: Name;
            // (undocumented)
            rule: Rule.JSON;
        }
        // (undocumented)
        export type Name = "start" | "end";
    }
    const // (undocumented)
    event: typeof Event.of, // (undocumented)
    start: typeof Event.start, // (undocumented)
    end: typeof Event.end;
}

// @public (undocumented)
export class Cache {
    // (undocumented)
    static empty(): Cache;
    // (undocumented)
    get<I, T, Q, S>(rule: Rule<I, T, Q, S>, ifMissing: Thunk<Future<Iterable<Outcome<I, T, Q, S>>>>): Future<Iterable<Outcome<I, T, Q, S>>>;
}

// @public (undocumented)
export class Diagnostic implements Equatable, Serializable<Diagnostic.JSON> {
    protected constructor(message: string);
    // (undocumented)
    equals(value: Diagnostic): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get message(): string;
    // (undocumented)
    protected readonly _message: string;
    // (undocumented)
    static of(message: string): Diagnostic;
    // (undocumented)
    toJSON(): Diagnostic.JSON;
}

// @public (undocumented)
export namespace Diagnostic {
    // (undocumented)
    export function isDiagnostic(value: unknown): value is Diagnostic;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        message: string;
    }
}

// Warning: (ae-forgotten-export) The symbol "Depths" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Interview<Q, S, C, A, D extends number = 3> = A | {
    [K in keyof Q]: Question<K, S, C, Q[K], D extends -1 ? A : Interview<Q, S, C, A, Depths[D]>>;
}[keyof Q];

// @public (undocumented)
export namespace Interview {
    // (undocumented)
    export function conduct<I, T, Q, S, A>(interview: Interview<Q, S, T, A>, rule: Rule<I, T, Q, S>, oracle: Oracle<I, T, Q, S>): Future<Option<A>>;
}

// @public (undocumented)
export type Oracle<I, T, Q, S> = <A>(rule: Rule<I, T, Q, S>, question: {
    [K in keyof Q]: Question<K, S, T, Q[K], A>;
}[keyof Q]) => Future<Option<A>>;

// @public (undocumented)
export abstract class Outcome<I, T, Q = never, S = T> implements Equatable, json.Serializable<Outcome.JSON>, earl.Serializable<Outcome.EARL>, sarif.Serializable<sarif.Result> {
    protected constructor(rule: Rule<I, T, Q, S>);
    // (undocumented)
    abstract equals<I, T, Q, S>(value: Outcome<I, T, Q, S>): boolean;
    // (undocumented)
    abstract equals(value: unknown): value is this;
    // (undocumented)
    get rule(): Rule<I, T, Q, S>;
    // (undocumented)
    protected readonly _rule: Rule<I, T, Q, S>;
    // (undocumented)
    get target(): T | undefined;
    // (undocumented)
    toEARL(): Outcome.EARL;
    // (undocumented)
    abstract toJSON(): Outcome.JSON;
    // (undocumented)
    abstract toSARIF(): sarif.Result;
}

// @public (undocumented)
export namespace Outcome {
    // (undocumented)
    export type Applicable<I, T, Q = unknown, S = T> = Passed<I, T, Q, S> | Failed<I, T, Q, S> | CantTell<I, T, Q, S>;
    // (undocumented)
    export namespace Applicable {
        // (undocumented)
        export function isApplicable<I, T, Q, S>(value: Outcome<I, T, Q, S>): value is Applicable<I, T, Q, S>;
        // (undocumented)
        export function isApplicable<I, T, Q, S>(value: unknown): value is Applicable<I, T, Q, S>;
    }
    // (undocumented)
    export class CantTell<I, T, Q = never, S = T> extends Outcome<I, T, Q, S> {
        // (undocumented)
        equals<I, T, Q, S>(value: CantTell<I, T, Q, S>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of<I, T, Q, S>(rule: Rule<I, T, Q, S>, target: T): CantTell<I, T, Q, S>;
        // (undocumented)
        get target(): T;
        // (undocumented)
        toEARL(): CantTell.EARL;
        // (undocumented)
        toJSON(): CantTell.JSON<T>;
        // (undocumented)
        toSARIF(): sarif.Result;
    }
    // (undocumented)
    export namespace CantTell {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:cantTell";
                };
                "earl:pointer"?: earl.EARL;
            };
        }
        // (undocumented)
        export function isCantTell<I, T, Q, S>(value: Outcome<I, T, Q, S>): value is CantTell<I, T, Q, S>;
        // (undocumented)
        export function isCantTell<I, T, Q, S>(value: unknown): value is CantTell<I, T, Q, S>;
        // (undocumented)
        export interface JSON<T> extends Outcome.JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            outcome: "cantTell";
            // (undocumented)
            target: json.Serializable.ToJSON<T>;
        }
    }
    const // (undocumented)
    passed: typeof Passed.of, // (undocumented)
    isPassed: typeof Passed.isPassed;
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@type": "earl:Assertion";
        // (undocumented)
        "earl:test": {
            "@id": string;
        };
    }
    // (undocumented)
    export class Failed<I, T, Q = never, S = T> extends Outcome<I, T, Q, S> {
        // (undocumented)
        equals<I, T, Q, S>(value: Failed<I, T, Q, S>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get expectations(): Record_2<{
            [key: string]: Result<Diagnostic>;
        }>;
        // (undocumented)
        static of<I, T, Q, S>(rule: Rule<I, T, Q, S>, target: T, expectations: Record_2<{
            [key: string]: Result<Diagnostic>;
        }>): Failed<I, T, Q, S>;
        // (undocumented)
        get target(): T;
        // (undocumented)
        toEARL(): Failed.EARL;
        // (undocumented)
        toJSON(): Failed.JSON<T>;
        // (undocumented)
        toSARIF(): sarif.Result;
    }
    const // (undocumented)
    failed: typeof Failed.of, // (undocumented)
    isFailed: typeof Failed.isFailed;
    // (undocumented)
    export namespace Failed {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:failed";
                };
                "earl:info": string;
                "earl:pointer"?: earl.EARL;
            };
        }
        // (undocumented)
        export function isFailed<I, T, Q, S>(value: Outcome<I, T, Q, S>): value is Failed<I, T, Q, S>;
        // (undocumented)
        export function isFailed<I, T, Q, S>(value: unknown): value is Failed<I, T, Q, S>;
        // (undocumented)
        export interface JSON<T> extends Outcome.JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            expectations: Array<[string, Result.JSON<Diagnostic.JSON>]>;
            // (undocumented)
            outcome: "failed";
            // (undocumented)
            target: json.Serializable.ToJSON<T>;
        }
    }
    // (undocumented)
    export function from<I, T, Q, S>(rule: Rule<I, T, Q, S>, target: T, expectations: Record_2<{
        [key: string]: Option<Result<Diagnostic>>;
    }>): Outcome.Applicable<I, T, Q, S>;
    const // (undocumented)
    cantTell: typeof CantTell.of, // (undocumented)
    isCantTell: typeof CantTell.isCantTell;
    // (undocumented)
    export class Inapplicable<I, T, Q = unknown, S = T> extends Outcome<I, T, Q, S> {
        // (undocumented)
        equals<I, T, Q, S>(value: Inapplicable<I, T, Q, S>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of<I, T, Q, S>(rule: Rule<I, T, Q, S>): Inapplicable<I, T, Q, S>;
        // (undocumented)
        toEARL(): Inapplicable.EARL;
        // (undocumented)
        toJSON(): Inapplicable.JSON;
        // (undocumented)
        toSARIF(): sarif.Result;
    }
    // (undocumented)
    export namespace Inapplicable {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:inapplicable";
                };
            };
        }
        // (undocumented)
        export function isInapplicable<I, T, Q, S>(value: Outcome<I, T, Q, S>): value is Inapplicable<I, T, Q, S>;
        // (undocumented)
        export function isInapplicable<I, T, Q, S>(value: unknown): value is Inapplicable<I, T, Q, S>;
        // (undocumented)
        export interface JSON extends Outcome.JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            outcome: "inapplicable";
        }
    }
    const // (undocumented)
    isApplicable: typeof Applicable.isApplicable;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        outcome: string;
        // (undocumented)
        rule: Rule.JSON;
    }
    // (undocumented)
    export class Passed<I, T, Q = never, S = T> extends Outcome<I, T, Q, S> {
        // (undocumented)
        equals<I, T, Q, S>(value: Passed<I, T, Q, S>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get expectations(): Record_2<{
            [key: string]: Result<Diagnostic>;
        }>;
        // (undocumented)
        static of<I, T, Q, S>(rule: Rule<I, T, Q, S>, target: T, expectations: Record_2<{
            [key: string]: Result<Diagnostic>;
        }>): Passed<I, T, Q, S>;
        // (undocumented)
        get target(): T;
        // (undocumented)
        toEARL(): Passed.EARL;
        // (undocumented)
        toJSON(): Passed.JSON<T>;
        // (undocumented)
        toSARIF(): sarif.Result;
    }
    const // (undocumented)
    inapplicable: typeof Inapplicable.of, // (undocumented)
    isInapplicable: typeof Inapplicable.isInapplicable;
    // (undocumented)
    export namespace Passed {
        // (undocumented)
        export interface EARL extends Outcome.EARL {
            // (undocumented)
            "earl:result": {
                "@type": "earl:TestResult";
                "earl:outcome": {
                    "@id": "earl:passed";
                };
                "earl:info": string;
                "earl:pointer"?: earl.EARL;
            };
        }
        // (undocumented)
        export function isPassed<I, T, Q, S>(value: Outcome<I, T, Q, S>): value is Passed<I, T, Q, S>;
        // (undocumented)
        export function isPassed<I, T, Q, S>(value: unknown): value is Passed<I, T, Q, S>;
        // (undocumented)
        export interface JSON<T> extends Outcome.JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            expectations: Array<[string, Result.JSON<Diagnostic.JSON>]>;
            // (undocumented)
            outcome: "passed";
            // (undocumented)
            target: json.Serializable.ToJSON<T>;
        }
    }
}

// @public (undocumented)
export class Question<Q, S, C, A, T = A> implements Functor<T>, Applicative<T>, Monad<T>, Serializable<Question.JSON<Q, S, C>> {
    protected constructor(type: Q, uri: string, message: string, subject: S, context: C, quester: Mapper<A, T>);
    // (undocumented)
    answer(answer: A): T;
    // (undocumented)
    apply<U>(mapper: Question<Q, S, C, A, Mapper<T, U>>): Question<Q, S, C, A, U>;
    // (undocumented)
    get context(): C;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Question<Q, S, C, A, U>>): Question<Q, S, C, A, U>;
    // (undocumented)
    flatten<Q, S, C, A, T>(this: Question<Q, S, C, A, Question<Q, S, C, A, T>>): Question<Q, S, C, A, T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Question<Q, S, C, A, U>;
    // (undocumented)
    get message(): string;
    // (undocumented)
    static of<Q, S, C, A>(type: Q, uri: string, message: string, subject: S, context: C): Question<Q, S, C, A>;
    // (undocumented)
    get subject(): S;
    // (undocumented)
    toJSON(): Question.JSON<Q, S, C>;
    // (undocumented)
    get type(): Q;
    // (undocumented)
    get uri(): string;
}

// @public (undocumented)
export namespace Question {
    // (undocumented)
    export function isQuestion<Q, S, C, A, T = A>(value: unknown): value is Question<Q, S, C, A, T>;
    // (undocumented)
    export interface JSON<Q, S, C> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        context: Serializable.ToJSON<C>;
        // (undocumented)
        message: string;
        // (undocumented)
        subject: Serializable.ToJSON<S>;
        // (undocumented)
        type: Serializable.ToJSON<Q>;
        // (undocumented)
        uri: string;
    }
}

// @public (undocumented)
export abstract class Requirement implements Equatable, json.Serializable<Requirement.JSON>, earl.Serializable<Requirement.EARL> {
    protected constructor();
    // (undocumented)
    equals(value: Requirement): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    toEARL(): Requirement.EARL;
    // (undocumented)
    toJSON(): Requirement.JSON;
    // (undocumented)
    abstract get uri(): string;
}

// @public (undocumented)
export namespace Requirement {
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            earl: "http://www.w3.org/ns/earl#";
        };
        // (undocumented)
        "@id": string;
        // (undocumented)
        "@type": ["earl:TestCriterion", "earl:TestRequirement"];
    }
    // (undocumented)
    export function isRequirement(value: unknown): value is Requirement;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        uri: string;
    }
}

// @public (undocumented)
export abstract class Rule<I = unknown, T = unknown, Q = never, S = T> implements Equatable, json.Serializable<Rule.JSON>, earl.Serializable<Rule.EARL>, sarif.Serializable<sarif.ReportingDescriptor> {
    protected constructor(uri: string, requirements: Array<Requirement>, tags: Array<Tag>, evaluator: Rule.Evaluate<I, T, Q, S>);
    // (undocumented)
    equals<I, T, Q, S>(value: Rule<I, T, Q, S>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    evaluate(input: Readonly<I>, oracle?: Oracle<I, T, Q, S>, outcomes?: Cache): Future<Iterable_2<Outcome<I, T, Q, S>>>;
    // (undocumented)
    protected readonly _evaluate: Rule.Evaluate<I, T, Q, S>;
    // (undocumented)
    get requirements(): ReadonlyArray<Requirement>;
    // (undocumented)
    protected readonly _requirements: Array<Requirement>;
    // (undocumented)
    get tags(): ReadonlyArray<Tag>;
    // (undocumented)
    protected readonly _tags: Array<Tag>;
    // (undocumented)
    toEARL(): Rule.EARL;
    // (undocumented)
    abstract toJSON(): Rule.JSON;
    // (undocumented)
    toSARIF(): sarif.ReportingDescriptor;
    // (undocumented)
    get uri(): string;
    // (undocumented)
    protected readonly _uri: string;
}

// @public (undocumented)
export namespace Rule {
    // (undocumented)
    export class Atomic<I = unknown, T = unknown, Q = never, S = T> extends Rule<I, T, Q, S> {
        // (undocumented)
        static of<I, T = unknown, Q = never, S = T>(properties: {
            uri: string;
            requirements?: Iterable_2<Requirement>;
            tags?: Iterable_2<Tag>;
            evaluate: Atomic.Evaluate<I, T, Q, S>;
        }): Atomic<I, T, Q, S>;
        // (undocumented)
        toJSON(): Atomic.JSON;
    }
    // (undocumented)
    export namespace Atomic {
        // (undocumented)
        export interface Evaluate<I, T, Q, S> {
            // (undocumented)
            (input: Readonly<I>): {
                applicability(): Iterable_2<Interview<Q, S, T, Option.Maybe<T>>>;
                expectations(target: T): {
                    [key: string]: Interview<Q, S, T, Option.Maybe<Result<Diagnostic>>>;
                };
            };
        }
        // (undocumented)
        export interface JSON extends Rule.JSON {
            // (undocumented)
            type: "atomic";
        }
    }
    // (undocumented)
    export class Composite<I = unknown, T = unknown, Q = never, S = T> extends Rule<I, T, Q, S> {
        // (undocumented)
        get composes(): ReadonlyArray<Rule<I, T, Q, S>>;
        // (undocumented)
        static of<I, T = unknown, Q = never, S = T>(properties: {
            uri: string;
            requirements?: Iterable_2<Requirement>;
            tags?: Iterable_2<Tag>;
            composes: Iterable_2<Rule<I, T, Q, S>>;
            evaluate: Composite.Evaluate<I, T, Q, S>;
        }): Composite<I, T, Q, S>;
        // (undocumented)
        toJSON(): Composite.JSON;
    }
    // (undocumented)
    export namespace Composite {
        // (undocumented)
        export interface Evaluate<I, T, Q, S> {
            // (undocumented)
            (input: Readonly<I>): {
                expectations(outcomes: Sequence<Outcome.Applicable<I, T, Q, S>>): {
                    [key: string]: Interview<Q, S, T, Option.Maybe<Result<Diagnostic>>>;
                };
            };
        }
        // (undocumented)
        export interface JSON extends Rule.JSON {
            // (undocumented)
            composes: Array<Rule.JSON>;
            // (undocumented)
            type: "composite";
            // (undocumented)
            uri: string;
        }
    }
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            earl: "http://www.w3.org/ns/earl#";
            dct: "http://purl.org/dc/terms/";
        };
        // (undocumented)
        "@id": string;
        // (undocumented)
        "@type": ["earl:TestCriterion", "earl:TestCase"];
        // (undocumented)
        "dct:isPartOf": {
            "@set": Array<Requirement.EARL>;
        };
    }
    // (undocumented)
    export interface Evaluate<I, T, Q, S> {
        // (undocumented)
        (input: Readonly<I>, oracle: Oracle<I, T, Q, S>, outcomes: Cache): Future<Iterable_2<Outcome<I, T, Q, S>>>;
    }
    // (undocumented)
    export type Input<R> = R extends Rule<infer I, any, any, any> ? I : never;
    // (undocumented)
    export function isAtomic<I, T, Q, S>(value: Rule<I, T, Q, S>): value is Atomic<I, T, Q, S>;
    // (undocumented)
    export function isAtomic<I, T, Q, S>(value: unknown): value is Atomic<I, T, Q, S>;
    // (undocumented)
    export function isComposite<I, T, Q>(value: Rule<I, T, Q>): value is Composite<I, T, Q>;
    // (undocumented)
    export function isComposite<I, T, Q>(value: unknown): value is Composite<I, T, Q>;
    // (undocumented)
    export function isRule<I, T, Q, S>(value: unknown): value is Rule<I, T, Q, S>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        requirements: Array<Requirement.JSON>;
        // (undocumented)
        tags: Array<Tag.JSON>;
        // (undocumented)
        type: string;
        // (undocumented)
        uri: string;
    }
    // (undocumented)
    export type Question<R> = R extends Rule<any, any, infer Q, any> ? Q : never;
    // (undocumented)
    export type Subject<R> = R extends Rule<any, any, any, infer S> ? S : never;
    // (undocumented)
    export type Target<R> = R extends Rule<any, infer T, any, any> ? T : never;
}

// @public (undocumented)
export abstract class Tag<T extends string = string> implements Equatable, Serializable<Tag.JSON> {
    protected constructor();
    // (undocumented)
    equals(value: Tag): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    toJSON(): Tag.JSON;
    // (undocumented)
    abstract get type(): T;
}

// @public (undocumented)
export namespace Tag {
    // (undocumented)
    export function isTag<T extends string>(value: unknown, type?: T): value is Tag<T>;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: string;
    }
}

```
