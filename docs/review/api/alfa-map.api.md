## API Report File for "@siteimprove/alfa-map"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Callback } from '@siteimprove/alfa-callback';
import { Collection } from '@siteimprove/alfa-collection';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Functor } from '@siteimprove/alfa-functor';
import { Hash } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Option } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Reducer } from '@siteimprove/alfa-reducer';
import { Refinement } from '@siteimprove/alfa-refinement';

// Warning: (ae-internal-missing-underscore) The name "Collision" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Collision<K, V> implements Node<K, V> {
    // (undocumented)
    [Symbol.iterator](): Iterator<[K, V]>;
    // (undocumented)
    delete(key: K, hash: number): Status<Node<K, V>>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get(key: K, hash: number, shift: number): Option<V>;
    // (undocumented)
    isEmpty(): this is Empty;
    // (undocumented)
    isLeaf(): this is Leaf<K, V>;
    // (undocumented)
    map<U>(mapper: Mapper<V, U, [K]>): Collision<K, U>;
    // (undocumented)
    static of<K, V>(hash: number, nodes: Array<Leaf<K, V>>): Collision<K, V>;
    // Warning: (ae-forgotten-export) The symbol "Status" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    set(key: K, value: V, hash: number, shift: number): Status<Node<K, V>>;
}

// Warning: (ae-internal-missing-underscore) The name "Empty" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface Empty extends Node<never, never> {
}

// @internal (undocumented)
export const Empty: Empty;

// Warning: (ae-internal-missing-underscore) The name "Leaf" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Leaf<K, V> implements Node<K, V> {
    // (undocumented)
    [Symbol.iterator](): Iterator<[K, V]>;
    // (undocumented)
    delete(key: K, hash: number): Status<Node<K, V>>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get(key: K, hash: number, shift: number): Option<V>;
    // (undocumented)
    isEmpty(): this is Empty;
    // (undocumented)
    isLeaf(): this is Leaf<K, V>;
    // (undocumented)
    get key(): K;
    // (undocumented)
    map<U>(mapper: Mapper<V, U, [K]>): Leaf<K, U>;
    // (undocumented)
    static of<K, V>(hash: number, key: K, value: V): Leaf<K, V>;
    // (undocumented)
    set(key: K, value: V, hash: number, shift: number): Status<Node<K, V>>;
    // (undocumented)
    get value(): V;
    }

// @public (undocumented)
class Map_2<K, V> implements Collection.Keyed<K, V> {
    // (undocumented)
    [Symbol.iterator](): Iterator<[K, V]>;
    // (undocumented)
    apply<U>(mapper: Map_2<K, Mapper<V, U>>): Map_2<K, U>;
    // (undocumented)
    collect<U>(mapper: Mapper<V, Option<U>, [K]>): Map_2<K, U>;
    // (undocumented)
    collectFirst<U>(mapper: Mapper<V, Option<U>, [K]>): Option<U>;
    // (undocumented)
    concat(iterable: Iterable_2<readonly [K, V]>): Map_2<K, V>;
    // (undocumented)
    count(predicate: Predicate<V, [K]>): number;
    // (undocumented)
    delete(key: K): Map_2<K, V>;
    // (undocumented)
    distinct(): Map_2<K, V>;
    // (undocumented)
    static empty<K = never, V = never>(): Map_2<K, V>;
    // (undocumented)
    equals<K, V>(value: Map_2<K, V>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    every(predicate: Predicate<V, [K]>): boolean;
    // (undocumented)
    filter<U extends V>(refinement: Refinement<V, U, [K]>): Map_2<K, U>;
    // (undocumented)
    filter(predicate: Predicate<V, [K]>): Map_2<K, V>;
    // (undocumented)
    find<U extends V>(refinement: Refinement<V, U, [K]>): Option<U>;
    // (undocumented)
    find(predicate: Predicate<V, [K]>): Option<V>;
    // (undocumented)
    flatMap<L, U>(mapper: Mapper<V, Map_2<L, U>, [K]>): Map_2<L, U>;
    // (undocumented)
    forEach(callback: Callback<V, void, [K]>): void;
    // (undocumented)
    get(key: K): Option<V>;
    // (undocumented)
    has(key: K): boolean;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    includes(value: V): boolean;
    // (undocumented)
    intersect(iterable: Iterable_2<readonly [K, V]>): Map_2<K, V>;
    // (undocumented)
    isEmpty(): this is Map_2<K, never>;
    // (undocumented)
    iterator(): Iterator<[K, V]>;
    // (undocumented)
    keys(): Iterable_2<K>;
    // (undocumented)
    map<U>(mapper: Mapper<V, U, [K]>): Map_2<K, U>;
    // (undocumented)
    none(predicate: Predicate<V, [K]>): boolean;
    // (undocumented)
    static of<K, V>(...entries: Array_2<readonly [K, V]>): Map_2<K, V>;
    // (undocumented)
    reduce<R>(reducer: Reducer<V, R, [K]>, accumulator: R): R;
    // (undocumented)
    reject<U extends V>(refinement: Refinement<V, U, [K]>): Map_2<K, Exclude<V, U>>;
    // (undocumented)
    reject(predicate: Predicate<V, [K]>): Map_2<K, V>;
    // (undocumented)
    set(key: K, value: V): Map_2<K, V>;
    // (undocumented)
    get size(): number;
    // (undocumented)
    some(predicate: Predicate<V, [K]>): boolean;
    // (undocumented)
    subtract(iterable: Iterable_2<readonly [K, V]>): Map_2<K, V>;
    // (undocumented)
    toArray(): Array_2<[K, V]>;
    // (undocumented)
    toJSON(): Map_2.JSON<K, V>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    values(): Iterable_2<V>;
}

// @public (undocumented)
namespace Map_2 {
    // (undocumented)
    function from<K, V>(iterable: Iterable_2<readonly [K, V]>): Map_2<K, V>;
    // (undocumented)
    function fromArray<K, V>(array: Array_2<readonly [K, V]>): Map_2<K, V>;
    // (undocumented)
    function fromIterable<K, V>(iterable: Iterable_2<readonly [K, V]>): Map_2<K, V>;
    // (undocumented)
    function isMap<K, V>(value: Iterable_2<readonly [K, V]>): value is Map_2<K, V>;
    // (undocumented)
    function isMap<K, V>(value: unknown): value is Map_2<K, V>;
    // (undocumented)
    type JSON<K, V> = Collection.Keyed.JSON<K, V>;
}

export { Map_2 as Map }

// Warning: (ae-internal-missing-underscore) The name "Node" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface Node<K, V> extends Functor<V>, Iterable_2<[K, V]>, Equatable {
    // (undocumented)
    delete(key: K, hash: number, shift: number): Status<Node<K, V>>;
    // (undocumented)
    get(key: K, hash: number, shift: number): Option<V>;
    // (undocumented)
    isEmpty(): this is Empty;
    // (undocumented)
    isLeaf(): this is Leaf<K, V>;
    // (undocumented)
    map<U>(mapper: Mapper<V, U, [K]>): Node<K, U>;
    // (undocumented)
    set(key: K, value: V, hash: number, shift: number): Status<Node<K, V>>;
}

// @internal (undocumented)
export namespace Node {
    const // (undocumented)
    Bits = 5;
    // (undocumented)
    export function fragment(hash: number, shift: number): number;
    // (undocumented)
    export function index(fragment: number, mask: number): number;
}

// Warning: (ae-internal-missing-underscore) The name "Sparse" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export class Sparse<K, V> implements Node<K, V> {
    // (undocumented)
    [Symbol.iterator](): Iterator<[K, V]>;
    // (undocumented)
    delete(key: K, hash: number, shift: number): Status<Node<K, V>>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get(key: K, hash: number, shift: number): Option<V>;
    // (undocumented)
    isEmpty(): this is Empty;
    // (undocumented)
    isLeaf(): this is Leaf<K, V>;
    // (undocumented)
    map<U>(mapper: Mapper<V, U, [K]>): Sparse<K, U>;
    // (undocumented)
    static of<K, V>(mask: number, nodes: Array<Node<K, V>>): Sparse<K, V>;
    // (undocumented)
    set(key: K, value: V, hash: number, shift: number): Status<Node<K, V>>;
}


// (No @packageDocumentation comment for this package)

```
