## API Report File for "@siteimprove/alfa-tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as earl from '@siteimprove/alfa-earl';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Flags } from '@siteimprove/alfa-flags';
import * as json from '@siteimprove/alfa-json';
import { Option } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Refinement } from '@siteimprove/alfa-refinement';
import * as sarif from '@siteimprove/alfa-sarif';
import { Sequence } from '@siteimprove/alfa-sequence';

// @public
export abstract class Node<F extends Flags, T extends string = string> implements Iterable<Node<F>>, Equatable, earl.Serializable<Node.EARL>, json.Serializable<Node.JSON<T>>, sarif.Serializable<sarif.Location> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Node<F>>;
    protected constructor(children: Array<Node<F>>, type: T, defaultFlags: F);
    // (undocumented)
    ancestors(options?: F): Sequence<Node<F>>;
    // @internal (undocumented)
    _attachParent(parent: Node<F>): boolean;
    // (undocumented)
    children(options?: F): Sequence<Node<F>>;
    // (undocumented)
    protected readonly _children: Array<Node<F>>;
    // (undocumented)
    closest<T extends Node<F>>(refinement: Refinement<Node<F>, T>, options?: F): Option<T>;
    // (undocumented)
    closest(predicate: Predicate<Node<F>>, options?: F): Option<Node<F>>;
    // (undocumented)
    protected readonly _defaultFlags: F;
    // (undocumented)
    descendants(options?: F): Sequence<Node<F>>;
    // (undocumented)
    equals(value: Node<F>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    first(options?: F): Option<Node<F>>;
    // (undocumented)
    following(options?: F): Sequence<Node<F>>;
    freeze(): this;
    // (undocumented)
    get frozen(): boolean;
    protected _frozen: boolean;
    // (undocumented)
    inclusiveAncestors(options?: F): Sequence<Node<F>>;
    // (undocumented)
    inclusiveDescendants(options?: F): Sequence<Node<F>>;
    // (undocumented)
    inclusiveSiblings(options?: F): Sequence<Node<F>>;
    // (undocumented)
    index(options?: F): number;
    // (undocumented)
    isAncestorOf(node: Node<F>, options?: F): boolean;
    // (undocumented)
    isChildOf(node: Node<F>, options?: F): boolean;
    // (undocumented)
    isDescendantOf(node: Node<F>, options?: F): boolean;
    // (undocumented)
    isInclusiveAncestorOf(node: Node<F>, options?: F): boolean;
    // (undocumented)
    isInclusiveDescendantsOf(node: Node<F>, options?: F): boolean;
    // (undocumented)
    isInclusiveSiblingOf(node: Node<F>, options?: F): boolean;
    // (undocumented)
    isParentOf(node: Node<F>, options?: F): boolean;
    // (undocumented)
    isRootOf(node: Node<F>, options?: F): boolean;
    // (undocumented)
    isSiblingOf(node: Node<F>, options?: F): boolean;
    // (undocumented)
    last(options?: F): Option<Node<F>>;
    // (undocumented)
    next(options?: F): Option<Node<F>>;
    // (undocumented)
    parent(options?: F): Option<Node<F>>;
    // (undocumented)
    protected _parent: Option<Node<F>>;
    // (undocumented)
    path(): string;
    // (undocumented)
    preceding(options?: F): Sequence<Node<F>>;
    // (undocumented)
    previous(options?: F): Option<Node<F>>;
    // (undocumented)
    root(options?: F): Node<F>;
    // (undocumented)
    siblings(options?: F): Sequence<Node<F>>;
    // (undocumented)
    toEARL(): Node.EARL;
    // (undocumented)
    toJSON(): Node.JSON<T>;
    // (undocumented)
    toSARIF(): sarif.Location;
    // (undocumented)
    get type(): T;
    // (undocumented)
    protected readonly _type: T;
}

// @public (undocumented)
export namespace Node {
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            ptr: "http://www.w3.org/2009/pointers#";
        };
        // (undocumented)
        "@type": [
        "ptr:Pointer",
        "ptr:SinglePointer",
        "ptr:ExpressionPointer",
        "ptr:XPathPointer"
        ];
        // (undocumented)
        "ptr:expression": string;
        // (undocumented)
        "ptr:reference"?: {
            "@id": string;
        };
    }
    // (undocumented)
    export function isNode<F extends Flags>(value: unknown): value is Node<F>;
    // (undocumented)
    export interface JSON<T extends string = string> {
        // (undocumented)
        [key: string]: json.JSON | undefined;
        // (undocumented)
        type: T;
    }
}

// (No @packageDocumentation comment for this package)

```
