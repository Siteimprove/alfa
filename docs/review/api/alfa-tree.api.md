## API Report File for "@siteimprove/alfa-tree"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Equatable } from '@siteimprove/alfa-equatable';
import type { Flags } from '@siteimprove/alfa-flags';
import type { Hash } from '@siteimprove/alfa-hash';
import type { Hashable } from '@siteimprove/alfa-hash';
import * as json from '@siteimprove/alfa-json';
import { Option } from '@siteimprove/alfa-option';
import type { Predicate } from '@siteimprove/alfa-predicate';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Sequence } from '@siteimprove/alfa-sequence';

// @public
export abstract class Node<K extends string, F extends Flags.allFlags, T extends string = string> implements Iterable<Node<K, F>>, Equatable, Hashable, json.Serializable<Node.JSON<T>> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Node<K, F>>;
    protected constructor(children: Array<Node<K, F>>, type: T, externalId?: string, internalId?: string, extraData?: any);
    // (undocumented)
    ancestors(options?: Flags<K, F>): Sequence<Node<K, F>>;
    // @internal (undocumented)
    _attachParent(parent: Node<K, F>): boolean;
    // (undocumented)
    children(options?: Flags<K, F>): Sequence<Node<K, F>>;
    // (undocumented)
    protected readonly _children: Array<Node<K, F>>;
    // (undocumented)
    closest<T extends Node<K, F>>(refinement: Refinement<Node<K, F>, T>, options?: Flags<K, F>): Option<T>;
    // (undocumented)
    closest(predicate: Predicate<Node<K, F>>, options?: Flags<K, F>): Option<Node<K, F>>;
    // (undocumented)
    descendants(options?: Flags<K, F>): Sequence<Node<K, F>>;
    // (undocumented)
    equals(value: Node<K, F>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get externalId(): string | undefined;
    // (undocumented)
    get extraData(): any;
    // (undocumented)
    first(options?: Flags<K, F>): Option<Node<K, F>>;
    // (undocumented)
    following(options?: Flags<K, F>): Sequence<Node<K, F>>;
    freeze(): this;
    // (undocumented)
    get frozen(): boolean;
    protected _frozen: boolean;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    inclusiveAncestors(options?: Flags<K, F>): Sequence<Node<K, F>>;
    // (undocumented)
    inclusiveDescendants(options?: Flags<K, F>): Sequence<Node<K, F>>;
    // (undocumented)
    inclusiveSiblings(options?: Flags<K, F>): Sequence<Node<K, F>>;
    // (undocumented)
    index(options?: Flags<K, F>): number;
    // (undocumented)
    get internalId(): string;
    // (undocumented)
    isAncestorOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    // (undocumented)
    isChildOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    // (undocumented)
    isDescendantOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    // (undocumented)
    isInclusiveAncestorOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    // (undocumented)
    isInclusiveDescendantsOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    // (undocumented)
    isInclusiveSiblingOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    // (undocumented)
    isParentOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    // (undocumented)
    isRootOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    // (undocumented)
    isSiblingOf(node: Node<K, F>, options?: Flags<K, F>): boolean;
    // (undocumented)
    last(options?: Flags<K, F>): Option<Node<K, F>>;
    // (undocumented)
    next(options?: Flags<K, F>): Option<Node<K, F>>;
    // (undocumented)
    parent(options?: Flags<K, F>): Option<Node<K, F>>;
    // (undocumented)
    protected _parent: Option<Node<K, F>>;
    // (undocumented)
    preceding(options?: Flags<K, F>): Sequence<Node<K, F>>;
    // (undocumented)
    previous(options?: Flags<K, F>): Option<Node<K, F>>;
    // (undocumented)
    root(options?: Flags<K, F>): Node<K, F>;
    // @deprecated (undocumented)
    get serializationId(): string | undefined;
    // (undocumented)
    siblings(options?: Flags<K, F>): Sequence<Node<K, F>>;
    // (undocumented)
    toJSON(options?: json.Serializable.Options): Node.JSON<T>;
    // (undocumented)
    get type(): T;
    // (undocumented)
    protected readonly _type: T;
}

// @public (undocumented)
export namespace Node {
    // (undocumented)
    export interface JSON<T extends string = string> {
        // (undocumented)
        [key: string]: json.JSON | undefined;
        // (undocumented)
        children?: Array<JSON>;
        // (undocumented)
        externalId?: string;
        // (undocumented)
        internalId?: string;
        // (undocumented)
        serializationId?: string;
        // (undocumented)
        type: T;
    }
}

// (No @packageDocumentation comment for this package)

```
