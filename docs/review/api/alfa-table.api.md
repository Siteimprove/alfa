## API Report File for "@siteimprove/alfa-table"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Comparable } from '@siteimprove/alfa-comparable';
import { Comparison } from '@siteimprove/alfa-comparable';
import { Element } from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import * as json from '@siteimprove/alfa-json';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';

// Warning: (ae-internal-missing-underscore) The name "Anchored" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface Anchored extends Comparable<Anchored> {
    // (undocumented)
    readonly anchor: Slot;
}

// @internal (undocumented)
export namespace Anchored {
    // (undocumented)
    export function compare(a: Anchored, b: Anchored): Comparison;
    // (undocumented)
    export function equals(a: Anchored, b: Anchored): boolean;
}

// Warning: (ae-incompatible-release-tags) The symbol "Cell" is marked as @public, but its signature references "Anchored" which is marked as @internal
//
// @public (undocumented)
export abstract class Cell implements Anchored, Equatable, Serializable<Cell.JSON> {
    protected constructor(element: Element, anchor: Slot, width: number, height: number, headers: Array_2<Slot>);
    // (undocumented)
    get anchor(): Slot;
    // (undocumented)
    protected readonly _anchor: Slot;
    // (undocumented)
    compare(anchored: Anchored): Comparison;
    // (undocumented)
    get element(): Element;
    // (undocumented)
    protected readonly _element: Element;
    // (undocumented)
    equals(cell: Cell): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get headers(): Sequence<Slot>;
    // (undocumented)
    protected readonly _headers: Array_2<Slot>;
    // (undocumented)
    get height(): number;
    // (undocumented)
    protected readonly _height: number;
    // (undocumented)
    abstract isData(): this is Cell.Data;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    abstract isHeader(): this is Cell.Header;
    // (undocumented)
    abstract toJSON(): Cell.JSON;
    // (undocumented)
    get width(): number;
    // (undocumented)
    protected readonly _width: number;
    // (undocumented)
    get x(): number;
    // (undocumented)
    get y(): number;
}

// @public (undocumented)
export namespace Cell {
    // (undocumented)
    export class Data extends Cell {
        // (undocumented)
        equals(cell: Data): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        isData(): boolean;
        // (undocumented)
        isHeader(): boolean;
        // (undocumented)
        static of(element: Element, anchor: Slot, width: number, height: number, headers?: Iterable<Slot>): Data;
        // (undocumented)
        toJSON(): Data.JSON;
    }
    // (undocumented)
    export namespace Data {
        // (undocumented)
        export function isData(value: unknown): value is Data;
        // (undocumented)
        export interface JSON extends Cell.JSON {
            // (undocumented)
            type: "data";
        }
    }
    const // Warning: (ae-forgotten-export) The symbol "predicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasElement: typeof predicate.hasElement;
    // (undocumented)
    export class Header extends Cell {
        // (undocumented)
        equals(cell: Header): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        isData(): boolean;
        // (undocumented)
        isHeader(): boolean;
        // (undocumented)
        static of(element: Element, anchor: Slot, width: number, height: number, headers?: Iterable<Slot>, scope?: Scope): Header;
        // (undocumented)
        get scope(): Scope;
        // (undocumented)
        toJSON(): Header.JSON;
    }
    // (undocumented)
    export namespace Header {
        // (undocumented)
        export function isHeader(value: unknown): value is Header;
        // (undocumented)
        export interface JSON extends Cell.JSON {
            // (undocumented)
            scope: Scope;
            // (undocumented)
            type: "header";
        }
    }
    const // (undocumented)
    data: typeof Data.of, // (undocumented)
    isData: typeof Data.isData;
    // (undocumented)
    export function isCell(value: unknown): value is Cell;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        anchor: Slot.JSON;
        // (undocumented)
        element: string;
        // (undocumented)
        headers: Array_2<Slot.JSON>;
        // (undocumented)
        height: number;
        // (undocumented)
        width: number;
    }
    const // (undocumented)
    header: typeof Header.of, // (undocumented)
    isHeader: typeof Header.isHeader;
}

// Warning: (ae-incompatible-release-tags) The symbol "Column" is marked as @public, but its signature references "Anchored" which is marked as @internal
//
// @public (undocumented)
export class Column implements Anchored, Equatable, Serializable<Column.JSON> {
    // (undocumented)
    get anchor(): Slot;
    // (undocumented)
    compare(anchored: Anchored): Comparison;
    // (undocumented)
    equals(column: Column): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(x: number): Column;
    // (undocumented)
    toJSON(): Column.JSON;
    // (undocumented)
    get x(): number;
}

// @public (undocumented)
export namespace Column {
    // Warning: (ae-incompatible-release-tags) The symbol "Group" is marked as @public, but its signature references "Anchored" which is marked as @internal
    //
    // (undocumented)
    export class Group implements Anchored, Equatable, Serializable<Group.JSON> {
        // (undocumented)
        get anchor(): Slot;
        // (undocumented)
        compare(anchored: Anchored): Comparison;
        // (undocumented)
        get element(): Element;
        // (undocumented)
        equals(group: Group): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(element: Element, x: number, width: number): Group;
        // (undocumented)
        toJSON(): Group.JSON;
        // (undocumented)
        get width(): number;
        // (undocumented)
        get x(): number;
    }
    // (undocumented)
    export namespace Group {
        // (undocumented)
        export function isGroup(value: unknown): value is Group;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            element: string;
            // (undocumented)
            width: number;
            // (undocumented)
            x: number;
        }
    }
    // (undocumented)
    export function isColumn(value: unknown): value is Column;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        x: number;
    }
    const // (undocumented)
    group: typeof Group.of, // (undocumented)
    isGroup: typeof Group.isGroup;
}

// @public (undocumented)
export type Group = Column.Group | Row.Group;

// @public (undocumented)
export namespace Group {
    // (undocumented)
    export type JSON = Column.Group.JSON | Row.Group.JSON;
    const // (undocumented)
    isColumn: typeof Column.Group.isGroup;
    const // (undocumented)
    isRow: typeof Row.Group.isGroup;
    const // (undocumented)
    isGroup: Refinement<unknown, Column.Group | Row.Group, []>;
}

// @public (undocumented)
function hasElement(predicate: Predicate<Element>): Predicate<Cell>;

// @public (undocumented)
function hasElement(element: Element): Predicate<Cell>;

// Warning: (ae-incompatible-release-tags) The symbol "Row" is marked as @public, but its signature references "Anchored" which is marked as @internal
//
// @public (undocumented)
export class Row implements Anchored, Equatable, Serializable<Row.JSON> {
    // (undocumented)
    get anchor(): Slot;
    // (undocumented)
    compare(anchored: Anchored): Comparison;
    // (undocumented)
    equals(row: Row): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(y: number): Row;
    // (undocumented)
    toJSON(): Row.JSON;
    // (undocumented)
    get y(): number;
}

// @public (undocumented)
export namespace Row {
    // Warning: (ae-incompatible-release-tags) The symbol "Group" is marked as @public, but its signature references "Anchored" which is marked as @internal
    //
    // (undocumented)
    export class Group implements Anchored, Equatable, Serializable<Group.JSON> {
        // (undocumented)
        get anchor(): Slot;
        // (undocumented)
        compare(anchored: Anchored): Comparison;
        // (undocumented)
        get element(): Element;
        // (undocumented)
        equals(group: this): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get height(): number;
        // (undocumented)
        static of(element: Element, y: number, height: number): Group;
        // (undocumented)
        toJSON(): Group.JSON;
        // (undocumented)
        get y(): number;
    }
    // (undocumented)
    export namespace Group {
        // (undocumented)
        export function isGroup(value: unknown): value is Group;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            element: string;
            // (undocumented)
            height: number;
            // (undocumented)
            y: number;
        }
    }
    // (undocumented)
    export function isRow(value: unknown): value is Row;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        y: number;
    }
    const // (undocumented)
    group: typeof Group.of, // (undocumented)
    isGroup: typeof Group.isGroup;
}

// @public (undocumented)
export type Scope = "row" | "row-group" | "column" | "column-group" | "auto";

// @public (undocumented)
export namespace Scope {
    // (undocumented)
    export function from(element: Element): Scope;
}

// @public (undocumented)
export class Slot implements Comparable<Slot>, Equatable, Serializable<Slot.JSON> {
    // (undocumented)
    compare(slot: Slot): Comparison;
    // (undocumented)
    equals(slot: Slot): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(x: number, y: number): Slot;
    // (undocumented)
    toJSON(): Slot.JSON;
    // (undocumented)
    get x(): number;
    // (undocumented)
    get y(): number;
}

// @public (undocumented)
export namespace Slot {
    // (undocumented)
    export function isSlot(value: unknown): value is Slot;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        x: number;
        // (undocumented)
        y: number;
    }
}

// @public (undocumented)
export class Table implements Equatable, Serializable<Table.JSON> {
    // (undocumented)
    get cells(): Sequence<Cell>;
    // (undocumented)
    get element(): Element;
    // (undocumented)
    static empty(element: Element): Table;
    // (undocumented)
    equals(table: Table): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get groups(): Sequence<Group>;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    static of(element: Element, cells: Iterable<Cell>, groups: Iterable<Group>): Table;
    // (undocumented)
    toJSON(): Table.JSON;
}

// @public (undocumented)
export namespace Table {
    // (undocumented)
    export function from(element: Element): Table;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        cells: Array_2<Cell.JSON>;
        // (undocumented)
        element: string;
        // (undocumented)
        groups: Array_2<Group.JSON>;
    }
}

// (No @packageDocumentation comment for this package)

```
