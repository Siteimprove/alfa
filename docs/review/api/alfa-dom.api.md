## API Report File for "@siteimprove/alfa-dom"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Device } from '@siteimprove/alfa-device';
import * as earl from '@siteimprove/alfa-earl';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Feature } from '@siteimprove/alfa-css-feature';
import { Flags } from '@siteimprove/alfa-flags';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Map as Map_2 } from '@siteimprove/alfa-map';
import { Option as Option_2 } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Rectangle } from '@siteimprove/alfa-rectangle';
import { Refinement } from '@siteimprove/alfa-refinement';
import * as sarif from '@siteimprove/alfa-sarif';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';
import { Trampoline } from '@siteimprove/alfa-trampoline';
import * as tree from '@siteimprove/alfa-tree';

// @public (undocumented)
export class Attribute<N extends string = string> extends Node_2<"attribute"> {
    // @internal (undocumented)
    _attachOwner(owner: Element_2): boolean;
    // @internal (undocumented)
    _attachParent(): boolean;
    // (undocumented)
    enumerate(): Option_2<string>;
    // (undocumented)
    enumerate<T extends string>(valid: T, ...rest: Array<T>): Option_2<T>;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    isBoolean(): boolean;
    // (undocumented)
    get name(): N | Lowercase<N>;
    // (undocumented)
    get namespace(): Option_2<Namespace>;
    // (undocumented)
    static of<N extends string = string>(namespace: Option_2<Namespace>, prefix: Option_2<string>, name: N, value: string, externalId?: string, serializationId?: string, extraData?: any): Attribute<N>;
    // (undocumented)
    get owner(): Option_2<Element_2>;
    // (undocumented)
    get prefix(): Option_2<string>;
    // (undocumented)
    get qualifiedName(): string;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal;
    }): Attribute.MinimalJSON;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Low;
    }): Attribute.MinimalJSON;
    // (undocumented)
    toJSON(options?: Node_2.SerializationOptions): Attribute.JSON<N>;
    // (undocumented)
    tokens(separator?: string | RegExp): Sequence<string>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
export namespace Attribute {
    // @internal (undocumented)
    export function cloneAttribute<N extends string = string>(attribute: Attribute<N>): Trampoline<Attribute<N | Lowercase<N>>>;
    // @internal
    export function foldCase<N extends string = string>(name: N, owner: Option_2<Element_2>): N | Lowercase<N>;
    // @internal (undocumented)
    export function fromAttribute<N extends string = string>(attribute: JSON<N>): Trampoline<Attribute<N>>;
    // (undocumented)
    export function isAttribute(value: unknown): value is Attribute;
    // (undocumented)
    export interface JSON<N extends string = string> extends Node_2.JSON<"attribute"> {
        // (undocumented)
        name: N;
        // (undocumented)
        namespace: string | null;
        // (undocumented)
        prefix: string | null;
        // (undocumented)
        value: string;
    }
    // (undocumented)
    export interface MinimalJSON extends Node_2.JSON<"attribute"> {
    }
    const // Warning: (ae-forgotten-export) The symbol "predicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasName: typeof predicate.hasName;
}

// @public (undocumented)
export class Block implements Iterable_2<Declaration>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Declaration>;
    // (undocumented)
    declaration(predicate: string | Predicate<Declaration>): Option_2<Declaration>;
    // (undocumented)
    get declarations(): Iterable_2<Declaration>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    static of(declarations: Iterable_2<Declaration>): Block;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toJSON(): Block.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Block {
    // (undocumented)
    export function from(jsonOrText: JSON | string): Block;
    // (undocumented)
    export type JSON = Array<Declaration.JSON>;
}

// @public (undocumented)
class Comment_2 extends Node_2<"comment"> {
    // (undocumented)
    get data(): string;
    // (undocumented)
    static empty(): Comment_2;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    static of(data: string, externalId?: string, serializationId?: string, extraData?: any): Comment_2;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal;
    }): Comment_2.MinimalJSON;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Low;
    }): Comment_2.MinimalJSON;
    // (undocumented)
    toJSON(options?: Node_2.SerializationOptions): Comment_2.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Comment_2 {
    // @internal (undocumented)
    function cloneComment(comment: Comment_2): Trampoline<Comment_2>;
    // @internal (undocumented)
    function fromComment(json: JSON): Trampoline<Comment_2>;
    // (undocumented)
    function isComment(value: unknown): value is Comment_2;
    // (undocumented)
    interface JSON extends Node_2.JSON<"comment"> {
        // (undocumented)
        data: string;
    }
    // (undocumented)
    interface MinimalJSON extends Node_2.JSON<"comment"> {
    }
}
export { Comment_2 as Comment }

// @public (undocumented)
export abstract class ConditionRule<T extends string = string> extends GroupingRule<T> {
    protected constructor(type: T, condition: string, rules: Array<Rule>);
    // (undocumented)
    get condition(): string;
    // (undocumented)
    protected readonly _condition: string;
    // (undocumented)
    toJSON(): ConditionRule.JSON<T>;
}

// @public (undocumented)
export namespace ConditionRule {
    // (undocumented)
    export function isConditionRule(value: unknown): value is ConditionRule;
    // (undocumented)
    export interface JSON<T extends string = string> extends GroupingRule.JSON<T> {
        // (undocumented)
        condition: string;
    }
}

// @public (undocumented)
export class Declaration implements Equatable, Serializable {
    // (undocumented)
    ancestors(): Iterable<Rule>;
    // @internal (undocumented)
    _attachOwner(owner: Element_2): boolean;
    // @internal (undocumented)
    _attachParent(parent: Rule): boolean;
    equals(value: unknown): value is this;
    // (undocumented)
    get important(): boolean;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(name: string, value: string, important?: boolean): Declaration;
    // (undocumented)
    get owner(): Option_2<Element_2>;
    // (undocumented)
    get parent(): Option_2<Rule>;
    // (undocumented)
    toJSON(): Declaration.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
export namespace Declaration {
    // (undocumented)
    export function from(json: JSON): Declaration;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        important: boolean;
        // (undocumented)
        name: string;
        // (undocumented)
        value: string;
    }
}

// @public (undocumented)
class Document_2 extends Node_2<"document"> {
    // @internal (undocumented)
    _attachFrame(frame: Element_2): boolean;
    // @internal (undocumented)
    _attachParent(): boolean;
    // (undocumented)
    static empty(): Document_2;
    // (undocumented)
    get frame(): Option_2<Element_2>;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    static of(children: Iterable_2<Node_2>, style?: Iterable_2<Sheet>, externalId?: string, serializationId?: string, extraData?: any): Document_2;
    // (undocumented)
    parent(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    get style(): Iterable_2<Sheet>;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal;
    }): Document_2.MinimalJSON;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Low;
    }): Document_2.MinimalJSON;
    // (undocumented)
    toJSON(options?: Node_2.SerializationOptions): Document_2.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Document_2 {
    // @internal (undocumented)
    function cloneDocument(options: Node_2.ElementReplacementOptions, device?: Device): (document: Document_2) => Trampoline<Document_2>;
    // @internal (undocumented)
    function fromDocument(json: JSON, device?: Device): Trampoline<Document_2>;
    // (undocumented)
    function isDocument(value: unknown): value is Document_2;
    // (undocumented)
    interface JSON extends Node_2.JSON<"document"> {
        // (undocumented)
        style: Array_2<Sheet.JSON>;
    }
    // (undocumented)
    interface MinimalJSON extends Node_2.JSON<"document"> {
    }
}
export { Document_2 as Document }

// @public (undocumented)
class Element_2<N extends string = string> extends Node_2<"element"> implements Slot, Slotable {
    // (undocumented)
    assignedNodes(): Iterable_2<Slotable>;
    // (undocumented)
    assignedSlot(): Option_2<Slot>;
    // @internal (undocumented)
    _attachContent(document: Document_2): boolean;
    // @internal (undocumented)
    _attachShadow(shadow: Shadow): boolean;
    // (undocumented)
    attribute<A extends string = string>(name: A): Option_2<Attribute<A>>;
    // (undocumented)
    attribute<A extends string = string>(predicate: Predicate<Attribute<A>>): Option_2<Attribute<A>>;
    // (undocumented)
    get attributes(): Sequence<Attribute>;
    // (undocumented)
    children(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    get classes(): Sequence<string>;
    // (undocumented)
    get content(): Option_2<Document_2>;
    // (undocumented)
    getBoundingBox(device: Device): Option_2<Rectangle>;
    // (undocumented)
    get id(): Option_2<string>;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    isVoid(): boolean;
    // (undocumented)
    get name(): N;
    // (undocumented)
    get namespace(): Option_2<Namespace>;
    // (undocumented)
    static of<N extends string = string>(namespace: Option_2<Namespace>, prefix: Option_2<string>, name: N, attributes?: Iterable_2<Attribute>, children?: Iterable_2<Node_2>, style?: Option_2<Block>, box?: Option_2<Rectangle>, device?: Option_2<Device>, externalId?: string, serializationId?: string, extraData?: any): Element_2<N>;
    // (undocumented)
    get prefix(): Option_2<string>;
    // (undocumented)
    get qualifiedName(): string;
    // (undocumented)
    get shadow(): Option_2<Shadow>;
    // (undocumented)
    get style(): Option_2<Block>;
    // (undocumented)
    tabIndex(): Option_2<number>;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal;
    }): Element_2.MinimalJSON;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Low;
    }): Element_2.MinimalJSON;
    // (undocumented)
    toJSON(options?: Node_2.SerializationOptions): Element_2.JSON<N>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Element_2 {
    // @internal (undocumented)
    function cloneElement(options: Node_2.ElementReplacementOptions, device?: Device): (element: Element_2) => Trampoline<Element_2>;
    // @internal (undocumented)
    function fromElement<N extends string = string>(json: JSON<N>, device?: Device): Trampoline<Element_2<N>>;
    // (undocumented)
    function isElement(value: unknown): value is Element_2;
    // (undocumented)
    interface JSON<N extends string = string> extends Node_2.JSON<"element"> {
        // (undocumented)
        attributes: Array<Attribute.JSON>;
        // (undocumented)
        box: Rectangle.JSON | null;
        // (undocumented)
        content: Document_2.JSON | null;
        // (undocumented)
        name: N;
        // (undocumented)
        namespace: string | null;
        // (undocumented)
        prefix: string | null;
        // (undocumented)
        shadow: Shadow.JSON | null;
        // (undocumented)
        style: Block.JSON | string | null;
    }
    // (undocumented)
    interface MinimalJSON extends Node_2.JSON<"element"> {
    }
    const // Warning: (ae-forgotten-export) The symbol "predicate_3" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasAttribute: typeof predicate_3.hasAttribute, // (undocumented)
    hasBox: typeof predicate_3.hasBox, // (undocumented)
    hasDisplaySize: typeof predicate_3.hasDisplaySize, // (undocumented)
    hasId: typeof predicate_3.hasId, // (undocumented)
    hasInputType: typeof predicate_3.hasInputType, // (undocumented)
    hasName: typeof predicate_3.hasName, // (undocumented)
    hasNamespace: typeof predicate_3.hasNamespace, // (undocumented)
    hasTabIndex: typeof predicate_3.hasTabIndex, // (undocumented)
    hasUniqueId: Predicate<Element_2<string>>, // (undocumented)
    isBrowsingContextContainer: typeof predicate_3.isBrowsingContextContainer, // (undocumented)
    isContent: typeof predicate_3.isContent, // (undocumented)
    isActuallyDisabled: typeof predicate_3.isActuallyDisabled, // (undocumented)
    isDocumentElement: typeof predicate_3.isDocumentElement, // (undocumented)
    isDraggable: typeof predicate_3.isDraggable, // (undocumented)
    isEditingHost: typeof predicate_3.isEditingHost, // (undocumented)
    isFallback: typeof predicate_3.isFallback, // (undocumented)
    isScopedTo: typeof predicate_3.isScopedTo, // (undocumented)
    isSuggestedFocusable: typeof predicate_3.isSuggestedFocusable, // (undocumented)
    isReplaced: typeof predicate_3.isReplaced;
    const // Warning: (ae-forgotten-export) The symbol "helpers" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    inputType: typeof helpers.inputType;
}
export { Element_2 as Element }

// @public (undocumented)
export class FontFaceRule extends Rule<"font-face"> {
    // (undocumented)
    static of(declarations: Iterable<Declaration>): FontFaceRule;
    // (undocumented)
    get style(): Block;
    // (undocumented)
    toJSON(): FontFaceRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace FontFaceRule {
    // @internal (undocumented)
    export function fromFontFaceRule(json: JSON): Trampoline<FontFaceRule>;
    // (undocumented)
    export function isFontFaceRule(value: unknown): value is FontFaceRule;
    // (undocumented)
    export interface JSON extends Rule.JSON<"font-face"> {
        // (undocumented)
        style: Block.JSON | string;
    }
}

// @public (undocumented)
export class Fragment extends Node_2<"fragment"> {
    // @internal (undocumented)
    _attachParent(): boolean;
    // (undocumented)
    static empty(): Fragment;
    // @internal (undocumented)
    protected _internalPath(): string;
    // (undocumented)
    static of(children: Iterable_2<Node_2>, externalId?: string, serializationId?: string, extraData?: any): Fragment;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Fragment {
    // @internal (undocumented)
    export function cloneFragment(options: Node_2.ElementReplacementOptions, device?: Device): (fragment: Fragment) => Trampoline<Fragment>;
    // @internal (undocumented)
    export function fromFragment(json: JSON, device?: Device): Trampoline<Fragment>;
    // (undocumented)
    export function isFragment(value: unknown): value is Fragment;
    // (undocumented)
    export interface JSON extends Node_2.JSON<"fragment"> {
    }
}

// @public (undocumented)
export abstract class GroupingRule<T extends string = string> extends Rule<T> {
    protected constructor(type: T, rules: Array_2<Rule>);
    // (undocumented)
    children(): Iterable<Rule>;
    // (undocumented)
    get rules(): Iterable<Rule>;
    // (undocumented)
    protected readonly _rules: Array_2<Rule>;
    // (undocumented)
    toJSON(): GroupingRule.JSON<T>;
}

// @public (undocumented)
export namespace GroupingRule {
    // (undocumented)
    export function isGroupingRule(value: unknown): value is GroupingRule;
    // (undocumented)
    export interface JSON<T extends string = string> extends Rule.JSON<T> {
        // (undocumented)
        rules: Array_2<Rule.JSON>;
    }
}

// @public (undocumented)
export function h<N extends string = string>(name: N, attributes?: Array<Attribute> | Record<string, string | boolean>, children?: Array<Node_2 | string>, style?: Array<Declaration> | Record<string, string>, box?: Rectangle, device?: Device, externalId?: string, serializationId?: string, extraData?: any): Element_2<N>;

// @public (undocumented)
export namespace h {
    // (undocumented)
    export function attribute<N extends string = string>(name: N, value: string, externalId?: string, serializationId?: string, extraData?: any): Attribute<N>;
    // (undocumented)
    export function block(declarations: Array<Declaration> | Record<string, string>): Block;
    // (undocumented)
    export function declaration(name: string, value: string, important?: boolean): Declaration;
    // (undocumented)
    export function document(children: Array<Node_2 | string>, style?: Array<Sheet>, externalId?: string, serializationId?: string, extraData?: any): Document_2;
    // (undocumented)
    export function element<N extends string = string>(name: N, attributes?: Array<Attribute> | Record<string, string | boolean>, children?: Array<Node_2 | string>, style?: Array<Declaration> | Record<string, string>, namespace?: Namespace, box?: Rectangle, device?: Device, externalId?: string, serializationId?: string, extraData?: any): Element_2<N>;
    // (undocumented)
    export function fragment(children: Array<Node_2 | string>, externalId?: string, extraData?: any): Fragment;
    // (undocumented)
    export namespace rule {
        // (undocumented)
        export function fontFace(declarations: Array<Declaration> | Record<string, string>): FontFaceRule;
        // (undocumented)
        export function importRule(url: string, sheet: Sheet, mediaCondition?: string, supportCondition?: string, layer?: string): ImportRule;
        // (undocumented)
        export function keyframe(key: string, declarations: Array<Declaration> | Record<string, string>): KeyframeRule;
        // (undocumented)
        export function keyframes(name: string, rules: Array<Rule>): KeyframesRule;
        // (undocumented)
        export function layerBlock(rules: Array<Rule>, layer?: string): Layer.BlockRule;
        // (undocumented)
        export function layerStatement(layers: Array<string>): Layer.StatementRule;
        // (undocumented)
        export function media(condition: string, rules: Array<Rule>): MediaRule;
        // (undocumented)
        export function namespace(namespace: string, prefix?: string): NamespaceRule;
        // (undocumented)
        export function page(selector: string, declarations: Array<Declaration> | Record<string, string>): PageRule;
        // (undocumented)
        export function style(selector: string, declarations: Array<Declaration> | Record<string, string>, hint?: boolean): StyleRule;
        // (undocumented)
        export function supports(condition: string, rules: Array<Rule>): SupportsRule;
    }
    // (undocumented)
    export function shadow(children: Array<Node_2 | string>, style?: Array<Sheet>, mode?: Shadow.Mode, externalId?: string, serializationId?: string, extraData?: any): Shadow;
    // (undocumented)
    export function sheet(rules: Array<Rule>, disabled?: boolean, condition?: string): Sheet;
    // (undocumented)
    export function text(data: string, externalId?: string, serializationId?: string, extraData?: any): Text_2;
    // (undocumented)
    export function type<N extends string = string>(name: N, publicId?: string, systemId?: string, externalId?: string, serializationId?: string, extraData?: any): Type<N>;
}

// @public (undocumented)
export class ImportRule extends ConditionRule<"import"> {
    // (undocumented)
    get href(): string;
    // (undocumented)
    get layer(): Option_2<string>;
    // (undocumented)
    get mediaQueries(): Feature.Media.List;
    // (undocumented)
    static of(href: string, sheet: Sheet, mediaCondition?: Option_2<string>, supportCondition?: Option_2<string>, layer?: Option_2<string>): ImportRule;
    // (undocumented)
    get rules(): Iterable<Rule>;
    // (undocumented)
    get sheet(): Sheet;
    // (undocumented)
    get supportCondition(): Option_2<string>;
    // (undocumented)
    get supportQuery(): Option_2<Option_2<Feature.Supports.Query>>;
    // (undocumented)
    toJSON(): ImportRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace ImportRule {
    // @internal (undocumented)
    export function fromImportRule(json: JSON): Trampoline<ImportRule>;
    // (undocumented)
    export function isImportRule(value: unknown): value is ImportRule;
    // (undocumented)
    export interface JSON extends ConditionRule.JSON<"import"> {
        // (undocumented)
        href: string;
        // (undocumented)
        layer: string | null;
        // (undocumented)
        supportText: string | null;
    }
    // (undocumented)
    export function matches(device: Device): Predicate<ImportRule>;
}

// @public (undocumented)
export function jsx<N extends string = string>(name: N, properties?: jsx.Properties | null, ...children: jsx.Children): Element_2<N>;

// @public (undocumented)
export namespace jsx {
    // (undocumented)
    export type Child = Node_2 | string;
    // (undocumented)
    export type Children = (Child | Children)[];
    // (undocumented)
    export namespace JSX {
        // Warning: (ae-forgotten-export) The symbol "dom" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        export type Element<N extends string = string> = dom.Element<N>;
        // (undocumented)
        export interface IntrinsicElements {
            // (undocumented)
            [tag: string]: Properties;
        }
    }
    // (undocumented)
    export interface Properties {
        // (undocumented)
        [name: string]: unknown;
        style?: Record<string, string>;
    }
}

// @public (undocumented)
export class KeyframeRule extends Rule<"keyframe"> {
    // (undocumented)
    get key(): string;
    // (undocumented)
    static of(key: string, declarations: Iterable<Declaration>): KeyframeRule;
    // (undocumented)
    get style(): Block;
    // (undocumented)
    toJSON(): KeyframeRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace KeyframeRule {
    // @internal (undocumented)
    export function fromKeyframeRule(json: JSON): Trampoline<KeyframeRule>;
    // (undocumented)
    export function isKeyframeRule(value: unknown): value is KeyframeRule;
    // (undocumented)
    export interface JSON extends Rule.JSON<"keyframe"> {
        // (undocumented)
        key: string;
        // (undocumented)
        style: Block.JSON | string;
    }
}

// @public (undocumented)
export class KeyframesRule extends GroupingRule<"keyframes"> {
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(name: string, rules: Iterable<Rule>): KeyframesRule;
    // (undocumented)
    toJSON(): KeyframesRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace KeyframesRule {
    // @internal (undocumented)
    export function fromKeyframesRule(json: JSON): Trampoline<KeyframesRule>;
    // (undocumented)
    export function isKeyframesRule(value: unknown): value is KeyframesRule;
    // (undocumented)
    export interface JSON extends GroupingRule.JSON<"keyframes"> {
        // (undocumented)
        name: string;
    }
}

// @public
export namespace Layer {
    // (undocumented)
    export class BlockRule extends GroupingRule<"layer-block"> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get layer(): Option_2<string>;
        // (undocumented)
        static of(rules: Iterable<Rule>, layer?: string | null): BlockRule;
        // (undocumented)
        toJSON(): BlockRule.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace BlockRule {
        // (undocumented)
        export function fromLayerBlockRule(json: JSON): Trampoline<BlockRule>;
        // (undocumented)
        export function isLayerBlockRule(value: unknown): value is BlockRule;
        // (undocumented)
        export interface JSON extends GroupingRule.JSON<"layer-block"> {
            // (undocumented)
            layer: string | null;
        }
    }
    // (undocumented)
    export class StatementRule extends Rule<"layer-statement"> {
        // (undocumented)
        get layers(): Iterable<string>;
        // (undocumented)
        static of(layers: Iterable<string>): StatementRule;
        // (undocumented)
        toJSON(): StatementRule.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace StatementRule {
        // (undocumented)
        export function fromLayerStatementRule(json: JSON): Trampoline<StatementRule>;
        // (undocumented)
        export function isLayerStatementRule(value: unknown): value is StatementRule;
        // (undocumented)
        export interface JSON extends Rule.JSON<"layer-statement"> {
            // (undocumented)
            layers: Array_2<string>;
        }
    }
}

// @public (undocumented)
export class MediaRule extends ConditionRule<"media"> {
    // (undocumented)
    static of(condition: string, rules: Iterable_2<Rule>): MediaRule;
    // (undocumented)
    get queries(): Feature.Media.List;
    // (undocumented)
    toJSON(): MediaRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace MediaRule {
    // @internal (undocumented)
    export function fromMediaRule(json: JSON): Trampoline<MediaRule>;
    // (undocumented)
    export function isMediaRule(value: unknown): value is MediaRule;
    // (undocumented)
    export interface JSON extends ConditionRule.JSON<"media"> {
    }
    // (undocumented)
    export function matches(device: Device): Predicate<MediaRule>;
}

// @public (undocumented)
export enum Namespace {
    // (undocumented)
    HTML = "http://www.w3.org/1999/xhtml",
    // (undocumented)
    MathML = "http://www.w3.org/1998/Math/MathML",
    // (undocumented)
    SVG = "http://www.w3.org/2000/svg",
    // (undocumented)
    XLink = "http://www.w3.org/1999/xlink",
    // (undocumented)
    XML = "http://www.w3.org/XML/1998/namespace",
    // (undocumented)
    XMLNS = "http://www.w3.org/2000/xmlns/"
}

// @public (undocumented)
export namespace Namespace {
    // (undocumented)
    export function isNamespace(value: string): value is Namespace;
}

// @public (undocumented)
export class NamespaceRule extends Rule<"namespace"> {
    // (undocumented)
    get namespace(): string;
    // (undocumented)
    static of(namespace: string, prefix: Option_2<string>): NamespaceRule;
    // (undocumented)
    get prefix(): Option_2<string>;
    // (undocumented)
    toJSON(): NamespaceRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace NamespaceRule {
    // @internal (undocumented)
    export function fromNamespaceRule(json: JSON): Trampoline<NamespaceRule>;
    // (undocumented)
    export function isNamespaceRule(value: unknown): value is NamespaceRule;
    // (undocumented)
    export interface JSON extends Rule.JSON<"namespace"> {
        // (undocumented)
        namespace: string;
        // (undocumented)
        prefix: string | null;
    }
}

// @public (undocumented)
abstract class Node_2<T extends string = string> extends tree.Node<Node_2.Traversal.Flag, T> implements earl.Serializable<Node_2.EARL>, json.Serializable<tree.Node.JSON<T>, Node_2.SerializationOptions>, sarif.Serializable<sarif.Location> {
    protected constructor(children: Array<Node_2>, type: T, externalId?: string, serializationId?: string, extraData?: any);
    // (undocumented)
    equals(value: Node_2): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    path(options?: Node_2.Traversal): string;
    tabOrder(): Sequence<Element_2>;
    // (undocumented)
    textContent(options?: Node_2.Traversal): string;
    // (undocumented)
    toEARL(): Node_2.EARL;
    // (undocumented)
    toSARIF(): sarif.Location;
}

// @public (undocumented)
interface Node_2 {
    // (undocumented)
    ancestors(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    children(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    closest<T extends Node_2>(refinement: Refinement<Node_2, T>, options?: Node_2.Traversal): Option_2<T>;
    // (undocumented)
    closest(predicate: Predicate<Node_2>, options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    descendants(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    first(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    following(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    inclusiveAncestors(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    inclusiveDescendants(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    inclusiveSiblings(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    index(options?: Node_2.Traversal): number;
    // (undocumented)
    isAncestorOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isChildOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isDescendantOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isInclusiveAncestorOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isInclusiveDescendantsOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isInclusiveSiblingOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isParentOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isRootOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isSiblingOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    last(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    next(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    parent(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    preceding(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    previous(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    root(options?: Node_2.Traversal): Node_2;
    // (undocumented)
    siblings(options?: Node_2.Traversal): Sequence<Node_2>;
}

// @public (undocumented)
namespace Node_2 {
    function clone(node: Element_2, options?: ElementReplacementOptions, device?: Device): Element_2;
    function clone(node: Attribute, options?: ElementReplacementOptions, device?: Device): Attribute;
    function clone(node: Text_2, options?: ElementReplacementOptions, device?: Device): Text_2;
    function clone(node: Comment_2, options?: ElementReplacementOptions, device?: Device): Comment_2;
    function clone(node: Document_2, options?: ElementReplacementOptions, device?: Device): Document_2;
    function clone(node: Type, options?: ElementReplacementOptions, device?: Device): Document_2;
    const flatTree: Traversal;
    const fullTree: Traversal;
    const composedNested: Traversal;
    function clone(node: Fragment, options?: ElementReplacementOptions, device?: Device): Fragment;
    function clone(node: Shadow, options?: ElementReplacementOptions, device?: Device): Shadow;
    function clone(node: Node_2, options?: ElementReplacementOptions, device?: Device): Node_2;
    // @internal (undocumented)
    function cloneNode(node: Node_2, options?: ElementReplacementOptions, device?: Device): Trampoline<Node_2>;
    // (undocumented)
    interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            ptr: "http://www.w3.org/2009/pointers#";
        };
        // (undocumented)
        "@type": [
        "ptr:Pointer",
        "ptr:SinglePointer",
        "ptr:ExpressionPointer",
        "ptr:XPathPointer"
        ];
        // (undocumented)
        "ptr:expression": string;
        // (undocumented)
        "ptr:reference"?: {
            "@id": string;
        };
    }
    // (undocumented)
    interface ElementReplacementOptions {
        // (undocumented)
        newElements: Iterable<Element_2>;
        // (undocumented)
        predicate: Predicate<Element_2>;
    }
    // (undocumented)
    function from(json: Element_2.JSON, device?: Device): Element_2;
    // (undocumented)
    function from(json: Attribute.JSON, device?: Device): Attribute;
    // (undocumented)
    function from(json: Text_2.JSON, device?: Device): Text_2;
    // (undocumented)
    function from(json: Comment_2.JSON, device?: Device): Comment_2;
    // (undocumented)
    function from(json: Document_2.JSON, device?: Device): Document_2;
    // (undocumented)
    function from(json: Type.JSON, device?: Device): Document_2;
    // (undocumented)
    function from(json: Fragment.JSON, device?: Device): Fragment;
    // (undocumented)
    function from(json: JSON, device?: Device): Node_2;
    // @internal (undocumented)
    function fromNode(json: JSON, device?: Device): Trampoline<Node_2>;
    // (undocumented)
    function isNode(value: unknown): value is Node_2;
    // (undocumented)
    interface JSON<T extends string = string> extends tree.Node.JSON<T> {
    }
    // (undocumented)
    interface SerializationOptions extends json.Serializable.Options {
        // (undocumented)
        device: Device;
    }
    // (undocumented)
    class Traversal extends Flags<Traversal.Flag> {
        // (undocumented)
        static of(...flags: Array<Traversal.Flag>): Traversal;
    }
    // (undocumented)
    namespace Traversal {
        // (undocumented)
        type Flag = 0 | 1 | 2 | 4;
        const // (undocumented)
        none: Flag;
        const composed: Flag;
        const flattened: Flag;
        const nested: Flag;
        const // (undocumented)
        empty: Traversal;
    }
    const // Warning: (ae-forgotten-export) The symbol "traversal" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getNodesBetween: typeof traversal.getNodesBetween;
    const // Warning: (ae-forgotten-export) The symbol "predicate_2" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasChild: typeof predicate_2.hasChild, // (undocumented)
    hasDescendant: typeof predicate_2.hasDescendant, // (undocumented)
    hasInclusiveDescendant: typeof predicate_2.hasInclusiveDescendant, // (undocumented)
    hasTextContent: typeof predicate_2.hasTextContent, // (undocumented)
    isRoot: typeof predicate_2.isRoot;
}
export { Node_2 as Node }

// @public (undocumented)
export class PageRule extends Rule<"page"> {
    // (undocumented)
    static of(selector: string, declarations: Iterable<Declaration>): PageRule;
    // (undocumented)
    get selector(): string;
    // (undocumented)
    get style(): Block;
    // (undocumented)
    toJSON(): PageRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace PageRule {
    // @internal (undocumented)
    export function fromPageRule(json: JSON): Trampoline<PageRule>;
    // (undocumented)
    export function isPageRule(value: unknown): value is PageRule;
    // (undocumented)
    export interface JSON extends Rule.JSON<"page"> {
        // (undocumented)
        selector: string;
        // (undocumented)
        style: Block.JSON | string;
    }
}

// @public (undocumented)
export namespace Query {
    const // Warning: (ae-forgotten-export) The symbol "elementDescendants" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getElementDescendants: typeof elementDescendants.getElementDescendants;
    const // Warning: (ae-forgotten-export) The symbol "elementIdMap" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getElementIdMap: typeof elementIdMap.getElementIdMap;
}

// @public (undocumented)
export abstract class Rule<T extends string = string> implements Equatable, Serializable {
    protected constructor(type: T);
    // (undocumented)
    ancestors(): Iterable_2<Rule>;
    // @internal (undocumented)
    _attachOwner(owner: Sheet): boolean;
    // @internal (undocumented)
    _attachParent(parent: Rule): boolean;
    // (undocumented)
    children(): Iterable_2<Rule>;
    // (undocumented)
    descendants(): Iterable_2<Rule>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    inclusiveAncestors(): Iterable_2<Rule>;
    // (undocumented)
    get owner(): Option_2<Sheet>;
    // (undocumented)
    protected _owner: Option_2<Sheet>;
    // (undocumented)
    get parent(): Option_2<Rule>;
    // (undocumented)
    protected _parent: Option_2<Rule>;
    // (undocumented)
    toJSON(): Rule.JSON<T>;
    // (undocumented)
    get type(): T;
}

// @public (undocumented)
export namespace Rule {
    // (undocumented)
    export function from(json: FontFaceRule.JSON): FontFaceRule;
    // (undocumented)
    export function from(json: ImportRule.JSON): ImportRule;
    // (undocumented)
    export function from(json: KeyframeRule.JSON): KeyframeRule;
    // (undocumented)
    export function from(json: KeyframesRule.JSON): KeyframesRule;
    // (undocumented)
    export function from(json: Layer.BlockRule.JSON): Layer.BlockRule;
    // (undocumented)
    export function from(json: Layer.StatementRule.JSON): Layer.StatementRule;
    // (undocumented)
    export function from(json: MediaRule.JSON): MediaRule;
    // (undocumented)
    export function from(json: NamespaceRule.JSON): NamespaceRule;
    // (undocumented)
    export function from(json: PageRule.JSON): PageRule;
    // (undocumented)
    export function from(json: StyleRule.JSON): StyleRule;
    // (undocumented)
    export function from(json: SupportsRule.JSON): SupportsRule;
    // (undocumented)
    export function from(json: JSON): Rule;
    // @internal (undocumented)
    export function fromRule(json: JSON): Trampoline<Rule>;
    // (undocumented)
    export interface JSON<T extends string = string> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: T;
    }
}

// @public (undocumented)
export class Shadow extends Node_2<"shadow"> {
    // @internal (undocumented)
    _attachHost(host: Element_2): boolean;
    // @internal (undocumented)
    _attachParent(): boolean;
    // (undocumented)
    static empty(): Shadow;
    // (undocumented)
    get host(): Option_2<Element_2>;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    get mode(): Shadow.Mode;
    // (undocumented)
    static of(children: Iterable_2<Node_2>, style?: Iterable_2<Sheet>, mode?: Shadow.Mode, externalId?: string, serializationId?: string, extraData?: any): Shadow;
    // (undocumented)
    parent(options?: Node_2.Traversal): Option_2<Node_2>;
    // (undocumented)
    get style(): Iterable_2<Sheet>;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal;
    }): Shadow.MinimalJSON;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Low;
    }): Shadow.MinimalJSON;
    // (undocumented)
    toJSON(options?: Node_2.SerializationOptions): Shadow.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Shadow {
    // @internal (undocumented)
    export function cloneShadow(options: Node_2.ElementReplacementOptions, device?: Device): (shadow: Shadow) => Trampoline<Shadow>;
    // @internal (undocumented)
    export function fromShadow(json: JSON, device?: Device): Trampoline<Shadow>;
    // (undocumented)
    export function isShadow(value: unknown): value is Shadow;
    // (undocumented)
    export interface JSON extends Node_2.JSON {
        // (undocumented)
        mode: string;
        // (undocumented)
        style: Array<Sheet.JSON>;
        // (undocumented)
        type: "shadow";
    }
    // (undocumented)
    export interface MinimalJSON extends Node_2.JSON {
    }
    // (undocumented)
    export enum Mode {
        // (undocumented)
        Closed = "closed",
        // (undocumented)
        Open = "open"
    }
}

// @public (undocumented)
export class Sheet implements Equatable, Serializable {
    // (undocumented)
    children(): Iterable<Rule>;
    // (undocumented)
    get condition(): Option_2<string>;
    // (undocumented)
    descendants(): Iterable<Rule>;
    // (undocumented)
    get disabled(): boolean;
    // (undocumented)
    static empty(): Sheet;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(rules: Iterable<Rule>, disabled?: boolean, condition?: Option_2<string>): Sheet;
    // (undocumented)
    get rules(): Iterable<Rule>;
    // (undocumented)
    toJSON(): Sheet.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Sheet {
    // (undocumented)
    export function from(json: JSON): Sheet;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        condition: string | null;
        // (undocumented)
        disabled: boolean;
        // (undocumented)
        rules: Array<Rule.JSON>;
    }
}

// @public (undocumented)
export interface Slot extends Element_2 {
    assignedNodes(): Iterable<Slotable>;
}

// @public (undocumented)
export namespace Slot {
    // (undocumented)
    export function findSlotables(slot: Slot): Iterable<Slotable>;
    // (undocumented)
    export function isSlot(element: Element_2): boolean;
    // (undocumented)
    export function isSlot(value: unknown): value is Slot;
    // (undocumented)
    export function name(slot: Slot): string;
}

// @public (undocumented)
export interface Slotable extends Node_2 {
    assignedSlot(): Option_2<Slot>;
}

// @public (undocumented)
export namespace Slotable {
    // (undocumented)
    export function findSlot(slotable: Slotable): Option_2<Slot>;
    // (undocumented)
    export function isSlotable(value: unknown): value is Slotable;
    // (undocumented)
    export function name(slotable: Slotable): string;
}

// @public (undocumented)
export class StyleRule extends Rule<"style"> {
    // (undocumented)
    get hint(): boolean;
    // (undocumented)
    static of(selector: string, declarations: Iterable<Declaration>, hint?: boolean): StyleRule;
    // (undocumented)
    get selector(): string;
    // (undocumented)
    get style(): Block;
    // (undocumented)
    toJSON(): StyleRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace StyleRule {
    // @internal (undocumented)
    export function fromStyleRule(json: JSON): Trampoline<StyleRule>;
    // (undocumented)
    export function isEmpty(rule: StyleRule): boolean;
    // (undocumented)
    export function isStyleRule(value: unknown): value is StyleRule;
    // (undocumented)
    export interface JSON extends Rule.JSON<"style"> {
        // (undocumented)
        selector: string;
        // (undocumented)
        style: Block.JSON | string;
    }
}

// @public (undocumented)
export class SupportsRule extends ConditionRule<"supports"> {
    // (undocumented)
    static of(condition: string, rules: Iterable<Rule>): SupportsRule;
    // (undocumented)
    get query(): Option_2<Feature.Supports.Query>;
    // (undocumented)
    toJSON(): SupportsRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace SupportsRule {
    // @internal (undocumented)
    export function fromSupportsRule(json: JSON): Trampoline<SupportsRule>;
    // (undocumented)
    export function isSupportsRule(value: unknown): value is SupportsRule;
    // (undocumented)
    export interface JSON extends ConditionRule.JSON<"supports"> {
    }
    // (undocumented)
    export function matches(device: Device): Predicate<SupportsRule>;
}

// @public (undocumented)
class Text_2 extends Node_2<"text"> implements Slotable {
    // (undocumented)
    assignedSlot(): Option_2<Slot>;
    // (undocumented)
    get data(): string;
    // (undocumented)
    static empty(): Text_2;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    static of(data: string, externalId?: string, serializationId?: string, extraData?: any): Text_2;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal;
    }): Text_2.MinimalJSON;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Low;
    }): Text_2.MinimalJSON;
    // (undocumented)
    toJSON(options?: Node_2.SerializationOptions): Text_2.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Text_2 {
    // @internal (undocumented)
    function cloneText(text: Text_2): Trampoline<Text_2>;
    // @internal (undocumented)
    function fromText(json: JSON): Trampoline<Text_2>;
    // (undocumented)
    function isText(value: unknown): value is Text_2;
    // (undocumented)
    interface JSON extends Node_2.JSON<"text"> {
        // (undocumented)
        data: string;
    }
    // (undocumented)
    interface MinimalJSON extends Node_2.JSON<"text"> {
    }
}
export { Text_2 as Text }

// @public (undocumented)
export class Type<N extends string = string> extends Node_2<"type"> {
    // (undocumented)
    static empty(): Type;
    // (undocumented)
    get name(): N;
    // (undocumented)
    static of<N extends string = string>(name: N, publicId?: Option_2<string>, systemId?: Option_2<string>, externalId?: string, serializationId?: string, extraData?: any): Type<N>;
    // (undocumented)
    get publicId(): Option_2<string>;
    // (undocumented)
    get systemId(): Option_2<string>;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Minimal;
    }): Type.MinimalJSON;
    // (undocumented)
    toJSON(options: Node_2.SerializationOptions & {
        verbosity: json.Serializable.Verbosity.Low;
    }): Type.MinimalJSON;
    // (undocumented)
    toJSON(options?: Node_2.SerializationOptions): Type.JSON<N>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Type {
    // @internal (undocumented)
    export function cloneType<N extends string = string>(type: Type<N>): Trampoline<Type<N>>;
    // @internal (undocumented)
    export function fromType<N extends string = string>(json: JSON<N>): Trampoline<Type<N>>;
    // (undocumented)
    export function isType(value: unknown): value is Type;
    // (undocumented)
    export interface JSON<N extends string = string> extends Node_2.JSON<"type"> {
        // (undocumented)
        name: N;
        // (undocumented)
        publicId: string | null;
        // (undocumented)
        systemId: string | null;
    }
    // (undocumented)
    export interface MinimalJSON extends Node_2.JSON<"type"> {
    }
}

// (No @packageDocumentation comment for this package)

```
