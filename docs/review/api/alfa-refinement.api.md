## API Report File for "@siteimprove/alfa-refinement"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Mapper } from '@siteimprove/alfa-mapper';
import { Predicate } from '@siteimprove/alfa-predicate';

// @public (undocumented)
export type Refinement<T, U extends T, A extends Array<unknown> = []> = (value: T, ...args: A) => value is U;

// @public (undocumented)
export namespace Refinement {
    // (undocumented)
    export interface And {
        // (undocumented)
        <T, U extends T, V extends U, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<U, V, A>): Refinement<T, V, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<U, A>): Refinement<T, U, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Refinement<T, U, A>;
        // (undocumented)
        <T, A extends Array<unknown> = []>(...predicates: Array<Predicate<T, A>>): Predicate<T, A>;
    }
    const // (undocumented)
    test: Test;
    // (undocumented)
    export interface Equals {
        // (undocumented)
        <T, U extends T>(...values: Array<U>): Refinement<T, U>;
        // (undocumented)
        <T>(...values: Array<T>): Predicate<unknown>;
    }
    const // (undocumented)
    fold: Fold;
    // (undocumented)
    export interface Fold {
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = [], V = U, W = T>(refinement: Refinement<T, U, A>, ifTrue: Mapper<U, V>, ifFalse: Mapper<T, W>, value: T, ...args: A): V | W;
        // (undocumented)
        <T, A extends Array<unknown> = [], V = T, W = T>(predicate: Predicate<T, A>, ifTrue: Mapper<T, V>, ifFalse: Mapper<T, W>, value: T, ...args: A): V | W;
    }
    const // (undocumented)
    not: Not;
    // (undocumented)
    export function isBigInt(value: unknown): value is bigint;
    const // (undocumented)
    and: And;
    // (undocumented)
    export function isBoolean(value: unknown): value is boolean;
    const // (undocumented)
    or: Or;
    // (undocumented)
    export function isFunction(value: unknown): value is Function;
    const // (undocumented)
    xor: Xor;
    // (undocumented)
    export function isNull(value: unknown): value is null;
    const // (undocumented)
    nor: Nor;
    // (undocumented)
    export function isNumber(value: unknown): value is number;
    const // (undocumented)
    nand: Nand;
    // (undocumented)
    export function isObject(value: unknown): value is {
        [key: string]: unknown;
    };
    const // (undocumented)
    equals: Equals;
    // (undocumented)
    export function isString(value: unknown): value is string;
    // (undocumented)
    export function isSymbol(value: unknown): value is symbol;
    // (undocumented)
    export function isUndefined(value: unknown): value is undefined;
    // (undocumented)
    export interface Nand {
        // (undocumented)
        <T, U extends T, V extends U, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<T, V, A>): Refinement<T, Exclude<T, U> | Exclude<T, V>, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<T, A>): Predicate<T, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Predicate<T, A>;
        // (undocumented)
        <T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Predicate<T, A>): Predicate<T, A>;
    }
    // (undocumented)
    export interface Nor {
        // (undocumented)
        <T, U extends T, V extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<T, V, A>): Refinement<T, Exclude<T, U | V>, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<T, A>): Refinement<T, Exclude<T, U>, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Refinement<T, Exclude<T, U>, A>;
        // (undocumented)
        <T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Predicate<T, A>): Predicate<T, A>;
    }
    // (undocumented)
    export interface Not {
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(refinement: Refinement<T, U, A>): Refinement<T, Exclude<T, U>, A>;
        // (undocumented)
        <T, A extends Array<unknown> = []>(predicate: Predicate<T, A>): Predicate<T, A>;
    }
    // (undocumented)
    export interface Or {
        // (undocumented)
        <T, U extends T, V extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<T, V, A>): Refinement<T, U | V, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<T, A>): Refinement<T, U | T, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Refinement<T, U | T, A>;
        // (undocumented)
        <T, A extends Array<unknown> = []>(...predicates: Array<Predicate<T, A>>): Predicate<T, A>;
    }
    // (undocumented)
    export interface Test {
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(refinement: Refinement<T, U, A>, value: T, ...args: A): value is U;
        // (undocumented)
        <T, A extends Array<unknown> = []>(predicate: Predicate<T, A>, value: T, ...args: A): boolean;
    }
    // (undocumented)
    export interface Xor {
        // (undocumented)
        <T, U extends T, V extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Refinement<T, V, A>): Refinement<T, U | V, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Refinement<T, U, A>, right: Predicate<T, A>): Refinement<T, U | T, A>;
        // (undocumented)
        <T, U extends T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Refinement<T, U, A>): Refinement<T, U | T, A>;
        // (undocumented)
        <T, A extends Array<unknown> = []>(left: Predicate<T, A>, right: Predicate<T, A>): Predicate<T, A>;
    }
    const // (undocumented)
    isPrimitive: Refinement<unknown, string | number | bigint | boolean | symbol | null | undefined, []>;
    {};
}


// (No @packageDocumentation comment for this package)

```
