## API Report File for "@siteimprove/alfa-option"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Applicative } from '@siteimprove/alfa-applicative';
import { Callback } from '@siteimprove/alfa-callback';
import { Comparable } from '@siteimprove/alfa-comparable';
import { Comparer } from '@siteimprove/alfa-comparable';
import { Comparison } from '@siteimprove/alfa-comparable';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Foldable } from '@siteimprove/alfa-foldable';
import { Functor } from '@siteimprove/alfa-functor';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Monad } from '@siteimprove/alfa-monad';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Reducer } from '@siteimprove/alfa-reducer';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Serializable } from '@siteimprove/alfa-json';
import { Thunk } from '@siteimprove/alfa-thunk';

// @public (undocumented)
export interface None extends Option<never> {
}

// @public (undocumented)
export const None: None;

// @public (undocumented)
export namespace None {
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "none";
    }
}

// @public (undocumented)
export interface Option<T> extends Functor<T>, Applicative<T>, Monad<T>, Foldable<T>, Iterable<T>, Equatable, Hashable, Serializable<Option.JSON<T>> {
    // (undocumented)
    and<U>(option: Option<U>): Option<U>;
    // (undocumented)
    andThen<U>(option: Mapper<T, Option<U>>): Option<U>;
    // (undocumented)
    apply<U>(mapper: Option<Mapper<T, U>>): Option<U>;
    // (undocumented)
    compare<T>(this: Option<Comparable<T>>, option: Option<T>): Comparison;
    // (undocumented)
    compareWith<U = T>(option: Option<U>, comparer: Comparer<T, U>): Comparison;
    // (undocumented)
    every<U extends T>(refinement: Refinement<T, U>): this is Option<U>;
    // (undocumented)
    every(predicate: Predicate<T>): boolean;
    // (undocumented)
    filter<U extends T>(refinement: Refinement<T, U>): Option<U>;
    // (undocumented)
    filter(predicate: Predicate<T>): Option<T>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Option<U>>): Option<U>;
    // (undocumented)
    flatten<T>(this: Option<Option<T>>): Option<T>;
    // (undocumented)
    get(message?: string): T;
    // (undocumented)
    getOr<U>(value: U): T | U;
    // (undocumented)
    getOrElse<U>(value: Thunk<U>): T | U;
    // (undocumented)
    includes(value: T): this is Some<T>;
    // (undocumented)
    isNone(): this is None;
    // (undocumented)
    isSome(): this is Some<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Option<U>;
    // (undocumented)
    none<U extends T>(refinement: Refinement<T, U>): this is Option<Exclude<T, U>>;
    // (undocumented)
    none(predicate: Predicate<T>): boolean;
    // (undocumented)
    or<U>(option: Option<U>): Option<T | U>;
    // (undocumented)
    orElse<U>(option: Thunk<Option<U>>): Option<T | U>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    reject<U extends T>(refinement: Refinement<T, U>): Option<Exclude<T, U>>;
    // (undocumented)
    reject(predicate: Predicate<T>): Option<T>;
    // (undocumented)
    some<U extends T>(refinement: Refinement<T, U>): this is Some<U>;
    // (undocumented)
    some(predicate: Predicate<T>): this is Some<T>;
    // (undocumented)
    tee(callback: Callback<T>): Option<T>;
    // (undocumented)
    toArray(): Array<T>;
    // (undocumented)
    toJSON(): Option.JSON<T>;
}

// @public (undocumented)
export namespace Option {
    // (undocumented)
    export function empty<T>(): Option<T>;
    // (undocumented)
    export function from<T>(value: T | null | undefined): Option<NonNullable<T>>;
    // (undocumented)
    export function isNone<T>(value: Iterable<T>): value is None;
    // (undocumented)
    export function isNone(value: unknown): value is None;
    // (undocumented)
    export function isOption<T>(value: Iterable<T>): value is Option<T>;
    // (undocumented)
    export function isOption<T>(value: unknown): value is Option<T>;
    // (undocumented)
    export function isSome<T>(value: Iterable<T>): value is Some<T>;
    // (undocumented)
    export function isSome<T>(value: unknown): value is Some<T>;
    // (undocumented)
    export type JSON<T> = Some.JSON<T> | None.JSON;
    // (undocumented)
    export type Maybe<T> = T | Option<T>;
    // (undocumented)
    export function of<T>(value: T): Option<T>;
}

// @public (undocumented)
export class Some<T> implements Option<T> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    // (undocumented)
    and<U>(option: Option<U>): Option<U>;
    // (undocumented)
    andThen<U>(option: Mapper<T, Option<U>>): Option<U>;
    // (undocumented)
    apply<U>(mapper: Option<Mapper<T, U>>): Option<U>;
    // (undocumented)
    compare<T>(this: Option<Comparable<T>>, option: Option<T>): Comparison;
    // (undocumented)
    compareWith<U = T>(option: Option<U>, comparer: Comparer<T, U>): Comparison;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    every(predicate: Predicate<T>): boolean;
    // (undocumented)
    filter<U extends T>(refinement: Refinement<T, U>): Option<U>;
    // (undocumented)
    filter(predicate: Predicate<T>): Option<T>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Option<U>>): Option<U>;
    // (undocumented)
    flatten<T>(this: Some<Option<T>>): Option<T>;
    // (undocumented)
    get(): T;
    // (undocumented)
    getOr(): T;
    // (undocumented)
    getOrElse(): T;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    isNone(): this is None;
    // (undocumented)
    isSome(): this is Some<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Option<U>;
    // (undocumented)
    none(predicate: Predicate<T>): boolean;
    // (undocumented)
    static of<T>(value: T): Some<T>;
    // (undocumented)
    or(): Option<T>;
    // (undocumented)
    orElse(): Option<T>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    reject<U extends T>(refinement: Refinement<T, U>): Option<Exclude<T, U>>;
    // (undocumented)
    reject(predicate: Predicate<T>): Option<T>;
    // (undocumented)
    some(predicate: Predicate<T>): boolean;
    // (undocumented)
    tee(callback: Callback<T>): Option<T>;
    // (undocumented)
    toArray(): [T];
    // (undocumented)
    toJSON(): Some.JSON<T>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Some {
    // (undocumented)
    export function isSome<T>(value: Iterable<T>): value is Some<T>;
    // (undocumented)
    export function isSome<T>(value: unknown): value is Some<T>;
    // (undocumented)
    export interface JSON<T> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "some";
        // (undocumented)
        value: Serializable.ToJSON<T>;
    }
}

// (No @packageDocumentation comment for this package)

```
