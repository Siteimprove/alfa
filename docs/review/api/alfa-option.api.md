## API Report File for "@siteimprove/alfa-option"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import type { Callback } from '@siteimprove/alfa-callback';
import { Comparable } from '@siteimprove/alfa-comparable';
import { Comparer } from '@siteimprove/alfa-comparable';
import { Comparison } from '@siteimprove/alfa-comparable';
import type { Equatable } from '@siteimprove/alfa-equatable';
import type { Foldable } from '@siteimprove/alfa-foldable';
import type { Hash } from '@siteimprove/alfa-hash';
import type { Hashable } from '@siteimprove/alfa-hash';
import type * as json from '@siteimprove/alfa-json';
import type { Mapper } from '@siteimprove/alfa-mapper';
import type { Monad } from '@siteimprove/alfa-monad';
import { Predicate } from '@siteimprove/alfa-predicate';
import type { Reducer } from '@siteimprove/alfa-reducer';
import type { Refinement } from '@siteimprove/alfa-refinement';
import { Serializable } from '@siteimprove/alfa-json';
import type { Thunk } from '@siteimprove/alfa-thunk';

// Warning: (ae-internal-missing-underscore) The name "Maybe" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type Maybe<T> = T | Option<T>;

// @internal (undocumented)
export namespace Maybe {
    // (undocumented)
    export function toOption<T>(maybe: Maybe<T>): Option<T>;
}

// @public (undocumented)
export interface None extends Option<never> {
}

// @public (undocumented)
export const None: None;

// @public (undocumented)
export namespace None {
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "none";
    }
}

// @public (undocumented)
export interface Option<T, O extends Serializable.Options = Serializable.Options> extends Monad<T>, Foldable<T>, Iterable<T>, Equatable, Hashable, Serializable<Option.JSON<T>, O> {
    // (undocumented)
    and<U>(option: Option<U>): Option<U>;
    // (undocumented)
    andThen<U>(option: Mapper<T, Option<U>>): Option<U>;
    // (undocumented)
    apply<U>(mapper: Option<Mapper<T, U>>): Option<U>;
    // (undocumented)
    compare<T>(this: Option<Comparable<T>>, option: Option<T>): Comparison;
    // (undocumented)
    compareWith<U = T>(option: Option<U>, comparer: Comparer<T, U>): Comparison;
    // (undocumented)
    every<U extends T>(refinement: Refinement<T, U>): this is Option<U>;
    // (undocumented)
    every(predicate: Predicate<T>): boolean;
    // (undocumented)
    filter<U extends T>(refinement: Refinement<T, U>): Option<U>;
    // (undocumented)
    filter(predicate: Predicate<T>): Option<T>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Option<U>>): Option<U>;
    // (undocumented)
    flatten<T>(this: Option<Option<T>>): Option<T>;
    // (undocumented)
    forEach(mapper: Mapper<T, void>): void;
    // (undocumented)
    getOr<U>(value: U): T | U;
    // (undocumented)
    getOrElse<U>(value: Thunk<U>): T | U;
    // @internal
    getUnsafe(message?: string): T;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    isNone(): this is None;
    // (undocumented)
    isSome(): this is Some<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Option<U>;
    // (undocumented)
    none<U extends T>(refinement: Refinement<T, U>): this is Option<Exclude<T, U>>;
    // (undocumented)
    none(predicate: Predicate<T>): boolean;
    // (undocumented)
    or<U>(option: Option<U>): Option<T | U>;
    // (undocumented)
    orElse<U>(option: Thunk<Option<U>>): Option<T | U>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    reject<U extends T>(refinement: Refinement<T, U>): Option<Exclude<T, U>>;
    // (undocumented)
    reject(predicate: Predicate<T>): Option<T>;
    // (undocumented)
    some<U extends T>(refinement: Refinement<T, U>): this is Some<U>;
    // (undocumented)
    some(predicate: Predicate<T>): boolean;
    // (undocumented)
    tee(callback: Callback<T>): Option<T>;
    // (undocumented)
    toArray(): Array<T>;
    // (undocumented)
    toJSON(options?: O): Option.JSON<T>;
}

// @public (undocumented)
export namespace Option {
    // (undocumented)
    export function empty<T>(): None;
    // (undocumented)
    export function from<T>(value: T | null | undefined): Option<NonNullable<T>>;
    // (undocumented)
    export function isNone<T>(value: Iterable<T>): value is None;
    // (undocumented)
    export function isNone(value: unknown): value is None;
    // (undocumented)
    export function isOption<T>(value: Iterable<T>): value is Option<T>;
    // (undocumented)
    export function isOption<T>(value: unknown): value is Option<T>;
    // (undocumented)
    export function isSome<T>(value: Iterable<T>): value is Some<T>;
    // (undocumented)
    export function isSome<T>(value: unknown): value is Some<T>;
    // (undocumented)
    export type JSON<T> = Some.JSON<T> | None.JSON;
    // (undocumented)
    export function of<T>(value: T): Some<T>;
}

// @public (undocumented)
export class Some<T, O extends Serializable.Options = Serializable.Options> implements Option<T, O> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    // (undocumented)
    and<U>(option: Option<U>): Option<U>;
    // (undocumented)
    andThen<U>(option: Mapper<T, Option<U>>): Option<U>;
    // (undocumented)
    apply<U>(mapper: Option<Mapper<T, U>>): Option<U>;
    // (undocumented)
    compare<T>(this: Option<Comparable<T>>, option: Option<T>): Comparison;
    // (undocumented)
    compareWith<U = T>(option: Option<U>, comparer: Comparer<T, U>): Comparison;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    every<U extends T>(refinement: Refinement<T, U>): this is Some<U>;
    // (undocumented)
    every(predicate: Predicate<T>): boolean;
    // (undocumented)
    filter<U extends T>(refinement: Refinement<T, U>): Option<U>;
    // (undocumented)
    filter(predicate: Predicate<T>): Option<T>;
    // (undocumented)
    flatMap<U>(mapper: Mapper<T, Option<U>>): Option<U>;
    // (undocumented)
    flatten<T>(this: Some<Option<T>>): Option<T>;
    // (undocumented)
    forEach(mapper: Mapper<T, void>): void;
    // (undocumented)
    get(): T;
    // (undocumented)
    getOr(): T;
    // (undocumented)
    getOrElse(): T;
    // @internal (undocumented)
    getUnsafe(): T;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    includes(value: T): boolean;
    // (undocumented)
    isNone(): this is None;
    // (undocumented)
    isSome(): this is Some<T>;
    // (undocumented)
    map<U>(mapper: Mapper<T, U>): Some<U>;
    // (undocumented)
    none<U extends T>(refinement: Refinement<T, U>): this is Some<Exclude<T, U>>;
    // (undocumented)
    none(predicate: Predicate<T>): boolean;
    // (undocumented)
    static of<T>(value: T): Some<T>;
    // (undocumented)
    or(): Some<T>;
    // (undocumented)
    orElse(): Some<T>;
    // (undocumented)
    reduce<U>(reducer: Reducer<T, U>, accumulator: U): U;
    // (undocumented)
    reject<U extends T>(refinement: Refinement<T, U>): Option<Exclude<T, U>>;
    // (undocumented)
    reject(predicate: Predicate<T>): Option<T>;
    // (undocumented)
    some<U extends T>(refinement: Refinement<T, U>): this is Some<U>;
    // (undocumented)
    some(predicate: Predicate<T>): boolean;
    // (undocumented)
    tee(callback: Callback<T>): this;
    // (undocumented)
    toArray(): [T];
    // (undocumented)
    toJSON(options?: O): Some.JSON<T>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Some {
    // (undocumented)
    export function isSome<T>(value: Iterable<T>): value is Some<T>;
    // (undocumented)
    export function isSome<T>(value: unknown): value is Some<T>;
    // (undocumented)
    export interface JSON<T> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: "some";
        // (undocumented)
        value: Serializable.ToJSON<T>;
    }
}

// (No @packageDocumentation comment for this package)

```
