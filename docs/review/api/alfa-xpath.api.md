## API Report File for "@siteimprove/alfa-xpath"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as dom from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import * as json from '@siteimprove/alfa-json';
import { Node } from '@siteimprove/alfa-dom';
import { Option } from '@siteimprove/alfa-option';
import { Parser as Parser_2 } from '@siteimprove/alfa-parser';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Serializable } from '@siteimprove/alfa-json';
import { Slice } from '@siteimprove/alfa-slice';

// @public (undocumented)
export function axis(axis: Expression.Axis.Type, name?: string): Builder.Axis;

// @public (undocumented)
export namespace axis {
    // (undocumented)
    export function ancestor(name?: string): Builder.Axis;
    // (undocumented)
    export function attribute(name?: string): Builder.Axis;
    // (undocumented)
    export function child(name?: string): Builder.Axis;
    // (undocumented)
    export function descendant(name?: string): Builder.Axis;
    // (undocumented)
    export function parent(name?: string): Builder.Axis;
    // (undocumented)
    export function self(name?: string): Builder.Axis;
}

// Warning: (ae-internal-missing-underscore) The name "boolean" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function boolean(): Descriptors.Boolean;

// @public (undocumented)
export class Builder<T extends Expression = Expression> implements Equatable, Serializable {
    constructor(expression: T);
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    readonly expression: T;
    // (undocumented)
    toJSON(): Builder.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Builder {
    // (undocumented)
    export class Axis extends Axis_base {
        // (undocumented)
        where(predicate: Builder): Axis;
    }
    const // (undocumented)
    ContextItem_base: {
        new (expression: Expression.ContextItem): {
            child(name?: string | undefined): Path;
            parent(name?: string | undefined): Path;
            descendant(name?: string | undefined): Path;
            ancestor(name?: string | undefined): Path;
            attribute(name?: string | undefined): Path;
            readonly expression: Expression.ContextItem;
            equals(value: unknown): value is any;
            toJSON(): JSON;
            toString(): string;
        };
    };
    // (undocumented)
    export class ContextItem extends ContextItem_base {
        // (undocumented)
        where(predicate: Builder): Filter;
    }
    const // (undocumented)
    Filter_base: {
        new (expression: Expression.Filter): {
            child(name?: string | undefined): Path;
            parent(name?: string | undefined): Path;
            descendant(name?: string | undefined): Path;
            ancestor(name?: string | undefined): Path;
            attribute(name?: string | undefined): Path;
            readonly expression: Expression.Filter;
            equals(value: unknown): value is any;
            toJSON(): JSON;
            toString(): string;
        };
    };
    // (undocumented)
    export class Filter extends Filter_base {
        // (undocumented)
        where(predicate: Builder): Filter;
    }
    const // (undocumented)
    Axis_base: {
        new (expression: Expression.Axis): {
            child(name?: string | undefined): Path;
            parent(name?: string | undefined): Path;
            descendant(name?: string | undefined): Path;
            ancestor(name?: string | undefined): Path;
            attribute(name?: string | undefined): Path;
            readonly expression: Expression.Axis;
            equals(value: unknown): value is any;
            toJSON(): JSON;
            toString(): string;
        };
    };
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        expression: Expression.JSON;
    }
    const // (undocumented)
    Path_base: {
        new (expression: Expression.Path): {
            child(name?: string | undefined): Path;
            parent(name?: string | undefined): Path;
            descendant(name?: string | undefined): Path;
            ancestor(name?: string | undefined): Path;
            attribute(name?: string | undefined): Path;
            readonly expression: Expression.Path;
            equals(value: unknown): value is any;
            toJSON(): JSON;
            toString(): string;
        };
    };
    // (undocumented)
    export class Path extends Path_base {
        // (undocumented)
        where(predicate: Builder): Path;
    }
    {};
}

// Warning: (ae-internal-missing-underscore) The name "coerceItems" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function coerceItems(items: Iterable<Item>, type: Type): Value | null;

// @public (undocumented)
export function context(): Builder.ContextItem;

// Warning: (ae-internal-missing-underscore) The name "decimal" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function decimal(): Descriptors.Decimal;

// Warning: (ae-internal-missing-underscore) The name "Descriptor" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface Descriptor<T = unknown, V = unknown, P = {}> {
    // (undocumented)
    readonly properties: P;
    // (undocumented)
    readonly type: T;
}

// @internal (undocumented)
export namespace Descriptor {
    // (undocumented)
    export type For<V, D extends Descriptor> = D extends Descriptor<infer T, infer U, infer P> ? U extends V ? D : never : never;
    // (undocumented)
    export type Properties<D extends Descriptor> = D extends Descriptor<infer T, infer V, infer P> ? P : never;
    // (undocumented)
    export type Type<D> = D extends Descriptor<infer T, infer V, infer P> ? T : never;
    // (undocumented)
    export type Value<D> = D extends Descriptor<infer T, infer V, infer P> ? V : never;
}

// Warning: (ae-internal-missing-underscore) The name "Descriptors" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export namespace Descriptors {
    // (undocumented)
    export type Boolean = Descriptor<"boolean", boolean>;
    // (undocumented)
    export type Decimal = Descriptor<"decimal", number>;
    // (undocumented)
    export type Double = Descriptor<"double", number>;
    // (undocumented)
    export type Element = Descriptor<"element", dom.Element>;
    // (undocumented)
    export type Integer = Descriptor<"integer", number>;
    // (undocumented)
    export type Node = Descriptor<"node", dom.Node>;
    // (undocumented)
    export type Numeric = Descriptor<"numeric", number>;
    // (undocumented)
    export type Optional<D extends Descriptor> = Descriptor<"?", Descriptor.Value<D> | undefined, {
        readonly descriptor: D;
    }>;
    // (undocumented)
    export type Sequence<D extends Descriptor> = Descriptor<"*" | "+", Iterable<Descriptor.Value<D>>, {
        readonly descriptor: D;
    }>;
    // (undocumented)
    export type String = Descriptor<"string", string>;
}

// Warning: (ae-internal-missing-underscore) The name "double" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function double(): Descriptors.Double;

// Warning: (ae-internal-missing-underscore) The name "element" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function element(): Descriptors.Element;

// Warning: (ae-internal-missing-underscore) The name "Environment" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface Environment<T extends Item.Value> {
    // (undocumented)
    readonly focus: Focus<T>;
    // (undocumented)
    readonly functions: FunctionMap;
}

// @public (undocumented)
export function evaluate(scope: Node, expression: string | Expression | Builder, options?: evaluate.Options): Iterable<Node>;

// @public (undocumented)
export namespace evaluate {
    // (undocumented)
    export interface Options extends Node.Traversal {
    }
}

// @public (undocumented)
export type Expression = Expression.Primary | Expression.Path | Expression.Axis | Expression.Filter;

// @public (undocumented)
export namespace Expression {
    // (undocumented)
    export class Axis implements Equatable, Serializable {
        // (undocumented)
        get axis(): Axis.Type;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(axis: Axis.Type, test?: Option<Test>, predicates?: Array<Expression>): Axis;
        // (undocumented)
        get predicates(): Iterable<Expression>;
        // (undocumented)
        get test(): Option<Test>;
        // (undocumented)
        toJSON(): Axis.JSON;
        // (undocumented)
        get type(): "axis";
    }
    // (undocumented)
    export namespace Axis {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            axis: string;
            // (undocumented)
            predicates: Array<Expression.JSON>;
            // (undocumented)
            test: Test.JSON | null;
            // (undocumented)
            type: "axis";
        }
        // (undocumented)
        export type Type = "ancestor" | "ancestor-or-self" | "attribute" | "child" | "descendant" | "descendant-or-self" | "following" | "following-sibling" | "parent" | "preceding" | "preceding-sibling" | "self";
    }
    // (undocumented)
    export class ContextItem implements Equatable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): ContextItem;
        // (undocumented)
        toJSON(): ContextItem.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "context-item";
    }
    // (undocumented)
    export namespace ContextItem {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "context-item";
        }
    }
    // (undocumented)
    export class Decimal implements Equatable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number): Decimal;
        // (undocumented)
        toJSON(): Decimal.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "decimal";
        // (undocumented)
        get value(): number;
        }
    // (undocumented)
    export namespace Decimal {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "decimal";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export class Double implements Equatable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number): Double;
        // (undocumented)
        toJSON(): Double.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "double";
        // (undocumented)
        get value(): number;
        }
    // (undocumented)
    export namespace Double {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "double";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export class Filter implements Equatable, Serializable {
        // (undocumented)
        get base(): Expression;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(base: Expression, predicates: Array<Expression>): Filter;
        // (undocumented)
        get predicates(): Iterable<Expression>;
        // (undocumented)
        toJSON(): Filter.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "filter";
    }
    // (undocumented)
    export namespace Filter {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            base: Expression.JSON;
            // (undocumented)
            predicates: Array<Expression.JSON>;
            // (undocumented)
            type: "filter";
        }
    }
    // (undocumented)
    export class FunctionCall implements Equatable, Serializable {
        // (undocumented)
        get arity(): number;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get name(): string;
        // (undocumented)
        static of(prefix: Option<string>, name: string, arity: number, parameters: Array<Expression>): FunctionCall;
        // (undocumented)
        get parameters(): Iterable<Expression>;
        // (undocumented)
        get prefix(): Option<string>;
        // (undocumented)
        toJSON(): FunctionCall.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "function-call";
    }
    // (undocumented)
    export namespace FunctionCall {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            arity: number;
            // (undocumented)
            name: string;
            // (undocumented)
            parameters: Array<Expression.JSON>;
            // (undocumented)
            prefix: string | null;
            // (undocumented)
            type: "function-call";
        }
    }
    // (undocumented)
    export class Integer implements Equatable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number): Integer;
        // (undocumented)
        toJSON(): Integer.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "integer";
        // (undocumented)
        get value(): number;
        }
    // (undocumented)
    export namespace Integer {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "integer";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export type JSON = Primary.JSON | Path.JSON | Axis.JSON | Filter.JSON;
    // (undocumented)
    export type Literal = Integer | Decimal | Double | String;
    // (undocumented)
    export namespace Literal {
        // (undocumented)
        export type JSON = Integer.JSON | Decimal.JSON | Double.JSON | String.JSON;
    }
    // (undocumented)
    export class Path implements Equatable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get left(): Expression;
        // (undocumented)
        static of(left: Expression, right: Expression): Path;
        // (undocumented)
        get right(): Expression;
        // (undocumented)
        toJSON(): Path.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "path";
    }
    // (undocumented)
    export namespace Path {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            left: Expression.JSON;
            // (undocumented)
            right: Expression.JSON;
            // (undocumented)
            type: "path";
        }
    }
    // (undocumented)
    export type Postfix = Primary | Filter;
    // (undocumented)
    export namespace Postfix {
        // (undocumented)
        export type JSON = Primary.JSON | Filter.JSON;
    }
    // (undocumented)
    export type Primary = Literal | ContextItem | FunctionCall;
    // (undocumented)
    export namespace Primary {
        // (undocumented)
        export type JSON = Literal.JSON | ContextItem.JSON | FunctionCall.JSON;
    }
    // (undocumented)
    export type Step = Postfix | Axis;
    // (undocumented)
    export namespace Step {
        // (undocumented)
        export type JSON = Postfix.JSON | Axis.JSON;
    }
    // (undocumented)
    export class String implements Equatable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): String;
        // (undocumented)
        toJSON(): String.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "string";
        // (undocumented)
        get value(): string;
        }
    // (undocumented)
    export namespace String {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "string";
            // (undocumented)
            value: string;
        }
    }
    // (undocumented)
    export type Test = Test.Kind | Test.Name;
    // (undocumented)
    export namespace Test {
        // (undocumented)
        export class Attribute implements Equatable, Serializable {
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get kind(): "attribute";
            // (undocumented)
            get name(): Option<string>;
            // (undocumented)
            static of(name: Option<string>): Attribute;
            // (undocumented)
            toJSON(): Attribute.JSON;
            // (undocumented)
            toString(): string;
            // (undocumented)
            get type(): "kind";
        }
        // (undocumented)
        export namespace Attribute {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                kind: "attribute";
                // (undocumented)
                name: string | null;
                // (undocumented)
                type: "kind";
            }
        }
        // (undocumented)
        export class Comment implements Equatable, Serializable {
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get kind(): "comment";
            // (undocumented)
            static of(): Comment;
            // (undocumented)
            toJSON(): Comment.JSON;
            // (undocumented)
            toString(): string;
            // (undocumented)
            get type(): "kind";
        }
        // (undocumented)
        export namespace Comment {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                kind: "comment";
                // (undocumented)
                type: "kind";
            }
        }
        // (undocumented)
        export class Document implements Equatable, Serializable {
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get kind(): "document";
            // (undocumented)
            static of(): Document;
            // (undocumented)
            toJSON(): Document.JSON;
            // (undocumented)
            toString(): string;
            // (undocumented)
            get type(): "kind";
        }
        // (undocumented)
        export namespace Document {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                kind: "document";
                // (undocumented)
                type: "kind";
            }
        }
        // (undocumented)
        export class Element implements Equatable, Serializable {
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get kind(): "element";
            // (undocumented)
            get name(): Option<string>;
            // (undocumented)
            static of(name: Option<string>): Element;
            // (undocumented)
            toJSON(): Element.JSON;
            // (undocumented)
            toString(): string;
            // (undocumented)
            get type(): "kind";
        }
        // (undocumented)
        export namespace Element {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                kind: "element";
                // (undocumented)
                name: string | null;
                // (undocumented)
                type: "kind";
            }
        }
        // (undocumented)
        export type JSON = Kind.JSON | Name.JSON;
        // (undocumented)
        export type Kind = Node | Document | Element | Attribute | Comment | Text;
        // (undocumented)
        export namespace Kind {
            // (undocumented)
            export type JSON = Node.JSON | Document.JSON | Element.JSON | Attribute.JSON | Comment.JSON | Text.JSON;
        }
        // (undocumented)
        export class Name implements Equatable, Serializable {
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get name(): string;
            // (undocumented)
            static of(prefix: Option<string>, name: string): Name;
            // (undocumented)
            get prefix(): Option<string>;
            // (undocumented)
            toJSON(): Name.JSON;
            // (undocumented)
            toString(): string;
            // (undocumented)
            get type(): "name";
        }
        // (undocumented)
        export namespace Name {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                name: string;
                // (undocumented)
                prefix: string | null;
                // (undocumented)
                type: "name";
            }
        }
        // (undocumented)
        export class Node implements Equatable, Serializable {
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get kind(): "node";
            // (undocumented)
            static of(): Node;
            // (undocumented)
            toJSON(): Node.JSON;
            // (undocumented)
            toString(): string;
            // (undocumented)
            get type(): "kind";
        }
        // (undocumented)
        export namespace Node {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                kind: "node";
                // (undocumented)
                type: "kind";
            }
        }
        // (undocumented)
        export class Text implements Equatable, Serializable {
            // (undocumented)
            equals(value: unknown): value is this;
            // (undocumented)
            get kind(): "text";
            // (undocumented)
            static of(): Text;
            // (undocumented)
            toJSON(): Text.JSON;
            // (undocumented)
            toString(): string;
            // (undocumented)
            get type(): "kind";
        }
        // (undocumented)
        export namespace Text {
            // (undocumented)
            export interface JSON {
                // (undocumented)
                [key: string]: json.JSON;
                // (undocumented)
                kind: "text";
                // (undocumented)
                type: "kind";
            }
        }
    }
}

// Warning: (ae-internal-missing-underscore) The name "Focus" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export interface Focus<T extends Item.Value> extends Item<T> {
    // (undocumented)
    readonly position: number;
}

// @internal (undocumented)
interface Function_2<P extends Array<Value> = Array<Value>, R extends Value = Value> {
    // (undocumented)
    apply<T extends Item.Value>(environment: Environment<T>, options: evaluate.Options, ...parameters: P): R;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly parameters: Function_2.Parameters<P>;
    // (undocumented)
    readonly prefix: string;
    // (undocumented)
    readonly result: Function_2.Result<R>;
}

// @internal (undocumented)
namespace Function_2 {
    // (undocumented)
    type Parameters<V extends Array<Value>> = {
        readonly [P in keyof V]: V[P] extends Value ? TypeFor<V[P]> : never;
    };
    // (undocumented)
    type Result<V extends Value> = TypeFor<V>;
}

// Warning: (ae-internal-missing-underscore) The name "Function" should be prefixed with an underscore because the declaration is marked as @internal
export { Function_2 as Function }

// Warning: (ae-internal-missing-underscore) The name "FunctionMap" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export type FunctionMap = Map<string, Map<number, Function_2>>;

// Warning: (ae-internal-missing-underscore) The name "integer" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function integer(): Descriptors.Integer;

// @public (undocumented)
export interface Item<V extends Item.Value = Item.Value> {
    // Warning: (ae-incompatible-release-tags) The symbol "type" is marked as @public, but its signature references "Descriptor" which is marked as @internal
    //
    // (undocumented)
    readonly type: Descriptor.For<V, Item.Type>;
    // (undocumented)
    value: V;
}

// @public (undocumented)
export namespace Item {
    // Warning: (ae-incompatible-release-tags) The symbol "Optional" is marked as @public, but its signature references "Descriptors" which is marked as @internal
    //
    // (undocumented)
    export type Optional<T extends Type = Type> = Descriptors.Optional<T>;
    // Warning: (ae-incompatible-release-tags) The symbol "Sequence" is marked as @public, but its signature references "Descriptors" which is marked as @internal
    //
    // (undocumented)
    export type Sequence<T extends Type = Type> = Descriptors.Sequence<T>;
    // Warning: (ae-incompatible-release-tags) The symbol "Type" is marked as @public, but its signature references "Descriptors" which is marked as @internal
    //
    // (undocumented)
    export type Type = Descriptors.String | Descriptors.Numeric | Descriptors.Integer | Descriptors.Decimal | Descriptors.Double | Descriptors.Boolean | Descriptors.Node | Descriptors.Element;
    // Warning: (ae-incompatible-release-tags) The symbol "TypeFor" is marked as @public, but its signature references "Descriptor" which is marked as @internal
    //
    // (undocumented)
    export type TypeFor<V extends Value> = Descriptor.For<V, Type>;
    // Warning: (ae-incompatible-release-tags) The symbol "Value" is marked as @public, but its signature references "Descriptor" which is marked as @internal
    //
    // (undocumented)
    export type Value<T extends Type = Type> = Descriptor.Value<T>;
}

// @public (undocumented)
export namespace Lexer {
    // (undocumented)
    export function lex(input: string): Array<Token>;
}

// Warning: (ae-internal-missing-underscore) The name "lookupFunction" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function lookupFunction(functions: FunctionMap, prefix: string | null, name: string, arity: number): Function_2 | null;

// Warning: (ae-internal-missing-underscore) The name "matches" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function matches<T extends Item.Type>(item: Item<any>, type: T): item is Item<Item.Value<T>>;

// Warning: (ae-internal-missing-underscore) The name "node" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function node(): Descriptors.Node;

// @public (undocumented)
export function nth(i: number): Builder<Expression.Integer>;

// Warning: (ae-internal-missing-underscore) The name "numeric" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function numeric(): Descriptors.Numeric;

// Warning: (ae-internal-missing-underscore) The name "optional" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function optional<D extends Descriptor>(descriptor: D): Descriptors.Optional<D>;

// @public (undocumented)
export namespace Parser {
    // (undocumented)
    export function parse(input: string): Option<Expression>;
}

// Warning: (ae-internal-missing-underscore) The name "registerFunction" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function registerFunction(functions: FunctionMap, definition: Function_2): FunctionMap;

// Warning: (ae-internal-missing-underscore) The name "sequence" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function sequence<D extends Descriptor>(descriptor: D, options?: {
    required?: boolean;
}): Descriptors.Sequence<D>;

// @public (undocumented)
export function step(left: Builder<Expression.Step | Expression.Path>, right: Builder<Expression.Step>): Builder.Path;

// Warning: (ae-internal-missing-underscore) The name "string" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function string(): Descriptors.String;

// @public (undocumented)
export type Token = Token.Integer | Token.Decimal | Token.Double | Token.String | Token.Comment | Token.Name | Token.Character;

// @public (undocumented)
export namespace Token {
    // (undocumented)
    export class Character implements Equatable, Serializable<Character.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number): Character;
        // (undocumented)
        toJSON(): Character.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "character";
        // (undocumented)
        get value(): number;
        }
    // (undocumented)
    export namespace Character {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "character";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export class Comment implements Equatable, Serializable<Comment.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): Comment;
        // (undocumented)
        toJSON(): Comment.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "comment";
        // (undocumented)
        get value(): string;
        }
    // (undocumented)
    export namespace Comment {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "comment";
            // (undocumented)
            value: string;
        }
    }
    const // (undocumented)
    parseInteger: Parser_2<Slice<Token>, Integer, string, []>;
    // (undocumented)
    export class Decimal implements Equatable, Serializable<Decimal.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number): Decimal;
        // (undocumented)
        toJSON(): Decimal.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "decimal";
        // (undocumented)
        get value(): number;
        }
    // (undocumented)
    export namespace Decimal {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "decimal";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export class Double implements Equatable, Serializable<Double.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number): Double;
        // (undocumented)
        toJSON(): Double.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "double";
        // (undocumented)
        get value(): number;
        }
    const // (undocumented)
    parseDecimal: Parser_2<Slice<Token>, Decimal, string, []>;
    // (undocumented)
    export namespace Double {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "double";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export class Integer implements Equatable, Serializable<Integer.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number): Integer;
        // (undocumented)
        toJSON(): Integer.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "integer";
        // (undocumented)
        get value(): number;
        }
    // (undocumented)
    export namespace Integer {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "integer";
            // (undocumented)
            value: number;
        }
    }
    const // (undocumented)
    parseDouble: Parser_2<Slice<Token>, Double, string, []>;
    // (undocumented)
    export function isCharacter(value: unknown): value is Character;
    // (undocumented)
    export function isComment(value: unknown): value is Comment;
    // (undocumented)
    export function isDecimal(value: unknown): value is Decimal;
    const // (undocumented)
    parseString: Parser_2<Slice<Token>, String, string, []>;
    // (undocumented)
    export function isDouble(value: unknown): value is Double;
    // (undocumented)
    export function isInteger(value: unknown): value is Integer;
    // (undocumented)
    export function isName(value: unknown): value is Name;
    const // (undocumented)
    parseComment: Parser_2<Slice<Token>, Comment, string, []>;
    // (undocumented)
    export function isString(value: unknown): value is String;
    // (undocumented)
    export type JSON = Integer.JSON | Decimal.JSON | Double.JSON | String.JSON | Comment.JSON | Name.JSON | Character.JSON;
    // (undocumented)
    export class Name implements Equatable, Serializable<Name.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(prefix: Option<string>, value: string): Name;
        // (undocumented)
        get prefix(): Option<string>;
        // (undocumented)
        toJSON(): Name.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "name";
        // (undocumented)
        get value(): string;
        }
    const // (undocumented)
    parseName: (query?: string | Predicate<Name>) => Parser_2<Slice<Token>, Name, string, []>;
    // (undocumented)
    export namespace Name {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            prefix: string | null;
            // (undocumented)
            type: "name";
            // (undocumented)
            value: string;
        }
    }
    // (undocumented)
    export class String implements Equatable, Serializable<String.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): String;
        // (undocumented)
        toJSON(): String.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "string";
        // (undocumented)
        get value(): string;
        }
    // (undocumented)
    export namespace String {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "string";
            // (undocumented)
            value: string;
        }
    }
    const // (undocumented)
    parseCharacter: (query?: string | Predicate<Character>) => Parser_2<Slice<Token>, Character, string, []>;
}

// @public (undocumented)
export type Type = Item.Type | Item.Sequence<Item.Type> | Item.Optional<Item.Type>;

// Warning: (ae-incompatible-release-tags) The symbol "TypeFor" is marked as @public, but its signature references "Descriptor" which is marked as @internal
//
// @public (undocumented)
export type TypeFor<V extends Value> = Descriptor.For<V, Type>;

// Warning: (ae-incompatible-release-tags) The symbol "Value" is marked as @public, but its signature references "Descriptor" which is marked as @internal
//
// @public (undocumented)
export type Value<T extends Type = Type> = Descriptor.Value<T>;

// Warning: (ae-internal-missing-underscore) The name "walk" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function walk(node: Node, axis: Expression.Axis.Type, options: Node.Traversal): Iterable<Node>;

// Warning: (ae-internal-missing-underscore) The name "withFocus" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal (undocumented)
export function withFocus<T extends Item.Value, U extends Item.Value>(environment: Environment<T>, focus: Focus<U>): Environment<U>;


// (No @packageDocumentation comment for this package)

```
