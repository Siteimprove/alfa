## API Report File for "@siteimprove/alfa-rules"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as act from '@siteimprove/alfa-act';
import * as aria from '@siteimprove/alfa-aria';
import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Attribute } from '@siteimprove/alfa-dom';
import { Comparable } from '@siteimprove/alfa-comparable';
import { Comparison } from '@siteimprove/alfa-comparable';
import { Computed } from '@siteimprove/alfa-style/src/property/background-color';
import { Computed as Computed_2 } from '@siteimprove/alfa-style/src/property/background-size';
import { Computed as Computed_3 } from '@siteimprove/alfa-style/src/property/background-image';
import { Computed as Computed_4 } from '@siteimprove/alfa-style/src/property/color';
import { Computed as Computed_5 } from '@siteimprove/alfa-style/src/property/text-shadow';
import { Context } from '@siteimprove/alfa-selector';
import { Current } from '@siteimprove/alfa-css';
import { Device } from '@siteimprove/alfa-device';
import { Diagnostic as Diagnostic_2 } from '@siteimprove/alfa-act';
import { Document } from '@siteimprove/alfa-dom';
import * as earl from '@siteimprove/alfa-earl';
import { Element } from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Flags } from '@siteimprove/alfa-flags';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Language } from '@siteimprove/alfa-iana';
import { List } from '@siteimprove/alfa-list';
import { Map as Map_2 } from '@siteimprove/alfa-map';
import { Media } from '@siteimprove/alfa-media';
import { Node } from '@siteimprove/alfa-dom';
import { Option } from '@siteimprove/alfa-option';
import { Page } from '@siteimprove/alfa-web';
import { Percentage } from '@siteimprove/alfa-css';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Property } from '@siteimprove/alfa-style';
import { Record as Record_2 } from '@siteimprove/alfa-record';
import { Refinement } from '@siteimprove/alfa-refinement';
import { Result } from '@siteimprove/alfa-result';
import { RGB } from '@siteimprove/alfa-css';
import { Role } from '@siteimprove/alfa-aria';
import { Rule } from '@siteimprove/alfa-act';
import * as sarif from '@siteimprove/alfa-sarif';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';
import { Specified } from '@siteimprove/alfa-style/src/property/position';
import { Style } from '@siteimprove/alfa-style';
import { System } from '@siteimprove/alfa-css';
import { Tag } from '@siteimprove/alfa-act';
import { Text } from '@siteimprove/alfa-dom';
import { Trampoline } from '@siteimprove/alfa-trampoline';
import * as tree from '@siteimprove/alfa-tree';

// @public (undocumented)
class Attribute_2<N extends string = string> extends Node_2<"attribute"> {
    // @internal (undocumented)
    _attachOwner(owner: Element_2): boolean;
    // @internal (undocumented)
    _attachParent(): boolean;
    // (undocumented)
    enumerate(): Option<string>;
    // (undocumented)
    enumerate<T extends string>(valid: T, ...rest: Array<T>): Option<T>;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    isBoolean(): boolean;
    // (undocumented)
    get name(): N | Lowercase<N>;
    // (undocumented)
    get namespace(): Option<Namespace>;
    // (undocumented)
    static of<N extends string = string>(namespace: Option<Namespace>, prefix: Option<string>, name: N, value: string): Attribute_2<N>;
    // (undocumented)
    get owner(): Option<Element_2>;
    // (undocumented)
    get prefix(): Option<string>;
    // (undocumented)
    get qualifiedName(): string;
    // (undocumented)
    toJSON(): Attribute_2.JSON<N>;
    // (undocumented)
    tokens(separator?: string | RegExp): Sequence<string>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
namespace Attribute_2 {
    // @internal
    function foldCase<N extends string = string>(name: N, owner: Option<Element_2>): N | Lowercase<N>;
    // @internal (undocumented)
    function fromAttribute<N extends string = string>(attribute: JSON<N>): Trampoline<Attribute_2<N>>;
    // (undocumented)
    function isAttribute(value: unknown): value is Attribute_2;
    // (undocumented)
    interface JSON<N extends string = string> extends Node_2.JSON<"attribute"> {
        // (undocumented)
        name: N;
        // (undocumented)
        namespace: string | null;
        // (undocumented)
        prefix: string | null;
        // (undocumented)
        value: string;
    }
    const // Warning: (ae-forgotten-export) The symbol "predicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasName: typeof predicate.hasName;
}

// @public (undocumented)
class Block implements Iterable<Declaration>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Declaration>;
    // (undocumented)
    declaration(predicate: string | Predicate<Declaration>): Option<Declaration>;
    // (undocumented)
    get declarations(): Iterable<Declaration>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    isEmpty(): boolean;
    // (undocumented)
    static of(declarations: Iterable<Declaration>): Block;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toJSON(): Block.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Block {
    // (undocumented)
    function from(json: JSON): Block;
    // (undocumented)
    type JSON = Array<Declaration.JSON>;
}

// @public (undocumented)
class Comment extends Node_2<"comment"> {
    // (undocumented)
    get data(): string;
    // (undocumented)
    static empty(): Comment;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    static of(data: string): Comment;
    // (undocumented)
    toJSON(): Comment.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Comment {
    // @internal (undocumented)
    function fromComment(json: JSON): Trampoline<Comment>;
    // (undocumented)
    function isComment(value: unknown): value is Comment;
    // (undocumented)
    interface JSON extends Node_2.JSON<"comment"> {
        // (undocumented)
        data: string;
    }
}

// @public (undocumented)
abstract class ConditionRule extends GroupingRule {
    protected constructor(condition: string, rules: Array<Rule_2>);
    // (undocumented)
    get condition(): string;
    // (undocumented)
    protected readonly _condition: string;
    // (undocumented)
    abstract toJSON(): ConditionRule.JSON;
}

// @public (undocumented)
namespace ConditionRule {
    // (undocumented)
    function isConditionRule(value: unknown): value is ConditionRule;
    // (undocumented)
    interface JSON extends GroupingRule.JSON {
        // (undocumented)
        condition: string;
    }
}

// @public (undocumented)
class Declaration implements Equatable, Serializable {
    // (undocumented)
    ancestors(): Iterable<Rule_2>;
    // @internal (undocumented)
    _attachParent(parent: Rule_2): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get important(): boolean;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(name: string, value: string, important?: boolean): Declaration;
    // (undocumented)
    get parent(): Option<Rule_2>;
    // (undocumented)
    toJSON(): Declaration.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
namespace Declaration {
    // (undocumented)
    function from(json: JSON): Declaration;
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        important: boolean;
        // (undocumented)
        name: string;
        // (undocumented)
        value: string;
    }
}

// @public
const _default: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_10: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_11: Rule.Atomic<Page, Attribute<string>, never, Attribute<string>>;

// @public (undocumented)
const _default_12: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_13: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_14: Rule.Atomic<Page, Attribute<string>, never, Attribute<string>>;

// @public (undocumented)
const _default_15: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_16: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_17: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_18: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_19: Rule.Atomic<Page, Group<Element<string>>, Question.Metadata, Group<Element<string>>>;

// @public
const _default_2: Rule.Atomic<Page, Document, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_20: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_21: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_22: Rule.Atomic<Page, Attribute<string>, never, Attribute<string>>;

// @public (undocumented)
const _default_23: Rule.Atomic<Page, Attribute<string>, never, Attribute<string>>;

// @public (undocumented)
const _default_24: Rule.Atomic<Page, Attribute<string>, never, Attribute<string>>;

// @public (undocumented)
const _default_25: Rule.Atomic<Page, Attribute<string>, never, Attribute<string>>;

// @public (undocumented)
const _default_26: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_27: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_28: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_29: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public
const _default_3: Rule.Atomic<Page, Element<string>, Question.Metadata, Node<string> | Array_2<Node<string>>>;

// @public (undocumented)
const _default_30: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_31: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_32: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_33: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_34: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_35: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_36: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_37: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_38: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_39: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public
const _default_4: Rule.Atomic<Page, Document, Question.Metadata, Document>;

// @public (undocumented)
const _default_40: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_41: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_42: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_43: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_44: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_45: Rule.Atomic<Page, Group<Element<string>>, Question.Metadata, Group<Element<string>>>;

// @public (undocumented)
const _default_46: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_47: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_48: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_49: Rule.Atomic<Page, Attribute<string>, never, Attribute<string>>;

// @public (undocumented)
const _default_5: Rule.Atomic<Page, Document, never, Document>;

// @public (undocumented)
const _default_50: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_51: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_52: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_53: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_54: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_55: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_56: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_57: Rule.Atomic<Page, Group<Element<string>>, Question.Metadata, Group<Element<string>>>;

// @public (undocumented)
const _default_58: Rule.Atomic<Page, Group<Element<string>>, never, Group<Element<string>>>;

// @public (undocumented)
const _default_59: Rule.Atomic<Page, Text, never, Text>;

// @public (undocumented)
const _default_6: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_60: Rule.Atomic<Page, Document, never, Document>;

// @public (undocumented)
const _default_61: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_62: Rule.Atomic<Page, Document, never, Document>;

// @public (undocumented)
const _default_63: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_64: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_65: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_66: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_67: Rule.Atomic<Page, Text, Question.Metadata, Text>;

// @public (undocumented)
const _default_68: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_69: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_7: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_70: Rule.Atomic<Page, Text, Question.Metadata, Text>;

// @public (undocumented)
const _default_71: Rule.Atomic<Page, Document, never, Document>;

// @public (undocumented)
const _default_72: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_73: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_74: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_75: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_76: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_77: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_78: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_79: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_8: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_80: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_81: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_82: Rule.Atomic<Page, Group<Element<string>>, Question.Metadata, Group<Element<string>>>;

// @public (undocumented)
const _default_83: Rule.Atomic<Page, Text, never, Text>;

// @public (undocumented)
const _default_84: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_85: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_86: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_87: Rule.Atomic<Page, Document, Question.Metadata, Document>;

// @public (undocumented)
const _default_88: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_89: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_9: Rule.Atomic<Page, Attribute<string>, never, Attribute<string>>;

// @public (undocumented)
const _default_90: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_91: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_92: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_93: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
const _default_94: Rule.Atomic<Page, Element<string>, never, Element<string>>;

// @public (undocumented)
export namespace Diagnostic {
    const // Warning: (ae-forgotten-export) The symbol "ClippingAncestors" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isClippingAncestors: typeof ClippingAncestors.isClippingAncestors;
    const // Warning: (ae-forgotten-export) The symbol "ColorError" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isColorError: typeof ColorError.isColorError, // (undocumented)
    isColorErrorInterposedDescendants: typeof ColorError.HasInterposedDescendants.isInterposedDescendants, // (undocumented)
    isColorErrorUnresolvableGradientStop: typeof ColorError.HasUnresolvableGradientStop.isUnresolvableGradientStop, // (undocumented)
    isColorErrorWithProperty: typeof ColorError.WithProperty.isWithProperty;
    const // Warning: (ae-forgotten-export) The symbol "Contrast" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isContrast: typeof Contrast.isContrast;
    const // Warning: (ae-forgotten-export) The symbol "DeprecatedElements" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isDeprecatedElements: typeof DeprecatedElements.isDeprecatedElements;
    const // Warning: (ae-forgotten-export) The symbol "DistinguishingStyles" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isDistinguishingStyles: typeof DistinguishingStyles.isDistinguishingStyles;
    const // Warning: (ae-forgotten-export) The symbol "DistinguishingStyles" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isDistinguishingStylesExperimental: typeof DistinguishingStyles_2.isDistinguishingStyles;
    const // Warning: (ae-forgotten-export) The symbol "LabelAndName" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isLabelAndName: typeof LabelAndName.isLabelAndName;
    const // Warning: (ae-forgotten-export) The symbol "Languages" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isLanguages: typeof Languages.isLanguages;
    const // Warning: (ae-forgotten-export) The symbol "RoleAndRequiredAttributes" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isRoleAndRequiredAttributes: typeof RoleAndRequiredAttributes.isRoleAndRequiredAttributes;
    const // Warning: (ae-forgotten-export) The symbol "SameNames" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isSameNames: typeof SameNames.isSameNames;
    const // Warning: (ae-forgotten-export) The symbol "WithRole" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    isWithRole: typeof WithRole.isWithRole;
}

// @public (undocumented)
class Document_2 extends Node_2<"document"> {
    // @internal (undocumented)
    _attachFrame(frame: Element_2): boolean;
    // @internal (undocumented)
    _attachParent(): boolean;
    // (undocumented)
    static empty(): Document_2;
    // (undocumented)
    get frame(): Option<Element_2>;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    static of(children: Iterable<Node_2>, style?: Iterable<Sheet>): Document_2;
    // (undocumented)
    parent(options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    get style(): Iterable<Sheet>;
    // (undocumented)
    toJSON(): Document_2.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Document_2 {
    // @internal (undocumented)
    function fromDocument(json: JSON): Trampoline<Document_2>;
    // (undocumented)
    function isDocument(value: unknown): value is Document_2;
    // (undocumented)
    interface JSON extends Node_2.JSON<"document"> {
        // (undocumented)
        style: Array<Sheet.JSON>;
    }
}

// @public (undocumented)
class Element_2<N extends string = string> extends Node_2<"element"> implements Slot, Slotable {
    // (undocumented)
    assignedNodes(): Iterable_2<Slotable>;
    // (undocumented)
    assignedSlot(): Option<Slot>;
    // @internal (undocumented)
    _attachContent(document: Document_2): boolean;
    // @internal (undocumented)
    _attachShadow(shadow: Shadow): boolean;
    // (undocumented)
    attribute<A extends string = string>(name: A): Option<Attribute_2<A>>;
    // (undocumented)
    attribute<A extends string = string>(predicate: Predicate<Attribute_2<A>>): Option<Attribute_2<A>>;
    // (undocumented)
    get attributes(): Sequence<Attribute_2>;
    // (undocumented)
    children(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    get classes(): Sequence<string>;
    // (undocumented)
    get content(): Option<Document_2>;
    // (undocumented)
    get id(): Option<string>;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    isVoid(): boolean;
    // (undocumented)
    get name(): N;
    // (undocumented)
    get namespace(): Option<Namespace>;
    // (undocumented)
    static of<N extends string = string>(namespace: Option<Namespace>, prefix: Option<string>, name: N, attributes?: Iterable_2<Attribute_2>, children?: Iterable_2<Node_2>, style?: Option<Block>): Element_2<N>;
    // (undocumented)
    parent(options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    get prefix(): Option<string>;
    // (undocumented)
    get qualifiedName(): string;
    // (undocumented)
    get shadow(): Option<Shadow>;
    // (undocumented)
    get style(): Option<Block>;
    // (undocumented)
    tabIndex(): Option<number>;
    // (undocumented)
    toJSON(): Element_2.JSON<N>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Element_2 {
    // @internal (undocumented)
    function fromElement<N extends string = string>(json: JSON<N>): Trampoline<Element_2<N>>;
    // (undocumented)
    function isElement(value: unknown): value is Element_2;
    // (undocumented)
    interface JSON<N extends string = string> extends Node_2.JSON<"element"> {
        // (undocumented)
        attributes: Array<Attribute_2.JSON>;
        // (undocumented)
        content: Document_2.JSON | null;
        // (undocumented)
        name: N;
        // (undocumented)
        namespace: string | null;
        // (undocumented)
        prefix: string | null;
        // (undocumented)
        shadow: Shadow.JSON | null;
        // (undocumented)
        style: Block.JSON | null;
    }
    const // Warning: (ae-forgotten-export) The symbol "predicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasAttribute: typeof predicate_2.hasAttribute, // (undocumented)
    hasDisplaySize: typeof predicate_2.hasDisplaySize, // (undocumented)
    hasId: typeof predicate_2.hasId, // (undocumented)
    hasInputType: typeof predicate_2.hasInputType, // (undocumented)
    hasName: typeof predicate_2.hasName, // (undocumented)
    hasNamespace: typeof predicate_2.hasNamespace, // (undocumented)
    hasTabIndex: typeof predicate_2.hasTabIndex, // (undocumented)
    hasUniqueId: typeof predicate_2.hasUniqueId, // (undocumented)
    isBrowsingContextContainer: typeof predicate_2.isBrowsingContextContainer, // (undocumented)
    isContent: typeof predicate_2.isContent, // (undocumented)
    isDisabled: typeof predicate_2.isDisabled, // (undocumented)
    isDocumentElement: typeof predicate_2.isDocumentElement, // (undocumented)
    isDraggable: typeof predicate_2.isDraggable, // (undocumented)
    isEditingHost: typeof predicate_2.isEditingHost, // (undocumented)
    isFallback: typeof predicate_2.isFallback, // (undocumented)
    isSuggestedFocusable: typeof predicate_2.isSuggestedFocusable, // (undocumented)
    isReplaced: typeof predicate_2.isReplaced;
}

declare namespace experimentalRules {
    export {
        _default as ER62,
        _default_2 as ER87,
        _default_3 as R82,
        _default_4 as R109
    }
}
export { experimentalRules }

// @public (undocumented)
namespace Flattened {
    type Flattened = Sequence<act.Rule<Input, Target, Question, Subject>>;
    type Input = act.Rule.Input<Rule>;
    type Question = act.Rule.Question<Rule>;
    // Warning: (ae-forgotten-export) The symbol "rules" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    type Rule = Record_2.Value<typeof rules>;
    type Subject = act.Rule.Subject<Rule>;
    type Target = act.Rule.Target<Rule>;
        {};
}

// @public
const Flattened: Flattened.Flattened;
export { Flattened }
export default Flattened;

// @public (undocumented)
class FontFaceRule extends Rule_2 {
    // (undocumented)
    static of(declarations: Iterable<Declaration>): FontFaceRule;
    // (undocumented)
    get style(): Block;
    // (undocumented)
    toJSON(): FontFaceRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace FontFaceRule {
    // @internal (undocumented)
    function fromFontFaceRule(json: JSON): Trampoline<FontFaceRule>;
    // (undocumented)
    function isFontFaceRule(value: unknown): value is FontFaceRule;
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        style: Block.JSON;
        // (undocumented)
        type: "font-face";
    }
}

// @public (undocumented)
class Fragment extends Node_2<"fragment"> {
    // @internal (undocumented)
    _attachParent(): boolean;
    // (undocumented)
    static empty(): Fragment;
    // @internal (undocumented)
    protected _internalPath(): string;
    // (undocumented)
    static of(children: Iterable<Node_2>): Fragment;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Fragment {
    // @internal (undocumented)
    function fromFragment(json: JSON): Trampoline<Fragment>;
    // (undocumented)
    function isFragment(value: unknown): value is Fragment;
    // (undocumented)
    interface JSON extends Node_2.JSON<"fragment"> {
    }
}

// Warning: (ae-forgotten-export) The symbol "Options" needs to be exported by the entry point index.d.ts
//
// @public
function getNodesBetween(node1: Node_2, node2: Node_2, includeOptions?: Options, treeOptions?: Node_2.Traversal): Sequence<Node_2>;

// @public (undocumented)
export class Group<T> implements Iterable<T>, Equatable, json.Serializable<Group.JSON<T>>, earl.Serializable<Group.EARL>, sarif.Serializable<sarif.Location> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<T extends earl.Serializable>(members: Iterable<T>): Group<T>;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toEARL(): Group.EARL;
    // (undocumented)
    toJSON(): Group.JSON<T>;
    // (undocumented)
    toSARIF(): sarif.Location;
}

// @public (undocumented)
export namespace Group {
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            ptr: "http://www.w3.org/2009/pointers#";
        };
        // (undocumented)
        "@type": ["ptr:Pointer", "ptr:PointersGroup", "ptr:RelatedPointers"];
        // (undocumented)
        "ptr:groupPointer": {
            "@list": Array_2<earl.EARL>;
        };
    }
    // (undocumented)
    export function isGroup<T extends earl.Serializable>(value: unknown): value is Group<T>;
    // (undocumented)
    export type JSON<T> = Array_2<json.Serializable.ToJSON<T>>;
}

// @public (undocumented)
abstract class GroupingRule extends Rule_2 {
    protected constructor(rules: Array<Rule_2>);
    // (undocumented)
    children(): Iterable<Rule_2>;
    // (undocumented)
    get rules(): Iterable<Rule_2>;
    // (undocumented)
    protected readonly _rules: Array<Rule_2>;
    // (undocumented)
    abstract toJSON(): GroupingRule.JSON;
}

// @public (undocumented)
namespace GroupingRule {
    // (undocumented)
    function isGroupingRule(value: unknown): value is GroupingRule;
    // (undocumented)
    interface JSON extends Rule_2.JSON {
        // (undocumented)
        rules: Array<Rule_2.JSON>;
    }
}

// @public (undocumented)
function h<N extends string = string>(name: N, attributes?: Array<Attribute_2> | Record<string, string | boolean>, children?: Array<Node_2 | string>, style?: Array<Declaration> | Record<string, string>): Element_2<N>;

// @public (undocumented)
namespace h {
    // (undocumented)
    function attribute<N extends string = string>(name: N, value: string): Attribute_2<N>;
    // (undocumented)
    function block(declarations: Array<Declaration> | Record<string, string>): Block;
    // (undocumented)
    function declaration(name: string, value: string, important?: boolean): Declaration;
    // (undocumented)
    function document(children: Array<Node_2 | string>, style?: Array<Sheet>): Document_2;
    // (undocumented)
    function element<N extends string = string>(name: N, attributes?: Array<Attribute_2> | Record<string, string | boolean>, children?: Array<Node_2 | string>, style?: Array<Declaration> | Record<string, string>, namespace?: Namespace): Element_2<N>;
    // (undocumented)
    function fragment(children: Array<Node_2 | string>): Fragment;
    // (undocumented)
    namespace rule {
        // (undocumented)
        function fontFace(declarations: Array<Declaration> | Record<string, string>): FontFaceRule;
        // (undocumented)
        function keyframe(key: string, declarations: Array<Declaration> | Record<string, string>): KeyframeRule;
        // (undocumented)
        function keyframes(name: string, rules: Array<Rule_2>): KeyframesRule;
        // (undocumented)
        function media(condition: string, rules: Array<Rule_2>): MediaRule;
        // (undocumented)
        function namespace(namespace: string, prefix?: string): NamespaceRule;
        // (undocumented)
        function page(selector: string, declarations: Array<Declaration> | Record<string, string>): PageRule;
        // (undocumented)
        function style(selector: string, declarations: Array<Declaration> | Record<string, string>, hint?: boolean): StyleRule;
        // (undocumented)
        function supports(condition: string, rules: Array<Rule_2>): SupportsRule;
    }
    // (undocumented)
    function shadow(children: Array<Node_2 | string>, style?: Array<Sheet>, mode?: Shadow.Mode): Shadow;
    // (undocumented)
    function sheet(rules: Array<Rule_2>, disabled?: boolean, condition?: string): Sheet;
    // (undocumented)
    function text(data: string): Text_2;
    // (undocumented)
    function type<N extends string = string>(name: N, publicId?: string, systemId?: string): Type<N>;
}

// @public (undocumented)
function hasAttribute(predicate: Predicate<Attribute_2>): Predicate<Element_2>;

// @public (undocumented)
function hasAttribute(name: string, value?: Predicate<string>): Predicate<Element_2>;

// @public (undocumented)
function hasChild(predicate: Predicate<Node_2>, options?: Node_2.Traversal): Predicate<Node_2>;

// @public (undocumented)
function hasDescendant(predicate: Predicate<Node_2>, options?: Node_2.Traversal): Predicate<Node_2>;

// @public (undocumented)
function hasDisplaySize(valueOrPredicate: number | Predicate<number>): Predicate<Element_2>;

// @public (undocumented)
function hasId(predicate?: Predicate<string>): Predicate<Element_2>;

// @public (undocumented)
function hasId(id: string, ...rest: Array<string>): Predicate<Element_2>;

// @public (undocumented)
function hasInclusiveDescendant(predicate: Predicate<Node_2>, options?: Node_2.Traversal): Predicate<Node_2>;

// Warning: (ae-forgotten-export) The symbol "InputType" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
function hasInputType(predicate: Predicate<InputType>): Predicate<Element_2>;

// @public (undocumented)
function hasInputType(inputType: InputType, ...rest: Array<InputType>): Predicate<Element_2>;

// @public (undocumented)
function hasName<N extends string = string>(predicate: Refinement<string, N>): Refinement<Attribute_2, Attribute_2<N>>;

// @public (undocumented)
function hasName<N extends string = string>(name: N, ...rest: Array<N>): Refinement<Attribute_2, Attribute_2<N>>;

// @public (undocumented)
function hasName_2<N extends string = string>(predicate: Refinement<string, N>): Refinement<Element_2, Element_2<N>>;

// @public (undocumented)
function hasName_2<N extends string = string>(name: N, ...rest: Array<N>): Refinement<Element_2, Element_2<N>>;

// @public (undocumented)
function hasNamespace(predicate: Predicate<Namespace>): Predicate<Element_2>;

// @public (undocumented)
function hasNamespace(namespace: Namespace, ...rest: Array<Namespace>): Predicate<Element_2>;

// @public (undocumented)
function hasTabIndex(predicate?: Predicate<number>): Predicate<Element_2>;

// @public (undocumented)
function hasTextContent(predicate?: Predicate<string>, options?: Node_2.Traversal): Predicate<Node_2>;

// @public (undocumented)
function hasUniqueId(): Predicate<Element_2>;

// @public (undocumented)
class ImportRule extends ConditionRule {
    // (undocumented)
    get href(): string;
    // (undocumented)
    static of(href: string, sheet: Sheet, condition?: Option<string>): ImportRule;
    // (undocumented)
    get queries(): Media.List;
    // (undocumented)
    get rules(): Iterable<Rule_2>;
    // (undocumented)
    get sheet(): Sheet;
    // (undocumented)
    toJSON(): ImportRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace ImportRule {
    // @internal (undocumented)
    function fromImportRule(json: JSON): Trampoline<ImportRule>;
    // (undocumented)
    function isImportRule(value: unknown): value is ImportRule;
    // (undocumented)
    interface JSON extends ConditionRule.JSON {
        // (undocumented)
        href: string;
        // (undocumented)
        type: "import";
    }
}

// @public (undocumented)
function isBrowsingContextContainer(element: Element_2): boolean;

// @public
function isContent(options?: Node_2.Traversal): Predicate<Node_2>;

// @public (undocumented)
function isDisabled(element: Element_2): boolean;

// @public (undocumented)
function isDocumentElement(value: unknown): value is Element_2<"html">;

// @public (undocumented)
function isDraggable(element: Element_2): boolean;

// @public (undocumented)
function isEditingHost(element: Element_2): boolean;

// @public
function isFallback(node: Node_2): boolean;

// @public (undocumented)
function isReplaced(element: Element_2): element is Element_2<"audio" | "canvas" | "embed" | "iframe" | "img" | "input" | "object" | "video">;

// @public (undocumented)
function isRoot(options?: Node_2.Traversal): Predicate<Node_2>;

// @public (undocumented)
function isSuggestedFocusable(element: Element_2): boolean;

// @public (undocumented)
function jsx<N extends string = string>(name: N, properties?: jsx.Properties | null, ...children: jsx.Children): Element_2<N>;

// @public (undocumented)
namespace jsx {
    // (undocumented)
    type Child = Node_2 | string;
    // (undocumented)
    type Children = (Child | Children)[];
    // (undocumented)
    namespace JSX {
        // Warning: (ae-forgotten-export) The symbol "dom" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        type Element<N extends string = string> = dom.Element<N>;
        // (undocumented)
        interface IntrinsicElements {
            // (undocumented)
            [tag: string]: Properties;
        }
    }
    // (undocumented)
    interface Properties {
        // (undocumented)
        [name: string]: unknown;
        style?: Record<string, string>;
    }
}

// @public (undocumented)
class KeyframeRule extends Rule_2 {
    // (undocumented)
    get key(): string;
    // (undocumented)
    static of(key: string, declarations: Iterable<Declaration>): KeyframeRule;
    // (undocumented)
    get style(): Block;
    // (undocumented)
    toJSON(): KeyframeRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace KeyframeRule {
    // @internal (undocumented)
    function fromKeyframeRule(json: JSON): Trampoline<KeyframeRule>;
    // (undocumented)
    function isKeyframeRule(value: unknown): value is KeyframeRule;
    // (undocumented)
    interface JSON extends Rule_2.JSON {
        // (undocumented)
        key: string;
        // (undocumented)
        style: Block.JSON;
        // (undocumented)
        type: "keyframe";
    }
}

// @public (undocumented)
class KeyframesRule extends GroupingRule {
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(name: string, rules: Iterable<Rule_2>): KeyframesRule;
    // (undocumented)
    toJSON(): KeyframesRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace KeyframesRule {
    // @internal (undocumented)
    function fromKeyframesRule(json: JSON): Trampoline<KeyframesRule>;
    // (undocumented)
    function isKeyframesRule(value: unknown): value is KeyframesRule;
    // (undocumented)
    interface JSON extends GroupingRule.JSON {
        // (undocumented)
        name: string;
        // (undocumented)
        type: "keyframes";
    }
}

// @public (undocumented)
class MediaRule extends ConditionRule {
    // (undocumented)
    static of(condition: string, rules: Iterable_2<Rule_2>): MediaRule;
    // (undocumented)
    get queries(): Media.List;
    // (undocumented)
    toJSON(): MediaRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace MediaRule {
    // @internal (undocumented)
    function fromMediaRule(json: JSON): Trampoline<MediaRule>;
    // (undocumented)
    function isMediaRule(value: unknown): value is MediaRule;
    // (undocumented)
    interface JSON extends ConditionRule.JSON {
        // (undocumented)
        type: "media";
    }
}

// @public (undocumented)
enum Namespace {
    // (undocumented)
    HTML = "http://www.w3.org/1999/xhtml",
    // (undocumented)
    MathML = "http://www.w3.org/1998/Math/MathML",
    // (undocumented)
    SVG = "http://www.w3.org/2000/svg",
    // (undocumented)
    XLink = "http://www.w3.org/1999/xlink",
    // (undocumented)
    XML = "http://www.w3.org/XML/1998/namespace",
    // (undocumented)
    XMLNS = "http://www.w3.org/2000/xmlns/"
}

// @public (undocumented)
namespace Namespace {
    // (undocumented)
    function isNamespace(value: string): value is Namespace;
}

// @public (undocumented)
class NamespaceRule extends Rule_2 {
    // (undocumented)
    get namespace(): string;
    // (undocumented)
    static of(namespace: string, prefix: Option<string>): NamespaceRule;
    // (undocumented)
    get prefix(): Option<string>;
    // (undocumented)
    toJSON(): NamespaceRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace NamespaceRule {
    // @internal (undocumented)
    function fromNamespaceRule(json: JSON): Trampoline<NamespaceRule>;
    // (undocumented)
    function isNamespaceRule(value: unknown): value is NamespaceRule;
    // (undocumented)
    interface JSON extends Rule_2.JSON {
        // (undocumented)
        namespace: string;
        // (undocumented)
        prefix: string | null;
        // (undocumented)
        type: "namespace";
    }
}

// @public (undocumented)
abstract class Node_2<T extends string = string> extends tree.Node<Node_2.Traversal.Flag, T> implements earl.Serializable<Node_2.EARL>, json.Serializable<tree.Node.JSON<T>>, sarif.Serializable<sarif.Location> {
    protected constructor(children: Array<Node_2>, type: T);
    // (undocumented)
    equals(value: Node_2): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    path(options?: Node_2.Traversal): string;
    tabOrder(): Sequence<Element_2>;
    // (undocumented)
    textContent(options?: Node_2.Traversal): string;
    // (undocumented)
    toEARL(): Node_2.EARL;
    // (undocumented)
    toSARIF(): sarif.Location;
}

// @public (undocumented)
interface Node_2 {
    // (undocumented)
    ancestors(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    children(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    closest<T extends Node_2>(refinement: Refinement<Node_2, T>, options?: Node_2.Traversal): Option<T>;
    // (undocumented)
    closest(predicate: Predicate<Node_2>, options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    descendants(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    first(options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    following(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    inclusiveAncestors(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    inclusiveDescendants(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    inclusiveSiblings(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    index(options?: Node_2.Traversal): number;
    // (undocumented)
    isAncestorOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isChildOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isDescendantOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isInclusiveAncestorOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isInclusiveDescendantsOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isInclusiveSiblingOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isParentOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isRootOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    isSiblingOf(node: Node_2, options?: Node_2.Traversal): boolean;
    // (undocumented)
    last(options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    next(options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    parent(options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    preceding(options?: Node_2.Traversal): Sequence<Node_2>;
    // (undocumented)
    previous(options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    root(options?: Node_2.Traversal): Node_2;
    // (undocumented)
    siblings(options?: Node_2.Traversal): Sequence<Node_2>;
}

// @public (undocumented)
namespace Node_2 {
    // (undocumented)
    interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            ptr: "http://www.w3.org/2009/pointers#";
        };
        // (undocumented)
        "@type": [
        "ptr:Pointer",
        "ptr:SinglePointer",
        "ptr:ExpressionPointer",
        "ptr:XPathPointer"
        ];
        // (undocumented)
        "ptr:expression": string;
        // (undocumented)
        "ptr:reference"?: {
            "@id": string;
        };
    }
    // (undocumented)
    function from(json: Element_2.JSON): Element_2;
    // (undocumented)
    function from(json: Attribute_2.JSON): Attribute_2;
    // (undocumented)
    function from(json: Text_2.JSON): Text_2;
    // (undocumented)
    function from(json: Comment.JSON): Comment;
    const flatTree: Traversal;
    const fullTree: Traversal;
    const composedNested: Traversal;
    // (undocumented)
    function from(json: Document_2.JSON): Document_2;
    // (undocumented)
    function from(json: Type.JSON): Document_2;
    // (undocumented)
    function from(json: Fragment.JSON): Fragment;
    // (undocumented)
    function from(json: JSON): Node_2;
    // @internal (undocumented)
    function fromNode(json: JSON): Trampoline<Node_2>;
    // (undocumented)
    function isNode(value: unknown): value is Node_2;
    // (undocumented)
    interface JSON<T extends string = string> extends tree.Node.JSON<T> {
    }
    // (undocumented)
    class Traversal extends Flags<Traversal.Flag> {
        // (undocumented)
        static of(...flags: Array<Traversal.Flag>): Traversal;
    }
    // (undocumented)
    namespace Traversal {
        // (undocumented)
        type Flag = 0 | 1 | 2 | 4;
        const // (undocumented)
        none: Flag;
        const composed: Flag;
        const flattened: Flag;
        const nested: Flag;
        const // (undocumented)
        empty: Traversal;
    }
    const // Warning: (ae-forgotten-export) The symbol "traversal" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    getNodesBetween: typeof traversal.getNodesBetween;
    const // Warning: (ae-forgotten-export) The symbol "predicate" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    hasChild: typeof predicate_3.hasChild, // (undocumented)
    hasDescendant: typeof predicate_3.hasDescendant, // (undocumented)
    hasInclusiveDescendant: typeof predicate_3.hasInclusiveDescendant, // (undocumented)
    hasTextContent: typeof predicate_3.hasTextContent, // (undocumented)
    isRoot: typeof predicate_3.isRoot;
}

// @public (undocumented)
class PageRule extends Rule_2 {
    // (undocumented)
    static of(selector: string, declarations: Iterable<Declaration>): PageRule;
    // (undocumented)
    get selector(): string;
    // (undocumented)
    get style(): Block;
    // (undocumented)
    toJSON(): PageRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace PageRule {
    // @internal (undocumented)
    function fromPageRule(json: JSON): Trampoline<PageRule>;
    // (undocumented)
    function isPageRule(value: unknown): value is PageRule;
    // (undocumented)
    interface JSON extends Rule_2.JSON {
        // (undocumented)
        selector: string;
        // (undocumented)
        style: Block.JSON;
        // (undocumented)
        type: "page";
    }
}

// @public (undocumented)
export namespace Question {
    // (undocumented)
    export type Data = typeof Data & Record<Uri, {
        readonly type: keyof Type;
        readonly message: string;
    }>;
    export type Metadata = {
        [U in Uri]: [TypeName<U>, Typeof<U>];
    };
    // (undocumented)
    export function of<S, U extends Uri = Uri>(uri: U, subject: S, message?: string, options?: act.Question.Options<Typeof<U>>): act.Question<TypeName<U>, S, S, Typeof<U>, Typeof<U>, U>;
    // (undocumented)
    export function of<S, C, U extends Uri = Uri>(uri: U, subject: S, context: C, message?: string, options?: act.Question.Options<Typeof<U>>): act.Question<TypeName<U>, S, C, Typeof<U>, Typeof<U>, U>;
    export interface Type {
        // (undocumented)
        "color[]": Iterable<RGB>;
        // (undocumented)
        "node[]": Iterable<Node>;
        // (undocumented)
        "string[]": Iterable<string>;
        // (undocumented)
        boolean: boolean;
        // (undocumented)
        node: Option<Node>;
        // (undocumented)
        string: string;
    }
    // (undocumented)
    export type TypeName<U extends Uri> = Data[U]["type"];
    // (undocumented)
    export type Typeof<U extends Uri> = Type[TypeName<U>];
    // (undocumented)
    export type Uri = keyof typeof Data;
    const // (undocumented)
    Data: {
        readonly "reference-equivalent-resources": {
            readonly type: "boolean";
            readonly message: "Do the [links/iframe] [resolve to/reference] equivalent resources?";
        };
        readonly "has-audio": {
            readonly type: "boolean";
            readonly message: "Does the `<video>` element have audio?";
        };
        readonly "has-audio-track": {
            readonly type: "boolean";
            readonly message: "Does the `<video>` element have an audio track that describes its visual information?";
        };
        readonly "has-captions": {
            readonly type: "boolean";
            readonly message: "Does the `<video>` element have captions?";
        };
        readonly "has-description": {
            readonly type: "boolean";
            readonly message: "Is the visual information of the [audio/video] available through its audio or a separate audio description track?";
        };
        readonly "is-audio-streaming": {
            readonly type: "boolean";
            readonly message: "Is the `<audio>` element streaming?";
        };
        readonly "is-playing": {
            readonly type: "boolean";
            readonly message: "Is the `<audio>` element currently playing?";
        };
        readonly "is-video-streaming": {
            readonly type: "boolean";
            readonly message: "Is the `<video>` element streaming?";
        };
        readonly label: {
            readonly type: "node";
            readonly message: "Where is the text that labels the [audio/video] element as a video alternative?";
        };
        readonly "play-button": {
            readonly type: "node";
            readonly message: "Where is the button that controls playback of the `<audio>` element?";
        };
        readonly "text-alternative": {
            readonly type: "node";
            readonly message: "Where is the text alternative of the [audio/video] element?";
        };
        readonly "track-describes-video": {
            readonly type: "boolean";
            readonly message: "Does at least 1 track describe the visual information of the `<video>` element, either in the language of the `<video>` element or the language of the page?";
        };
        readonly transcript: {
            readonly type: "node";
            readonly message: "Where is the transcript of the [audio/video] element?";
        };
        readonly "transcript-link": {
            readonly type: "node";
            readonly message: "Where is the link pointing to the transcript of the [audio/video]\n                  element?";
        };
        readonly "transcript-perceivable": {
            readonly type: "boolean";
            readonly message: "Is the transcript of the [audio/video] element perceivable?";
        };
        readonly "name-describes-purpose": {
            readonly type: "boolean";
            readonly message: "Does the accessible name of the `<(target.name]>` element describe its purpose?";
        };
        readonly "audio-control-mechanism": {
            readonly type: "node";
            readonly message: "Where is the mechanism that can pause or stop the audio of the `<[target.name]>` element?";
        };
        readonly "is-above-duration-threshold": {
            readonly type: "boolean";
            readonly message: "Does the `<[element.name]>` element have a duration of more than 3 seconds?";
        };
        readonly "is-below-audio-duration-threshold": {
            readonly type: "boolean";
            readonly message: "Does the `<[target.name]>` element have a total audio duration of less than 3 seconds?";
        };
        readonly "is-content-equivalent": {
            readonly type: "boolean";
            readonly message: "Do these [role] landmarks have the same or equivalent content?";
        };
        readonly "visible-focus-classes": {
            readonly type: "string[]";
            readonly message: "Which classes have a visible focus indicator?";
        };
        readonly "has-focus-indicator": {
            readonly type: "boolean";
            readonly message: "Does the element have a visible focus indicator?";
        };
        readonly "background-colors": {
            readonly type: "color[]";
            readonly message: "What are the background colors of the text node?";
        };
        readonly "foreground-colors": {
            readonly type: "color[]";
            readonly message: "What are the foreground colors of the text node?";
        };
        readonly "first-tabbable-is-internal-link": {
            readonly type: "boolean";
            readonly message: "Is the first tabbable element of the document an internal link?";
        };
        readonly "first-tabbable-is-visible": {
            readonly type: "boolean";
            readonly message: "Is the first tabbable element of the document visible if it's focused?";
        };
        readonly "first-tabbable-reference": {
            readonly type: "node";
            readonly message: "Where in the document does the first tabbable element point?";
        };
        readonly "first-tabbable-reference-is-main": {
            readonly type: "boolean";
            readonly message: "Does the first tabbable element of the document point to the main content?";
        };
        readonly "error-indicators": {
            readonly type: "node[]";
            readonly message: "Where are (all) the error indicators, if any, for the form field?";
        };
        readonly "error-indicator-describing-resolution": {
            readonly type: "node";
            readonly message: "Which of these error indicators describes, in text, the cause of the error or how to resolve it?";
        };
        readonly "error-indicator-identifying-form-field": {
            readonly type: "node";
            readonly message: "Which of these error indicators identifies, in text, the form field it relates to?";
        };
        readonly "internal-reference": {
            readonly type: "node";
            readonly message: "Where in the document does this element point?";
        };
        readonly "is-start-of-main": {
            readonly type: "boolean";
            readonly message: "Is this element at the start of the main content of the document?";
        };
        readonly "is-visible-when-focused": {
            readonly type: "boolean";
            readonly message: "Is this element visible when it's focused?";
        };
        readonly "document-language": {
            readonly type: "string";
            readonly message: "What is the main language of the document?";
        };
    };
        {};
}

// @public (undocumented)
abstract class Rule_2 implements Equatable, Serializable {
    protected constructor();
    // (undocumented)
    ancestors(): Iterable<Rule_2>;
    // @internal (undocumented)
    _attachOwner(owner: Sheet): boolean;
    // @internal (undocumented)
    _attachParent(parent: Rule_2): boolean;
    // (undocumented)
    children(): Iterable<Rule_2>;
    // (undocumented)
    descendants(): Iterable<Rule_2>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    inclusiveAncestors(): Iterable<Rule_2>;
    // (undocumented)
    get owner(): Option<Sheet>;
    // (undocumented)
    protected _owner: Option<Sheet>;
    // (undocumented)
    get parent(): Option<Rule_2>;
    // (undocumented)
    protected _parent: Option<Rule_2>;
    // (undocumented)
    abstract toJSON(): Rule_2.JSON;
}

// @public (undocumented)
namespace Rule_2 {
    // (undocumented)
    function from(json: StyleRule.JSON): StyleRule;
    // (undocumented)
    function from(json: ImportRule.JSON): ImportRule;
    // (undocumented)
    function from(json: MediaRule.JSON): MediaRule;
    // (undocumented)
    function from(json: FontFaceRule.JSON): FontFaceRule;
    // (undocumented)
    function from(json: PageRule.JSON): PageRule;
    // (undocumented)
    function from(json: KeyframeRule.JSON): KeyframeRule;
    // (undocumented)
    function from(json: KeyframesRule.JSON): KeyframesRule;
    // (undocumented)
    function from(json: NamespaceRule.JSON): NamespaceRule;
    // (undocumented)
    function from(json: SupportsRule.JSON): SupportsRule;
    // (undocumented)
    function from(json: JSON): Rule_2;
    // @internal (undocumented)
    function fromRule(json: JSON): Trampoline<Rule_2>;
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: string;
    }
}

// @public (undocumented)
export type Rules = typeof Rules;

// @public
export const Rules: Record_2<typeof rules>;

// @public (undocumented)
export class Scope<S extends string = string> extends Tag<"scope"> {
    // (undocumented)
    equals(value: Scope): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<S extends string>(scope: S): Scope<S>;
    // (undocumented)
    get scope(): S;
    // (undocumented)
    toJSON(): Scope.JSON<S>;
    // (undocumented)
    get type(): "scope";
}

// @public (undocumented)
export namespace Scope {
    // (undocumented)
    export interface JSON<S extends string = string> extends Tag.JSON<"scope"> {
        // (undocumented)
        scope: S;
    }
    const Page: Scope<"page">;
    const Component: Scope<"component">;
}

// @public (undocumented)
class Shadow extends Node_2<"shadow"> {
    // @internal (undocumented)
    _attachHost(host: Element_2): boolean;
    // @internal (undocumented)
    _attachParent(): boolean;
    // (undocumented)
    static empty(): Shadow;
    // (undocumented)
    get host(): Option<Element_2>;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    get mode(): Shadow.Mode;
    // (undocumented)
    static of(children: Iterable<Node_2>, style?: Iterable<Sheet>, mode?: Shadow.Mode): Shadow;
    // (undocumented)
    parent(options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    get style(): Iterable<Sheet>;
    // (undocumented)
    toJSON(): Shadow.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Shadow {
    // @internal (undocumented)
    function fromShadow(json: JSON): Trampoline<Shadow>;
    // (undocumented)
    function isShadow(value: unknown): value is Shadow;
    // (undocumented)
    interface JSON extends Node_2.JSON {
        // (undocumented)
        mode: string;
        // (undocumented)
        style: Array<Sheet.JSON>;
        // (undocumented)
        type: "shadow";
    }
    // (undocumented)
    enum Mode {
        // (undocumented)
        Closed = "closed",
        // (undocumented)
        Open = "open"
    }
}

// @public (undocumented)
class Sheet implements Equatable, Serializable {
    // (undocumented)
    children(): Iterable<Rule_2>;
    // (undocumented)
    get condition(): Option<string>;
    // (undocumented)
    descendants(): Iterable<Rule_2>;
    // (undocumented)
    get disabled(): boolean;
    // (undocumented)
    static empty(): Sheet;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(rules: Iterable<Rule_2>, disabled?: boolean, condition?: Option<string>): Sheet;
    // (undocumented)
    get rules(): Iterable<Rule_2>;
    // (undocumented)
    toJSON(): Sheet.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Sheet {
    // (undocumented)
    function from(json: JSON): Sheet;
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        condition: string | null;
        // (undocumented)
        disabled: boolean;
        // (undocumented)
        rules: Array<Rule_2.JSON>;
    }
}

// @public (undocumented)
interface Slot extends Element_2 {
    assignedNodes(): Iterable<Slotable>;
}

// @public (undocumented)
namespace Slot {
    // (undocumented)
    function findSlotables(slot: Slot): Iterable<Slotable>;
    // (undocumented)
    function isSlot(element: Element_2): boolean;
    // (undocumented)
    function isSlot(value: unknown): value is Slot;
    // (undocumented)
    function name(slot: Slot): string;
}

// @public (undocumented)
interface Slotable extends Node_2 {
    assignedSlot(): Option<Slot>;
}

// @public (undocumented)
namespace Slotable {
    // (undocumented)
    function findSlot(slotable: Slotable): Option<Slot>;
    // (undocumented)
    function isSlotable(value: unknown): value is Slotable;
    // (undocumented)
    function name(slotable: Slotable): string;
}

// @public (undocumented)
export class Stability<S extends string = string> extends Tag<"stability"> {
    // (undocumented)
    equals(value: Stability): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<S extends string>(stability: S): Stability<S>;
    // (undocumented)
    get stability(): S;
    // (undocumented)
    toJSON(): Stability.JSON<S>;
    // (undocumented)
    get type(): "stability";
}

// @public (undocumented)
export namespace Stability {
    // (undocumented)
    export interface JSON<S extends string = string> extends Tag.JSON<"stability"> {
        // (undocumented)
        stability: S;
    }
    const Experimental: Stability<"experimental">;
    const Stable: Stability<"stable">;
}

// @public (undocumented)
class StyleRule extends Rule_2 {
    // (undocumented)
    get hint(): boolean;
    // (undocumented)
    static of(selector: string, declarations: Iterable<Declaration>, hint?: boolean): StyleRule;
    // (undocumented)
    get selector(): string;
    // (undocumented)
    get style(): Block;
    // (undocumented)
    toJSON(): StyleRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace StyleRule {
    // @internal (undocumented)
    function fromStyleRule(json: JSON): Trampoline<StyleRule>;
    // (undocumented)
    function isStyleRule(value: unknown): value is StyleRule;
    // (undocumented)
    interface JSON extends Rule_2.JSON {
        // (undocumented)
        selector: string;
        // (undocumented)
        style: Block.JSON;
        // (undocumented)
        type: "style";
    }
}

// @public (undocumented)
class SupportsRule extends ConditionRule {
    // (undocumented)
    static of(condition: string, rules: Iterable<Rule_2>): SupportsRule;
    // (undocumented)
    toJSON(): SupportsRule.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace SupportsRule {
    // @internal (undocumented)
    function fromSupportsRule(json: JSON): Trampoline<SupportsRule>;
    // (undocumented)
    function isSupportsRue(value: unknown): value is SupportsRule;
    // (undocumented)
    interface JSON extends ConditionRule.JSON {
        // (undocumented)
        type: "supports";
    }
}

// @public (undocumented)
class Text_2 extends Node_2<"text"> implements Slotable {
    // (undocumented)
    assignedSlot(): Option<Slot>;
    // (undocumented)
    get data(): string;
    // (undocumented)
    static empty(): Text_2;
    // @internal (undocumented)
    protected _internalPath(options?: Node_2.Traversal): string;
    // (undocumented)
    static of(data: string): Text_2;
    // (undocumented)
    parent(options?: Node_2.Traversal): Option<Node_2>;
    // (undocumented)
    toJSON(): Text_2.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Text_2 {
    // @internal (undocumented)
    function fromText(json: JSON): Trampoline<Text_2>;
    // (undocumented)
    function isText(value: unknown): value is Text_2;
    // (undocumented)
    interface JSON extends Node_2.JSON<"text"> {
        // (undocumented)
        data: string;
    }
}

// @public (undocumented)
class Type<N extends string = string> extends Node_2<"type"> {
    // (undocumented)
    static empty(): Type;
    // (undocumented)
    get name(): N;
    // (undocumented)
    static of<N extends string = string>(name: N, publicId?: Option<string>, systemId?: Option<string>): Type<N>;
    // (undocumented)
    get publicId(): Option<string>;
    // (undocumented)
    get systemId(): Option<string>;
    // (undocumented)
    toJSON(): Type.JSON<N>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Type {
    // @internal (undocumented)
    function fromType<N extends string = string>(json: JSON<N>): Trampoline<Type<N>>;
    // (undocumented)
    function isType(value: unknown): value is Type;
    // (undocumented)
    interface JSON<N extends string = string> extends Node_2.JSON<"type"> {
        // (undocumented)
        name: N;
        // (undocumented)
        publicId: string | null;
        // (undocumented)
        systemId: string | null;
    }
}

// @public (undocumented)
export class Version<N extends number = number> extends Tag<"version"> {
    // (undocumented)
    equals(value: Version): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<N extends number>(version: N): Version<N>;
    // (undocumented)
    toJSON(): Version.JSON<N>;
    // (undocumented)
    get type(): "version";
    // (undocumented)
    get version(): N;
}

// @public (undocumented)
export namespace Version {
    // (undocumented)
    export function isVersion<T extends string>(value: unknown, type?: T): value is Version;
    // (undocumented)
    export interface JSON<N extends number = number> extends Tag.JSON<"version"> {
        // (undocumented)
        version: N;
    }
}

// (No @packageDocumentation comment for this package)

```
