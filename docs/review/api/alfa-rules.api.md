## API Report File for "@siteimprove/alfa-rules"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as act from '@siteimprove/alfa-act';
import * as aria from '@siteimprove/alfa-aria';
import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Attribute } from '@siteimprove/alfa-dom';
import { Comparable } from '@siteimprove/alfa-comparable';
import { Comparison } from '@siteimprove/alfa-comparable';
import { Computed } from '@siteimprove/alfa-style/src/property/background-color';
import { Computed as Computed_2 } from '@siteimprove/alfa-style/src/property/background-size';
import { Computed as Computed_3 } from '@siteimprove/alfa-style/src/property/background-image';
import { Computed as Computed_4 } from '@siteimprove/alfa-style/src/property/color';
import { Computed as Computed_5 } from '@siteimprove/alfa-style/src/property/text-shadow';
import { Context } from '@siteimprove/alfa-selector';
import { Current } from '@siteimprove/alfa-css';
import { Declaration } from '@siteimprove/alfa-dom';
import { Device } from '@siteimprove/alfa-device';
import { Diagnostic as Diagnostic_2 } from '@siteimprove/alfa-act';
import { Document } from '@siteimprove/alfa-dom';
import * as earl from '@siteimprove/alfa-earl';
import { Element } from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Err } from '@siteimprove/alfa-result';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Language } from '@siteimprove/alfa-iana';
import { Length } from '@siteimprove/alfa-css';
import { List } from '@siteimprove/alfa-list';
import { Map as Map_2 } from '@siteimprove/alfa-map';
import { Node } from '@siteimprove/alfa-dom';
import { Ok } from '@siteimprove/alfa-result';
import { Option } from '@siteimprove/alfa-option';
import { Page } from '@siteimprove/alfa-web';
import { Percentage } from '@siteimprove/alfa-css';
import { Property } from '@siteimprove/alfa-style';
import { Record as Record_2 } from '@siteimprove/alfa-record';
import { Result } from '@siteimprove/alfa-result';
import { RGB } from '@siteimprove/alfa-css';
import { Role } from '@siteimprove/alfa-aria';
import { Rule } from '@siteimprove/alfa-act';
import * as sarif from '@siteimprove/alfa-sarif';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Serializable } from '@siteimprove/alfa-json';
import { Set as Set_2 } from '@siteimprove/alfa-set';
import { Specified } from '@siteimprove/alfa-style/src/property/position';
import { Style } from '@siteimprove/alfa-style';
import { System } from '@siteimprove/alfa-css';
import { Tag } from '@siteimprove/alfa-act';
import { Text } from '@siteimprove/alfa-dom';

// @public (undocumented)
type Background = ReadonlyArray<Color.Resolved>;

// @public (undocumented)
class ClippingAncestors extends Diagnostic_2 {
    // (undocumented)
    equals(value: ClippingAncestors): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get horizontal(): Option<Element>;
    // (undocumented)
    static of(message: string, horizontal?: Option<Element>, vertical?: Option<Element>): ClippingAncestors;
    // (undocumented)
    toJSON(): ClippingAncestors.JSON;
    // (undocumented)
    get vertical(): Option<Element>;
}

// @public (undocumented)
namespace ClippingAncestors {
    // (undocumented)
    function isClippingAncestors(value: Diagnostic_2): value is ClippingAncestors;
    // (undocumented)
    function isClippingAncestors(value: unknown): value is ClippingAncestors;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        horizontal: Option.JSON<Element>;
        // (undocumented)
        vertical: Option.JSON<Element>;
    }
}

// @public (undocumented)
namespace Color {
    // (undocumented)
    function composite(foreground: Resolved, background: Resolved, opacity: number): Resolved;
    // (undocumented)
    type Computed = RGB<Percentage, Percentage> | Current | System;
    // (undocumented)
    function resolve(color: Computed, style: Style): Option<Resolved>;
    // (undocumented)
    type Resolved = RGB<Percentage, Percentage>;
}

// Warning: (ae-forgotten-export) The symbol "ErrorName" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
abstract class ColorError<out T extends keyof ErrorName = keyof ErrorName, out K extends ErrorName[T] = ErrorName[T]> extends Diagnostic_2 {
    protected constructor(message: string, element: Element, type: T, kind: K);
    // (undocumented)
    get element(): Element;
    // (undocumented)
    protected readonly _element: Element;
    // (undocumented)
    equals(value: ColorError): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): K;
    // (undocumented)
    protected readonly _kind: K;
    // (undocumented)
    toJSON(): ColorError.JSON<T, K>;
    // (undocumented)
    get type(): T;
    // (undocumented)
    protected readonly _type: T;
}

// @public (undocumented)
namespace ColorError {
    class HasInterposedDescendants extends ColorError<"layer", "interposed-descendant"> {
        // (undocumented)
        equals(value: HasInterposedDescendants): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(message: string): Diagnostic_2;
        // (undocumented)
        static of(message: string, element: Element, positionedDescendants: Iterable<Element>): HasInterposedDescendants;
        // (undocumented)
        get positionedDescendants(): Iterable<Element>;
        // (undocumented)
        toJSON(): HasInterposedDescendants.JSON;
    }
    // (undocumented)
    namespace HasInterposedDescendants {
        // (undocumented)
        function from(offsetParent: Element, positionedDescendants: Iterable<Element>): HasInterposedDescendants;
        // (undocumented)
        function isInterposedDescendants(value: Diagnostic_2): value is HasInterposedDescendants;
        // (undocumented)
        function isInterposedDescendants(value: unknown): value is HasInterposedDescendants;
        // (undocumented)
        interface JSON extends ColorError.JSON<"layer", "interposed-descendant"> {
            // (undocumented)
            positionedDescendants: Sequence.JSON<Element>;
        }
    }
    class HasUnresolvableGradientStop extends WithProperty<"layer", "unresolvable-gradient", "background-image"> {
        // (undocumented)
        get color(): Color.Computed;
        // (undocumented)
        static create(element: Element, value: Style.Computed<"background-image">, color: Color.Computed): HasUnresolvableGradientStop;
        // (undocumented)
        equals(value: HasUnresolvableGradientStop): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        toJSON(): HasUnresolvableGradientStop.JSON;
    }
    // (undocumented)
    namespace HasUnresolvableGradientStop {
        // (undocumented)
        function isUnresolvableGradientStop(value: Diagnostic_2): value is HasUnresolvableGradientStop;
        // (undocumented)
        function isUnresolvableGradientStop(value: unknown): value is HasUnresolvableGradientStop;
        // (undocumented)
        interface JSON extends WithProperty.JSON<"layer", "unresolvable-gradient", "background-image"> {
            // (undocumented)
            color: Serializable.ToJSON<Color.Computed>;
        }
    }
    // (undocumented)
    function isColorError<T extends keyof ErrorName = keyof ErrorName, K extends ErrorName[T] = ErrorName[T]>(value: Diagnostic_2): value is ColorError<T, K>;
    const // (undocumented)
    isWithProperty: typeof WithProperty.isWithProperty;
    const // (undocumented)
    unresolvableBackgroundColor: (element: Element, value: Computed) => WithProperty<"layer", "unresolvable-background-color", "background-color">;
    const // (undocumented)
    backgroundSize: (element: Element, value: Computed_2) => WithProperty<"layer", "background-size", "background-size">;
    const // (undocumented)
    externalBackgroundImage: (element: Element, value: Computed_3) => WithProperty<"layer", "background-image", "background-image">;
    const // (undocumented)
    nonStaticPosition: (element: Element, value: Specified) => WithProperty<"layer", "non-static", "position">;
    const // (undocumented)
    unresolvableForegroundColor: (element: Element, value: Computed_4) => WithProperty<"foreground", "unresolvable-foreground-color", "color">;
    const // (undocumented)
    textShadow: (element: Element, value: Computed_5) => WithProperty<"background", "text-shadow", "text-shadow">;
    // (undocumented)
    function isColorError<T extends keyof ErrorName = keyof ErrorName, K extends ErrorName[T] = ErrorName[T]>(value: unknown): value is ColorError<T, K>;
    // (undocumented)
    interface JSON<T extends keyof ErrorName = keyof ErrorName, K extends ErrorName[T] = ErrorName[T]> extends Diagnostic_2.JSON {
        // (undocumented)
        element: Element.JSON;
        // (undocumented)
        kind: K;
        // (undocumented)
        type: T;
    }
    const // (undocumented)
    unresolvableGradientStop: typeof HasUnresolvableGradientStop.create, // (undocumented)
    isUnresolvableGradientStop: typeof HasUnresolvableGradientStop.isUnresolvableGradientStop;
    // @internal
    class WithProperty<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow"> extends ColorError<T, K> {
        protected constructor(message: string, type: T, kind: K, element: Element, proprety: N, value: Style.Computed<N>);
        // (undocumented)
        equals(value: WithProperty<T, K, N>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(message: string): Diagnostic_2;
        // (undocumented)
        static of<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow">(message: string, diagnostic: {
            type: T;
            kind: K;
            element: Element;
            property: N;
            value: Style.Computed<N>;
        }): WithProperty<T, K, N>;
        // (undocumented)
        get property(): N;
        // (undocumented)
        toJSON(): WithProperty.JSON<T, K, N>;
        // (undocumented)
        get value(): Style.Computed<N>;
    }
    // (undocumented)
    namespace WithProperty {
        // (undocumented)
        function from<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow">(type: T, kind: K, property: N, message: string): (element: Element, value: Style.Computed<N>) => WithProperty<T, K, N>;
        // (undocumented)
        function isWithProperty<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow">(value: Diagnostic_2): value is WithProperty<T, K, N>;
        // (undocumented)
        function isWithProperty<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow">(value: unknown): value is WithProperty<T, K, N>;
        // (undocumented)
        interface JSON<T extends keyof ErrorName, K extends ErrorName[T], N extends "background-color" | "background-image" | "background-size" | "color" | "position" | "text-shadow"> extends ColorError.JSON<T, K> {
            // (undocumented)
            property: N;
            // (undocumented)
            value: Serializable.ToJSON<Style.Computed<N>>;
        }
    }
    const // (undocumented)
    interposedDescendants: typeof HasInterposedDescendants.from, // (undocumented)
    isInterposedDescendants: typeof HasInterposedDescendants.isInterposedDescendants;
}

// @public (undocumented)
class ColorErrors<out T extends keyof ErrorName = keyof ErrorName> extends Diagnostic_2 {
    // (undocumented)
    equals(value: ColorErrors): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get errors(): ReadonlyArray<ColorError<T>>;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(message: string): Diagnostic_2;
    // (undocumented)
    static of<T extends keyof ErrorName = keyof ErrorName>(errors: ReadonlyArray<ColorError<T>>): ColorErrors<T>;
    // (undocumented)
    toJSON(): ColorErrors.JSON<T>;
}

// @public (undocumented)
namespace ColorErrors {
    // (undocumented)
    function isColorErrors<T extends keyof ErrorName = keyof ErrorName>(value: Diagnostic_2): value is ColorErrors<T>;
    // (undocumented)
    function isColorErrors<T extends keyof ErrorName = keyof ErrorName>(value: unknown): value is ColorErrors<T>;
    // (undocumented)
    interface JSON<T extends keyof ErrorName = keyof ErrorName> extends Diagnostic_2.JSON {
        // (undocumented)
        errors: Array_2<ColorError.JSON<T>>;
    }
    // (undocumented)
    function prepend<T extends keyof ErrorName = keyof ErrorName, T1 extends T = T, T2 extends T = T>(old: Result<unknown, ColorErrors<T1>>, cur: Iterable<ColorError<T2>>): ColorErrors<T>;
}

// @public (undocumented)
class ComputedStyles implements Equatable, Hashable, Serializable {
    // (undocumented)
    equals(value: ComputedStyles): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // Warning: (ae-forgotten-export) The symbol "Name" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static of(style?: Iterable<readonly [Name, string]>): ComputedStyles;
    // (undocumented)
    get style(): Map_2<Name, string>;
    // (undocumented)
    toJSON(): ComputedStyles.JSON;
}

// @public (undocumented)
namespace ComputedStyles {
    // (undocumented)
    function from(element: Element, device: Device, context?: Context): ComputedStyles;
    // (undocumented)
    function isComputedStyles(value: unknown): value is ComputedStyles;
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        style: Map_2.JSON<Name, string>;
    }
}

// Warning: (ae-forgotten-export) The symbol "Name" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
class Contrast<N extends Name_3 = Name_3> extends Diagnostic_2 {
    // (undocumented)
    equals(value: Contrast): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<N extends Name_3 = Name_3>(message: string, threshold?: number, pairings?: Iterable<Contrast.Pairing<N>>): Contrast<N>;
    // (undocumented)
    get pairings(): Iterable<Contrast.Pairing<N>>;
    // (undocumented)
    get threshold(): number;
    // (undocumented)
    toJSON(): Contrast.JSON<N>;
}

// @public (undocumented)
namespace Contrast {
    // (undocumented)
    class Color<N extends FirstColor<Name_3> | SecondColor<Name_3>> implements Equatable, Serializable, Hashable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        get name(): N;
        // (undocumented)
        static of<N extends FirstColor<Name_3> | SecondColor<Name_3>>(name: N, value: RGB): Color<N>;
        // (undocumented)
        toJSON(): Color.JSON<N>;
        // (undocumented)
        get value(): RGB;
    }
    // (undocumented)
    namespace Color {
        // (undocumented)
        interface JSON<N extends FirstColor<Name_3> | SecondColor<Name_3>> {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            name: N;
            // (undocumented)
            value: RGB.JSON;
        }
    }
    // (undocumented)
    function isContrast<N extends Name_3>(value: Diagnostic_2): value is Contrast<N>;
    // (undocumented)
    function isContrast<N extends Name_3>(value: unknown): value is Contrast<N>;
    // (undocumented)
    interface JSON<N extends Name_3> extends Diagnostic_2.JSON {
        // (undocumented)
        pairings: Array<Pairing.JSON<N>>;
        // (undocumented)
        threshold: number;
    }
    // (undocumented)
    class Pairing<N extends Name_3 = Name_3> implements Equatable, Serializable, Hashable, Comparable<Pairing<N>> {
        // (undocumented)
        get color1(): Color<FirstColor<N>>;
        // (undocumented)
        get color2(): Color<SecondColor<N>>;
        // (undocumented)
        compare(value: Pairing<N>): Comparison;
        // (undocumented)
        get contrast(): number;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // Warning: (ae-forgotten-export) The symbol "FirstColor" needs to be exported by the entry point index.d.ts
        // Warning: (ae-forgotten-export) The symbol "SecondColor" needs to be exported by the entry point index.d.ts
        //
        // (undocumented)
        static of<N extends Name_3 = Name_3>(color1: [FirstColor<N>, RGB], color2: [SecondColor<N>, RGB], contrast: number): Pairing<N>;
        // (undocumented)
        toJSON(): Pairing.JSON<N>;
    }
    // (undocumented)
    namespace Pairing {
        // (undocumented)
        interface JSON<N extends Name_3> {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            color1: Color.JSON<FirstColor<N>>;
            // (undocumented)
            color2: Color.JSON<SecondColor<N>>;
            // (undocumented)
            contrast: number;
        }
    }
        {};
}

// @public (undocumented)
const _default: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public @deprecated (undocumented)
const _default_10: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_100: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_101: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_102: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public @deprecated (undocumented)
const _default_11: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_12: Rule.Atomic<Page, Document, {}, Document>;

// @public (undocumented)
const _default_13: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_14: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_15: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_16: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public (undocumented)
const _default_17: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_18: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public (undocumented)
const _default_19: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_2: Rule.Atomic<Page, Text, Question.Metadata, Text | Group<Element<string>>>;

// @public (undocumented)
const _default_20: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_21: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public (undocumented)
const _default_22: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_23: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_24: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_25: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_26: Rule.Atomic<Page, Group<Element<string>>, Question.Metadata, Group<Element<string>>>;

// @public (undocumented)
const _default_27: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_28: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_29: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public (undocumented)
const _default_3: Rule.Atomic<Page, Text, Question.Metadata, Text | Group<Element<string>>>;

// @public (undocumented)
const _default_30: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public (undocumented)
const _default_31: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public (undocumented)
const _default_32: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public (undocumented)
const _default_33: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_34: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_35: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_36: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_37: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_38: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_39: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public
const _default_4: Rule.Atomic<Page, Document, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_40: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_41: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_42: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_43: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_44: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_45: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_46: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_47: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_48: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_49: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public
const _default_5: Rule.Atomic<Page, Element<string>, Question.Metadata, Node<string> | Array_2<Node<string>>>;

// @public (undocumented)
const _default_50: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_51: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_52: Rule.Atomic<Page, Group<Element<string>>, Question.Metadata, Group<Element<string>>>;

// @public (undocumented)
const _default_53: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_54: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_55: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_56: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public (undocumented)
const _default_57: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_58: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_59: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public
const _default_6: Rule.Atomic<Page, Document, Question.Metadata, Document>;

// @public (undocumented)
const _default_60: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_61: Rule.Composite<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_62: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_63: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_64: Rule.Atomic<Page, Group<Element<string>>, Question.Metadata, Group<Element<string>>>;

// @public (undocumented)
const _default_65: Rule.Atomic<Page, Group<Element<string>>, {}, Group<Element<string>>>;

// @public (undocumented)
const _default_66: Rule.Atomic<Page, Text, {}, Text>;

// @public (undocumented)
const _default_67: Rule.Atomic<Page, Document, {}, Document>;

// @public (undocumented)
const _default_68: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_69: Rule.Atomic<Page, Document, {}, Document>;

// @public @deprecated (undocumented)
const _default_7: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public
const _default_70: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_71: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_72: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_73: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_74: Rule.Atomic<Page, Text, Question.Metadata, Text>;

// @public (undocumented)
const _default_75: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_76: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_77: Rule.Atomic<Page, Text, Question.Metadata, Text>;

// @public (undocumented)
const _default_78: Rule.Atomic<Page, Document, {}, Document>;

// @public (undocumented)
const _default_79: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public @deprecated (undocumented)
const _default_8: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_80: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_81: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_82: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_83: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_84: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_85: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_86: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_87: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_88: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_89: Rule.Atomic<Page, Group<Element<string>>, Question.Metadata, Group<Element<string>>>;

// @public @deprecated (undocumented)
const _default_9: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_90: Rule.Atomic<Page, Text, {}, Text>;

// @public (undocumented)
const _default_91: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_92: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_93: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_94: Rule.Atomic<Page, Document, Question.Metadata, Document>;

// @public (undocumented)
const _default_95: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_96: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_97: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_98: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public (undocumented)
const _default_99: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

declare namespace deprecatedRules {
    export {
        _default_7 as DR62,
        _default_8 as DR91,
        _default_9 as DR92,
        _default_10 as DR93,
        _default_11 as DR95
    }
}
export { deprecatedRules }

// @public (undocumented)
export namespace Diagnostic {
    const // Warning: (ae-forgotten-export) The symbol "deprecatedDistinguishingStyles" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    DeprecatedDistinguishingStyles: typeof deprecatedDistinguishingStyles.DistinguishingStyles;
    const // Warning: (ae-forgotten-export) The symbol "languages" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    Languages: typeof languages.Languages;
    const // Warning: (ae-forgotten-export) The symbol "labelAndName" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    LabelAndName: typeof labelAndName.LabelAndName;
    const // Warning: (ae-forgotten-export) The symbol "roleAndRequiredAttributes" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    RoleAndRequiredAttributes: typeof roleAndRequiredAttributes.RoleAndRequiredAttributes;
    const // Warning: (ae-forgotten-export) The symbol "withPreviousHeading" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    WithPreviousHeading: typeof withPreviousHeading.WithPreviousHeading;
    const // Warning: (ae-forgotten-export) The symbol "withRoleAndName" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    WithRoleAndName: typeof withRoleAndName.WithRoleAndName;
    const // Warning: (ae-forgotten-export) The symbol "sameNames" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    SameNames: typeof sameNames.SameNames;
    const // Warning: (ae-forgotten-export) The symbol "withFirstHeading" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    WithFirstHeading: typeof withFirstHeading.WithFirstHeading;
    const // Warning: (ae-forgotten-export) The symbol "distinguishingStyles" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    DistinguishingStyles: typeof distinguishingStyles.DistinguishingStyles;
    const // Warning: (ae-forgotten-export) The symbol "colorError" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    ColorError: typeof colorError.ColorError;
    const // Warning: (ae-forgotten-export) The symbol "matchingClasses" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    MatchingClasses: typeof matchingClasses.MatchingClasses;
    const // Warning: (ae-forgotten-export) The symbol "withDeclaration" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    WithDeclaration: typeof withDeclaration.WithDeclaration;
    const // Warning: (ae-forgotten-export) The symbol "withNextHeading" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    WithNextHeading: typeof withNextHeading.WithNextHeading;
    const // Warning: (ae-forgotten-export) The symbol "clippingAncestors" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    ClippingAncestors: typeof clippingAncestors.ClippingAncestors;
    const // Warning: (ae-forgotten-export) The symbol "diagnostic" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    Contrast: typeof diagnostic.Contrast, // (undocumented)
    TextSpacing: typeof diagnostic.TextSpacing, // (undocumented)
    WithBadElements: typeof diagnostic.WithBadElements, // (undocumented)
    WithRole: typeof diagnostic.WithRole;
}

// Warning: (ae-forgotten-export) The symbol "Name" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
type DistinguishingProperty = Name_2 | "contrast";

// @public (undocumented)
class DistinguishingStyles extends Diagnostic_2 {
    // (undocumented)
    get defaultStyles(): Iterable<Result<ComputedStyles>>;
    // (undocumented)
    equals(value: DistinguishingStyles): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get focusStyles(): Iterable<Result<ComputedStyles>>;
    // (undocumented)
    get hoverStyles(): Iterable<Result<ComputedStyles>>;
    // (undocumented)
    static of(message: string, defaultStyles?: Iterable<Result<ComputedStyles>>, hoverStyles?: Iterable<Result<ComputedStyles>>, focusStyles?: Iterable<Result<ComputedStyles>>): DistinguishingStyles;
    // (undocumented)
    toJSON(): DistinguishingStyles.JSON;
}

// @public (undocumented)
namespace DistinguishingStyles {
    // (undocumented)
    function isDistinguishingStyles(value: Diagnostic_2): value is DistinguishingStyles;
    // (undocumented)
    function isDistinguishingStyles(value: unknown): value is DistinguishingStyles;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        defaultStyle: Sequence.JSON<Result<ComputedStyles>>;
        // (undocumented)
        focusStyle: Sequence.JSON<Result<ComputedStyles>>;
        // (undocumented)
        hoverStyle: Sequence.JSON<Result<ComputedStyles>>;
    }
}

// @public (undocumented)
class DistinguishingStyles_2 extends Diagnostic_2 {
    // (undocumented)
    get defaultStyles(): Iterable<Result<ElementDistinguishable>>;
    // (undocumented)
    equals(value: DistinguishingStyles_2): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get focusStyles(): Iterable<Result<ElementDistinguishable>>;
    // (undocumented)
    get hoverStyles(): Iterable<Result<ElementDistinguishable>>;
    // (undocumented)
    static of(message: string, defaultStyles?: Iterable<Result<ElementDistinguishable>>, hoverStyles?: Iterable<Result<ElementDistinguishable>>, focusStyles?: Iterable<Result<ElementDistinguishable>>): DistinguishingStyles_2;
    // (undocumented)
    toJSON(): DistinguishingStyles_2.JSON;
}

// @public (undocumented)
namespace DistinguishingStyles_2 {
    // (undocumented)
    function isDistinguishingStyles(value: Diagnostic_2): value is DistinguishingStyles_2;
    // (undocumented)
    function isDistinguishingStyles(value: unknown): value is DistinguishingStyles_2;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        defaultStyle: Sequence.JSON<Result<ElementDistinguishable>>;
        // (undocumented)
        focusStyle: Sequence.JSON<Result<ElementDistinguishable>>;
        // (undocumented)
        hoverStyle: Sequence.JSON<Result<ElementDistinguishable>>;
    }
}

// @public (undocumented)
class ElementDistinguishable implements Equatable, Hashable, Serializable {
    // (undocumented)
    get distinguishingProperties(): ReadonlyArray<DistinguishingProperty>;
    // (undocumented)
    equals(value: ElementDistinguishable): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(distinguishingProperties?: Iterable<DistinguishingProperty>, style?: Iterable<readonly [Name_2, string]>, pairings?: Iterable<Contrast.Pairing<["container", "link"]>>): ElementDistinguishable;
    // (undocumented)
    get pairings(): ReadonlyArray<Contrast.Pairing<["container", "link"]>>;
    // (undocumented)
    get style(): Map_2<Name_2, string>;
    // (undocumented)
    toJSON(): ElementDistinguishable.JSON;
    // (undocumented)
    withDistinguishingProperties(distinguishingProperties: ReadonlyArray<DistinguishingProperty>): ElementDistinguishable;
    // (undocumented)
    withPairings(pairings: ReadonlyArray<Contrast.Pairing<["container", "link"]>>): ElementDistinguishable;
    // (undocumented)
    withStyle(...styles: ReadonlyArray<readonly [Name_2, string]>): ElementDistinguishable;
}

// @public (undocumented)
namespace ElementDistinguishable {
    // (undocumented)
    function from(element: Element, device: Device, target: Element, context: Context | undefined, distinguishingProperties: Iterable<DistinguishingProperty>, pairings: Iterable<Contrast.Pairing<["container", "link"]>>): ElementDistinguishable;
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        distinguishingProperties: Array_2<DistinguishingProperty>;
        // (undocumented)
        pairings: Array_2<Contrast.Pairing.JSON<["container", "link"]>>;
        // (undocumented)
        style: Map_2.JSON<Name_2, string>;
    }
}

declare namespace experimentalRules {
    export {
        _default as ER18,
        _default_2 as ER66,
        _default_3 as ER69,
        _default_4 as ER87,
        _default_5 as R82,
        _default_6 as R109
    }
}
export { experimentalRules }

// @public (undocumented)
export namespace Flattened {
    export type Input = {
        [K in Keys]: act.Rule.Input<RulesObject[K]>;
    }[Keys];
    export type Keys = keyof RulesObject;
    export type Question = Question.Metadata;
    export type Rule = act.Rule<Input, Target, Question, Subject>;
    // Warning: (ae-forgotten-export) The symbol "rules" needs to be exported by the entry point index.d.ts
    export type RulesObject = typeof rules;
    export type Subject = {
        [K in Keys]: act.Rule.Subject<RulesObject[K]>;
    }[Keys];
    export type Target = {
        [K in Keys]: act.Rule.Target<RulesObject[K]>;
    }[Keys];
        {};
}

// @public
const FlattenedRules: Sequence<Flattened.Rule>;
export { FlattenedRules }
export default FlattenedRules;

// @public (undocumented)
type Foreground = ReadonlyArray<Color.Resolved>;

// @public
function getBackground(element: Element, device: Device, context?: Context, opacity?: number, ignoredInterposedDescendants?: Set_2<Element>): Result<Background, ColorErrors<"background" | "layer">>;

// @public
function getForeground(element: Element, device: Device, context?: Context, ignoredInterposedDescendants?: Set_2<Element>): Result<Foreground, ColorErrors>;

// @public (undocumented)
export class Group<T extends Hashable> implements Iterable<T>, Equatable, Hashable, json.Serializable<Group.JSON<T>>, earl.Serializable<Group.EARL>, sarif.Serializable<sarif.Location> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<T extends Hashable>(members: Iterable<T>): Group<T>;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toEARL(): Group.EARL;
    // (undocumented)
    toJSON(): Group.JSON<T>;
    // (undocumented)
    toSARIF(): sarif.Location;
}

// @public (undocumented)
export namespace Group {
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            ptr: "http://www.w3.org/2009/pointers#";
        };
        // (undocumented)
        "@type": ["ptr:Pointer", "ptr:PointersGroup", "ptr:RelatedPointers"];
        // (undocumented)
        "ptr:groupPointer": {
            "@list": Array_2<earl.EARL>;
        };
    }
    // (undocumented)
    export function isGroup<T extends Hashable>(value: unknown): value is Group<T>;
    // (undocumented)
    export type JSON<T> = Array_2<json.Serializable.ToJSON<T>>;
}

// @public (undocumented)
class LabelAndName extends Diagnostic_2 {
    // (undocumented)
    equals(value: LabelAndName): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(message: string, textContent?: string, name?: string): LabelAndName;
    // (undocumented)
    get textContent(): string;
    // (undocumented)
    toJSON(): LabelAndName.JSON;
}

// @public (undocumented)
namespace LabelAndName {
    // (undocumented)
    function isLabelAndName(value: Diagnostic_2): value is LabelAndName;
    // (undocumented)
    function isLabelAndName(value: unknown): value is LabelAndName;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        name: string;
        // (undocumented)
        textContent: string;
    }
}

// @public (undocumented)
class Languages extends Diagnostic_2 {
    // (undocumented)
    equals(value: Diagnostic_2): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get natural(): Option<Language>;
    // (undocumented)
    static of(message: string, programmatic?: Language, natural?: Language): Languages;
    // (undocumented)
    get programmatic(): Language;
    // (undocumented)
    toJSON(): Languages.JSON;
}

// @public (undocumented)
namespace Languages {
    // (undocumented)
    function isLanguages(value: Diagnostic_2): value is Languages;
    // (undocumented)
    function isLanguages(value: unknown): value is Languages;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        natural: Option.JSON<Language>;
        // (undocumented)
        programmatic: Language.JSON;
    }
}

// @public (undocumented)
class Layer {
    // (undocumented)
    get colors(): ReadonlyArray<Color.Resolved>;
    // (undocumented)
    static of(colors: Iterable<Color.Resolved>, opacity: number): Layer;
    // (undocumented)
    get opacity(): number;
}

// @public (undocumented)
namespace Layer {
    function getLayers(element: Element, device: Device, context?: Context, opacity?: number, ignoredInterposedDescendants?: Set_2<Element>): Result<Array_2<Layer>, ColorErrors<"layer">>;
    function merge(backdrops: Array_2<Color.Resolved>, layer: Layer): Array_2<Color.Resolved>;
}

// @public (undocumented)
class MatchingClasses extends Diagnostic_2 {
    // (undocumented)
    equals(value: MatchingClasses): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get matchingNonTargets(): Map_2<string, number>;
    // (undocumented)
    get matchingTargets(): Map_2<string, number>;
    // (undocumented)
    static of(message: string, matchingTargets?: Map_2<string, number>, matchingNonTargets?: Map_2<string, number>): Diagnostic_2;
    // (undocumented)
    toJSON(): MatchingClasses.JSON;
}

// @public (undocumented)
namespace MatchingClasses {
    // (undocumented)
    function isMatchingClasses(value: Diagnostic_2): value is MatchingClasses;
    // (undocumented)
    function isMatchingClasses(value: unknown): value is MatchingClasses;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        matchingNonTargets: Map_2.JSON<string, number>;
        // (undocumented)
        matchingTargets: Map_2.JSON<string, number>;
    }
}

// @public (undocumented)
namespace Outcomes {
    const // (undocumented)
    IsDistinguishable: (defaultStyles: Iterable<Result<ComputedStyles>>, hoverStyles: Iterable<Result<ComputedStyles>>, focusStyles: Iterable<Result<ComputedStyles>>) => Ok<DistinguishingStyles>;
    const // (undocumented)
    IsNotDistinguishable: (defaultStyles: Iterable<Result<ComputedStyles>>, hoverStyles: Iterable<Result<ComputedStyles>>, focusStyles: Iterable<Result<ComputedStyles>>) => Err<DistinguishingStyles>;
}

// @public (undocumented)
namespace Outcomes_10 {
    const // (undocumented)
    hasContent: (nextHeading: Option<Element>, currentLevel: number, nextLevel: number) => Ok<WithNextHeading>;
    const // (undocumented)
    hasNoContent: (nextHeading: Option<Element>, currentLevel: number, nextLevel: number) => Err<WithNextHeading>;
}

// @public (undocumented)
namespace Outcomes_11 {
    const // (undocumented)
    WrapsText: Ok<ClippingAncestors>;
    const // (undocumented)
    ClipsText: (horizontal: Option<Element>, vertical: Option<Element>) => Err<ClippingAncestors>;
}

// @public (undocumented)
namespace Outcomes_2 {
    const // (undocumented)
    HasCorrectLang: (programmatic: Language, natural: Language) => Ok<Languages>;
    const // (undocumented)
    HasIncorrectLang: (programmatic: Language, natural: Language) => Err<Languages>;
    const // (undocumented)
    HasNoLanguage: (programmatic: Language) => Err<Languages>;
}

// @public (undocumented)
namespace Outcomes_3 {
    const // (undocumented)
    VisibleIsInName: (textContent: string, name: string) => Ok<LabelAndName>;
    const // (undocumented)
    VisibleIsNotInName: (textContent: string, name: string) => Err<LabelAndName>;
}

// @public (undocumented)
namespace Outcomes_4 {
    const // (undocumented)
    HasAllStates: (role: Role.Name, required: ReadonlyArray<aria.Attribute.Name>, missing: ReadonlyArray<aria.Attribute.Name>) => Ok<RoleAndRequiredAttributes>;
    const // (undocumented)
    HasNotAllStates: (role: Role.Name, required: ReadonlyArray<aria.Attribute.Name>, missing: ReadonlyArray<aria.Attribute.Name>) => Err<RoleAndRequiredAttributes>;
    const // (undocumented)
    RuleError: Err<RoleAndRequiredAttributes>;
}

// @public (undocumented)
namespace Outcomes_5 {
    const // (undocumented)
    IsStructured: (previous: Element) => Ok<WithPreviousHeading>;
    const // (undocumented)
    IsNotStructured: (previous: Element) => Err<WithPreviousHeading>;
}

// @public (undocumented)
namespace Outcomes_6 {
    const // (undocumented)
    SameResource: (role: Role.Name, name: string) => Ok<WithRoleAndName>;
    const // (undocumented)
    DifferentResources: (role: Role.Name, name: string) => Err<WithRoleAndName>;
}

// @public (undocumented)
namespace Outcomes_7 {
    const // (undocumented)
    differentNames: (role: Role.Name) => Ok<SameNames>;
    const // (undocumented)
    sameNames: (role: Role.Name, errors: Iterable_2<Iterable_2<Element>>) => Err<SameNames>;
}

// @public (undocumented)
namespace Outcomes_8 {
    const // (undocumented)
    StartWithLevel1Heading: (heading: Element, level: number) => Ok<WithFirstHeading>;
    const // (undocumented)
    StartWithHigherLevelHeading: (heading: Element, level: number) => Err<WithFirstHeading>;
}

// @public (undocumented)
namespace Outcomes_9 {
    const // (undocumented)
    IsSufficient: (declaration: Option<Declaration>) => Ok<WithDeclaration>;
    const // (undocumented)
    IsInsufficient: (declaration: Option<Declaration>) => Err<WithDeclaration>;
}

// @public (undocumented)
export namespace Question {
    // (undocumented)
    export type Data = typeof Data & Record<Uri, {
        readonly type: keyof Type;
        readonly message: string;
    }>;
    export type Metadata = {
        [U in Uri]: [TypeName<U>, Typeof<U>];
    };
    // (undocumented)
    export function of<S, U extends Uri = Uri>(uri: U, subject: S, message?: string, options?: act.Question.Options<Typeof<U>>): act.Question<TypeName<U>, S, S, Typeof<U>, Typeof<U>, U>;
    // (undocumented)
    export function of<S, C, U extends Uri = Uri>(uri: U, subject: S, context: C, message?: string, options?: act.Question.Options<Typeof<U>>): act.Question<TypeName<U>, S, C, Typeof<U>, Typeof<U>, U>;
    export interface Type {
        // (undocumented)
        "color[]": Iterable<RGB>;
        // (undocumented)
        "node[]": Iterable<Node>;
        // (undocumented)
        "string[]": Iterable<string>;
        // (undocumented)
        boolean: boolean;
        // (undocumented)
        node: Option<Node>;
        // (undocumented)
        string: string;
    }
    // (undocumented)
    export type TypeName<U extends Uri> = Data[U]["type"];
    // (undocumented)
    export type Typeof<U extends Uri> = Type[TypeName<U>];
    // (undocumented)
    export type Uri = keyof typeof Data;
    const // (undocumented)
    Data: {
        readonly "reference-equivalent-resources": {
            readonly type: "boolean";
            readonly message: "Do the [links/iframe] [resolve to/reference] equivalent resources?";
        };
        readonly "has-audio": {
            readonly type: "boolean";
            readonly message: "Does the `<video>` element have audio?";
        };
        readonly "has-audio-track": {
            readonly type: "boolean";
            readonly message: "Does the `<video>` element have an audio track that describes its visual information?";
        };
        readonly "has-captions": {
            readonly type: "boolean";
            readonly message: "Does the `<video>` element have captions that describe the content of the video?";
        };
        readonly "has-description": {
            readonly type: "boolean";
            readonly message: "Is the visual information of the [audio/video] available through its audio or a separate audio description track?";
        };
        readonly "is-audio-streaming": {
            readonly type: "boolean";
            readonly message: "Is the `<audio>` element streaming?";
        };
        readonly "is-playing": {
            readonly type: "boolean";
            readonly message: "Is the `<audio>` element currently playing?";
        };
        readonly "is-video-streaming": {
            readonly type: "boolean";
            readonly message: "Is the `<video>` element streaming?";
        };
        readonly label: {
            readonly type: "node";
            readonly message: "Where is the text that labels the [audio/video] element as a video alternative?";
        };
        readonly "play-button": {
            readonly type: "node";
            readonly message: "Where is the button that controls playback of the `<audio>` element?";
        };
        readonly "text-alternative": {
            readonly type: "node";
            readonly message: "Where is the text alternative of the [audio/video] element?";
        };
        readonly "track-describes-video": {
            readonly type: "boolean";
            readonly message: "Does at least 1 track describe the visual information of the `<video>` element, either in the language of the `<video>` element or the language of the page?";
        };
        readonly transcript: {
            readonly type: "node";
            readonly message: "Where is the transcript that describes the content of the [audio/video] element?";
        };
        readonly "transcript-link": {
            readonly type: "node";
            readonly message: "Where is the link pointing to the transcript that describes the content of the [audio/video] element?";
        };
        readonly "name-describes-purpose": {
            readonly type: "boolean";
            readonly message: "Does the accessible name of the `<(target.name]>` element describe its purpose?";
        };
        readonly "audio-control-mechanism": {
            readonly type: "node";
            readonly message: "Where is the mechanism that can pause or stop the audio of the `<[target.name]>` element?";
        };
        readonly "is-above-duration-threshold": {
            readonly type: "boolean";
            readonly message: "Does the `<[element.name]>` element have a duration of more than 3 seconds?";
        };
        readonly "is-below-audio-duration-threshold": {
            readonly type: "boolean";
            readonly message: "Does the `<[target.name]>` element have a total audio duration of less than 3 seconds?";
        };
        readonly "is-content-equivalent": {
            readonly type: "boolean";
            readonly message: "Do these [role] landmarks have the same or equivalent content?";
        };
        readonly "visible-focus-classes": {
            readonly type: "string[]";
            readonly message: "Which classes have a visible focus indicator?";
        };
        readonly "has-focus-indicator": {
            readonly type: "boolean";
            readonly message: "Does the element have a visible focus indicator?";
        };
        readonly "background-colors": {
            readonly type: "color[]";
            readonly message: "What are the background colors of the text node?";
        };
        readonly "foreground-colors": {
            readonly type: "color[]";
            readonly message: "What are the foreground colors of the text node?";
        };
        readonly "ignored-interposed-elements": {
            readonly type: "node[]";
            readonly message: "Which of these interposed descendants should be ignored?";
        };
        readonly "first-tabbable-is-internal-link": {
            readonly type: "boolean";
            readonly message: "Is the first tabbable element of the document an internal link?";
        };
        readonly "first-tabbable-is-visible": {
            readonly type: "boolean";
            readonly message: "Is the first tabbable element of the document visible if it's focused?";
        };
        readonly "first-tabbable-reference": {
            readonly type: "node";
            readonly message: "Where in the document does the first tabbable element point?";
        };
        readonly "first-tabbable-reference-is-main": {
            readonly type: "boolean";
            readonly message: "Does the first tabbable element of the document point to the main content?";
        };
        readonly "error-indicators": {
            readonly type: "node[]";
            readonly message: "Where are (all) the error indicators, if any, for the form field?";
        };
        readonly "error-indicator-describing-resolution": {
            readonly type: "node";
            readonly message: "Which of these error indicators describes, in text, the cause of the error or how to resolve it?";
        };
        readonly "error-indicator-identifying-form-field": {
            readonly type: "node";
            readonly message: "Which of these error indicators identifies, in text, the form field it relates to?";
        };
        readonly "internal-reference": {
            readonly type: "node";
            readonly message: "Where in the document does this element point?";
        };
        readonly "is-start-of-main": {
            readonly type: "boolean";
            readonly message: "Is this element at the start of the main content of the document?";
        };
        readonly "is-visible-when-focused": {
            readonly type: "boolean";
            readonly message: "Is this element visible when it's focused?";
        };
        readonly "document-language": {
            readonly type: "string";
            readonly message: "What is the main language of the document?";
        };
    };
        {};
}

// @public (undocumented)
class RoleAndRequiredAttributes extends Diagnostic_2 {
    // (undocumented)
    equals(value: RoleAndRequiredAttributes): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get missingAttributes(): ReadonlyArray<aria.Attribute.Name>;
    // (undocumented)
    static of(message: string): Diagnostic_2;
    // (undocumented)
    static of(message: string, role: Role.Name, requiredAttributes: ReadonlyArray<aria.Attribute.Name>, missingAttributes: ReadonlyArray<aria.Attribute.Name>): RoleAndRequiredAttributes;
    // (undocumented)
    get requiredAttributes(): ReadonlyArray<aria.Attribute.Name>;
    // (undocumented)
    get role(): Role.Name;
    // (undocumented)
    toJSON(): RoleAndRequiredAttributes.JSON;
}

// @public (undocumented)
namespace RoleAndRequiredAttributes {
    // (undocumented)
    function isRoleAndRequiredAttributes(value: Diagnostic_2): value is RoleAndRequiredAttributes;
    // (undocumented)
    function isRoleAndRequiredAttributes(value: unknown): value is RoleAndRequiredAttributes;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        attributes: {
            required: Array_2<aria.Attribute.Name>;
            missing: Array_2<aria.Attribute.Name>;
        };
        // (undocumented)
        role: string;
    }
}

// @public (undocumented)
export type Rules = typeof Rules;

// @public
export const Rules: Record_2<typeof rules>;

// @public (undocumented)
class SameNames extends Diagnostic_2 implements Iterable_2<List<Element>> {
    // (undocumented)
    [Symbol.iterator](): Iterator<List<Element>>;
    // (undocumented)
    equals(value: SameNames): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(message: string, role?: Role.Name, errors?: Iterable_2<Iterable_2<Element>>): SameNames;
    // (undocumented)
    get role(): Role.Name;
    // (undocumented)
    toJSON(): SameNames.JSON;
}

// @public (undocumented)
namespace SameNames {
    // (undocumented)
    function isSameNames(value: Diagnostic_2): value is SameNames;
    // (undocumented)
    function isSameNames(value: unknown): value is SameNames;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        errors: Array_2<List.JSON<Element>>;
        // (undocumented)
        role: string;
    }
}

// @public (undocumented)
export class Scope<S extends string = string> extends Tag<"scope"> {
    // (undocumented)
    equals(value: Scope): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<S extends string>(scope: S): Scope<S>;
    // (undocumented)
    get scope(): S;
    // (undocumented)
    toJSON(): Scope.JSON<S>;
    // (undocumented)
    get type(): "scope";
}

// @public (undocumented)
export namespace Scope {
    // (undocumented)
    export interface JSON<S extends string = string> extends Tag.JSON<"scope"> {
        // (undocumented)
        scope: S;
    }
    const Page: Scope<"page">;
    const Component: Scope<"component">;
}

// @public (undocumented)
export class Stability<S extends string = string> extends Tag<"stability"> {
    // (undocumented)
    equals(value: Stability): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<S extends string>(stability: S): Stability<S>;
    // (undocumented)
    get stability(): S;
    // (undocumented)
    toJSON(): Stability.JSON<S>;
    // (undocumented)
    get type(): "stability";
}

// @public (undocumented)
export namespace Stability {
    // (undocumented)
    export interface JSON<S extends string = string> extends Tag.JSON<"stability"> {
        // (undocumented)
        stability: S;
    }
    const Experimental: Stability<"experimental">;
    const Stable: Stability<"stable">;
    const Deprecated: Stability<"deprecated">;
}

// @public (undocumented)
class TextSpacing<N extends Property.Name> extends Diagnostic_2 {
    // (undocumented)
    get declaration(): Declaration;
    // (undocumented)
    equals(value: TextSpacing<N>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get fontSize(): Style.Computed<"font-size">;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(message: string): Diagnostic_2;
    // (undocumented)
    static of<N extends Property.Name>(message: string, property: N, value: Length<"px">, fontSize: Style.Computed<"font-size">, ratio: number, threshold: number, declaration: Declaration, owner: Element): TextSpacing<N>;
    // (undocumented)
    get owner(): Element;
    // (undocumented)
    get property(): N;
    // (undocumented)
    get ratio(): number;
    // (undocumented)
    get threshold(): number;
    // (undocumented)
    toJSON(): TextSpacing.JSON<N>;
    // (undocumented)
    get value(): Length<"px">;
}

// @public (undocumented)
namespace TextSpacing {
    // (undocumented)
    function isTextSpacing(value: Diagnostic_2): value is TextSpacing<Property.Name>;
    // (undocumented)
    function isTextSpacing(value: unknown): value is TextSpacing<Property.Name>;
    // (undocumented)
    interface JSON<N extends Property.Name> extends Diagnostic_2.JSON {
        // (undocumented)
        "font-size": Serializable.ToJSON<Style.Computed<"font-size">>;
        // (undocumented)
        declaration: Declaration.JSON;
        // (undocumented)
        owner: Element.JSON;
        // (undocumented)
        property: N;
        // (undocumented)
        ratio: number;
        // (undocumented)
        threshold: number;
        // (undocumented)
        value: Length.JSON<"px">;
    }
}

// @public (undocumented)
export class Version<N extends number = number> extends Tag<"version"> {
    // (undocumented)
    equals(value: Version): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<N extends number>(version: N): Version<N>;
    // (undocumented)
    toJSON(): Version.JSON<N>;
    // (undocumented)
    get type(): "version";
    // (undocumented)
    get version(): N;
}

// @public (undocumented)
export namespace Version {
    // (undocumented)
    export function isVersion<T extends string>(value: unknown): value is Version;
    // (undocumented)
    export interface JSON<N extends number = number> extends Tag.JSON<"version"> {
        // (undocumented)
        version: N;
    }
}

// @public (undocumented)
class WithBadElements extends Diagnostic_2 implements Iterable_2<Element> {
    // (undocumented)
    [Symbol.iterator](): Iterator<Element>;
    // (undocumented)
    equals(value: WithBadElements): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get errors(): ReadonlyArray<Element>;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(message: string, errors?: Iterable_2<Element>): WithBadElements;
    // (undocumented)
    toJSON(): WithBadElements.JSON;
}

// @public (undocumented)
namespace WithBadElements {
    // (undocumented)
    function isWithBadElements(value: Diagnostic_2): value is WithBadElements;
    // (undocumented)
    function isWithBadElements(value: unknown): value is WithBadElements;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        errors: Array_2<string>;
    }
}

// @public (undocumented)
class WithDeclaration extends Diagnostic_2 {
    constructor(message: string, declaration: Option<Declaration>);
    // (undocumented)
    get declaration(): Option<Declaration>;
    // (undocumented)
    equals(value: WithDeclaration): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(message: string, declaration?: Option<Declaration>): WithDeclaration;
    // (undocumented)
    toJSON(): WithDeclaration.JSON;
}

// @public (undocumented)
namespace WithDeclaration {
    // (undocumented)
    function isWithDeclaration(value: Diagnostic_2): value is WithDeclaration;
    // (undocumented)
    function isWithDeclaration(value: unknown): value is WithDeclaration;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        declaration: Option.JSON<Declaration>;
    }
}

// @public (undocumented)
class WithFirstHeading extends Diagnostic_2 {
    // (undocumented)
    equals(value: WithFirstHeading): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get firstHeading(): Element;
    // (undocumented)
    get firstHeadingLevel(): number;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(message: string): Diagnostic_2;
    // (undocumented)
    static of(message: string, firstHeading: Element, level: number): WithFirstHeading;
    // (undocumented)
    toJSON(): WithFirstHeading.JSON;
}

// @public (undocumented)
namespace WithFirstHeading {
    // (undocumented)
    function isWithFirstHeading(value: Diagnostic_2): value is WithFirstHeading;
    // (undocumented)
    function isWithFirstHeading(value: unknown): value is WithFirstHeading;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        firstHeading: Element.JSON;
        // (undocumented)
        firstHeadingLevel: number;
    }
}

// @public (undocumented)
class WithNextHeading extends Diagnostic_2 {
    // (undocumented)
    get currentHeadingLevel(): number;
    // (undocumented)
    equals(value: WithNextHeading): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get nextHeading(): Option<Element>;
    // (undocumented)
    get nextHeadingLevel(): number;
    // (undocumented)
    static of(message: string): Diagnostic_2;
    // (undocumented)
    static of(message: string, nextHeading: Option<Element>, currentLevel: number, nextLevel: number): WithNextHeading;
    // (undocumented)
    toJSON(): WithNextHeading.JSON;
}

// @public (undocumented)
namespace WithNextHeading {
    // (undocumented)
    function isWithNextHeading(value: Diagnostic_2): value is WithNextHeading;
    // (undocumented)
    function isWithNextHeading(value: unknown): value is WithNextHeading;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        currentHeadingLevel: number;
        // (undocumented)
        nextHeading: Option.JSON<Element>;
        // (undocumented)
        nextHeadingLevel: number;
    }
}

// @public (undocumented)
class WithPreviousHeading extends Diagnostic_2 {
    constructor(message: string, previous: Element);
    // (undocumented)
    equals(value: WithPreviousHeading): value is this;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(message: string): Diagnostic_2;
    // (undocumented)
    static of(message: string, previous: Element): WithPreviousHeading;
    // (undocumented)
    get previous(): Element;
    // (undocumented)
    toJSON(): WithPreviousHeading.JSON;
}

// @public (undocumented)
namespace WithPreviousHeading {
    // (undocumented)
    function isWithPreviousHeading(value: unknown): value is WithPreviousHeading;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        previous: Element.JSON;
    }
}

// @public (undocumented)
class WithRole extends Diagnostic_2 {
    protected constructor(message: string, role: Role.Name);
    // (undocumented)
    equals(value: WithRole): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(message: string): Diagnostic_2;
    // (undocumented)
    static of(message: string, role: Role.Name): WithRole;
    // (undocumented)
    get role(): Role.Name;
    // (undocumented)
    protected readonly _role: Role.Name;
    // (undocumented)
    toJSON(): WithRole.JSON;
}

// @public (undocumented)
namespace WithRole {
    // (undocumented)
    function getRoleName(element: Element, device: Device): Role.Name;
    // (undocumented)
    function isWithRole(value: Diagnostic_2): value is WithRole;
    // (undocumented)
    function isWithRole(value: unknown): value is WithRole;
    // (undocumented)
    interface JSON extends Diagnostic_2.JSON {
        // (undocumented)
        role: string;
    }
}

// @public (undocumented)
class WithRoleAndName extends WithRole {
    // (undocumented)
    equals(value: WithRoleAndName): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(message: string): Diagnostic_2;
    // (undocumented)
    static of(message: string, role: Role.Name): WithRole;
    // (undocumented)
    static of(message: string, role: Role.Name, name: string): WithRoleAndName;
    // (undocumented)
    toJSON(): WithRoleAndName.JSON;
}

// @public (undocumented)
namespace WithRoleAndName {
    // (undocumented)
    function isWithRoleAndName(value: Diagnostic_2): value is WithRoleAndName;
    // (undocumented)
    function isWithRoleAndName(value: unknown): value is WithRoleAndName;
    // (undocumented)
    interface JSON extends WithRole.JSON {
        // (undocumented)
        name: string;
    }
}

// (No @packageDocumentation comment for this package)

```
