## API Report File for "@siteimprove/alfa-rules"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import * as act from '@siteimprove/alfa-act';
import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Attribute } from '@siteimprove/alfa-dom';
import { Document } from '@siteimprove/alfa-dom';
import * as earl from '@siteimprove/alfa-earl';
import { Element } from '@siteimprove/alfa-dom';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import * as json from '@siteimprove/alfa-json';
import { Node } from '@siteimprove/alfa-dom';
import { Option } from '@siteimprove/alfa-option';
import { Page } from '@siteimprove/alfa-web';
import { Record as Record_2 } from '@siteimprove/alfa-record';
import { RGB } from '@siteimprove/alfa-css';
import { Rule } from '@siteimprove/alfa-act';
import * as sarif from '@siteimprove/alfa-sarif';
import { Sequence } from '@siteimprove/alfa-sequence';
import { Tag } from '@siteimprove/alfa-act';
import { Text } from '@siteimprove/alfa-dom';

// @public
const _default: Rule.Atomic<Page, Document, Question.Metadata, Element<string>>;

// @public
const _default_2: Rule.Atomic<Page, Element<string>, Question.Metadata, Node<string> | Array_2<Node<string>>>;

// @public
const _default_3: Rule.Atomic<Page, Document, Question.Metadata, Document>;

// @public @deprecated (undocumented)
const _default_4: Rule.Atomic<Page, Element<string>, {}, Element<string>>;

// @public @deprecated (undocumented)
const _default_5: Rule.Atomic<Page, Attribute<string>, {}, Attribute<string>>;

// @public (undocumented)
const _default_6: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public (undocumented)
const _default_7: Rule.Atomic<Page, Element<string>, Question.Metadata, Element<string>>;

// @public @deprecated (undocumented)
const _default_8: Rule.Atomic<Page, Text, Question.Metadata, Text>;

// @public @deprecated (undocumented)
const _default_9: Rule.Atomic<Page, Text, Question.Metadata, Text>;

declare namespace deprecatedRules {
    export {
        _default_4 as DR6,
        _default_5 as DR18,
        _default_6 as DR34,
        _default_7 as DR36,
        _default_8 as DR66,
        _default_9 as DR69
    }
}
export { deprecatedRules }

// @public (undocumented)
export namespace Diagnostic {
    import Languages = languages.Languages;
    import LabelAndName = labelAndName.LabelAndName;
    import RoleAndRequiredAttributes = roleAndRequiredAttributes.RoleAndRequiredAttributes;
    import WithPreviousHeading = withPreviousHeading.WithPreviousHeading;
    import WithRoleAndName = withRoleAndName.WithRoleAndName;
    import SameNames = sameNames.SameNames;
    import WithFirstHeading = withFirstHeading.WithFirstHeading;
    import DistinguishingStyles = distinguishingStyles.DistinguishingStyles;
    import ElementDistinguishable = distinguishingStyles.ElementDistinguishable;
    import ColorError = colorError.ColorError;
    import ColorErrors = colorError.ColorErrors;
    import MatchingClasses = matchingClasses.MatchingClasses;
    import WithDeclaration = withDeclaration.WithDeclaration;
    import WithNextHeading = withNextHeading.WithNextHeading;
    import ClippingAncestors = clippingAncestors.ClippingAncestors;
    import Contrast = diagnostic.Contrast;
    import TextSpacing = diagnostic.TextSpacing;
    import WithBadElements = diagnostic.WithBadElements;
    import WithRole = diagnostic.WithRole;
    import WithAccessibleName = diagnostic.WithAccessibleName;
}

declare namespace experimentalRules {
    export {
        _default as ER87,
        _default_2 as R82,
        _default_3 as R109
    }
}
export { experimentalRules }

// @public (undocumented)
export namespace Flattened {
    export type Input = {
        [K in Keys]: act.Rule.Input<RulesObject[K]>;
    }[Keys];
    export type Keys = keyof RulesObject;
    export type Question = Question.Metadata;
    export type Rule = act.Rule<Input, Target, Question, Subject>;
    // Warning: (ae-forgotten-export) The symbol "rules" needs to be exported by the entry point index.d.ts
    export type RulesObject = typeof rules;
    export type Subject = {
        [K in Keys]: act.Rule.Subject<RulesObject[K]>;
    }[Keys];
    export type Target = {
        [K in Keys]: act.Rule.Target<RulesObject[K]>;
    }[Keys];
        {};
}

// @public
const FlattenedRules: Sequence<Flattened.Rule>;
export default FlattenedRules;

// @public (undocumented)
export class Group<T extends Hashable> implements Iterable<T>, Equatable, Hashable, json.Serializable<Group.JSON<T>>, earl.Serializable<Group.EARL>, sarif.Serializable<sarif.Location> {
    // (undocumented)
    [Symbol.iterator](): Iterator<T>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<T extends Hashable>(members: Iterable<T>): Group<T>;
    // (undocumented)
    get size(): number;
    // (undocumented)
    toEARL(): Group.EARL;
    // (undocumented)
    toJSON(): Group.JSON<T>;
    // (undocumented)
    toSARIF(): sarif.Location;
}

// @public (undocumented)
export namespace Group {
    // (undocumented)
    export interface EARL extends earl.EARL {
        // (undocumented)
        "@context": {
            ptr: "http://www.w3.org/2009/pointers#";
        };
        // (undocumented)
        "@type": ["ptr:Pointer", "ptr:PointersGroup", "ptr:RelatedPointers"];
        // (undocumented)
        "ptr:groupPointer": {
            "@list": Array_2<earl.EARL>;
        };
    }
    // (undocumented)
    export function isGroup<T extends Hashable>(value: unknown): value is Group<T>;
    // (undocumented)
    export type JSON<T> = Array_2<json.Serializable.ToJSON<T>>;
}

// @public (undocumented)
export namespace Question {
    // (undocumented)
    export type Data = typeof Data & Record<Uri, {
        readonly type: keyof Type;
        readonly message: string;
    }>;
    export type Metadata = {
        [U in Uri]: [TypeName<U>, Typeof<U>];
    };
    // (undocumented)
    export function of<S, U extends Uri = Uri>(uri: U, subject: S, message?: string, options?: act.Question.Options<Typeof<U>>): act.Question<TypeName<U>, S, S, Typeof<U>, Typeof<U>, U>;
    // (undocumented)
    export function of<S, C, U extends Uri = Uri>(uri: U, subject: S, context: C, message?: string, options?: act.Question.Options<Typeof<U>>): act.Question<TypeName<U>, S, C, Typeof<U>, Typeof<U>, U>;
    export interface Type {
        // (undocumented)
        "color[]": Iterable<RGB>;
        // (undocumented)
        "node[]": Iterable<Node>;
        // (undocumented)
        boolean: boolean;
        // (undocumented)
        node: Option<Node>;
        // (undocumented)
        string: string;
    }
    // (undocumented)
    export type TypeName<U extends Uri> = Data[U]["type"];
    // (undocumented)
    export type Typeof<U extends Uri> = Type[TypeName<U>];
    // (undocumented)
    export type Uri = keyof typeof Data;
    const // (undocumented)
    Data: {
        readonly "reference-equivalent-resources": {
            readonly type: "boolean";
            readonly message: "Do the [links/iframe] [resolve to/reference] equivalent resources?";
        };
        readonly "has-audio": {
            readonly type: "boolean";
            readonly message: "Does the `<video>` element have audio?";
        };
        readonly "has-audio-track": {
            readonly type: "boolean";
            readonly message: "Does the `<video>` element have an audio track that describes its visual information?";
        };
        readonly "has-captions": {
            readonly type: "boolean";
            readonly message: "Does the `<video>` element have captions that describe the content of the video?";
        };
        readonly "has-description": {
            readonly type: "boolean";
            readonly message: "Is the visual information of the [audio/video] available through its audio or a separate audio description track?";
        };
        readonly "is-audio-streaming": {
            readonly type: "boolean";
            readonly message: "Is the `<audio>` element streaming?";
        };
        readonly "is-playing": {
            readonly type: "boolean";
            readonly message: "Is the `<audio>` element currently playing?";
        };
        readonly "is-video-streaming": {
            readonly type: "boolean";
            readonly message: "Is the `<video>` element streaming?";
        };
        readonly label: {
            readonly type: "node";
            readonly message: "Where is the text that labels the [audio/video] element as a video alternative?";
        };
        readonly "play-button": {
            readonly type: "node";
            readonly message: "Where is the button that controls playback of the `<audio>` element?";
        };
        readonly "text-alternative": {
            readonly type: "node";
            readonly message: "Where is the text alternative of the [audio/video] element?";
        };
        readonly "track-describes-video": {
            readonly type: "boolean";
            readonly message: "Does at least 1 track describe the visual information of the `<video>` element, either in the language of the `<video>` element or the language of the page?";
        };
        readonly transcript: {
            readonly type: "node";
            readonly message: "Where is the transcript that describes the content of the [audio/video] element?";
        };
        readonly "transcript-link": {
            readonly type: "node";
            readonly message: "Where is the link pointing to the transcript that describes the content of the [audio/video] element?";
        };
        readonly "name-describes-purpose": {
            readonly type: "boolean";
            readonly message: "Does the accessible name of the `<(target.name]>` element describe its purpose?";
        };
        readonly "audio-control-mechanism": {
            readonly type: "node";
            readonly message: "Where is the mechanism that can pause or stop the audio of the `<[target.name]>` element?";
        };
        readonly "is-above-duration-threshold": {
            readonly type: "boolean";
            readonly message: "Does the `<[element.name]>` element have a duration of more than 3 seconds?";
        };
        readonly "is-below-audio-duration-threshold": {
            readonly type: "boolean";
            readonly message: "Does the `<[target.name]>` element have a total audio duration of less than 3 seconds?";
        };
        readonly "is-content-equivalent": {
            readonly type: "boolean";
            readonly message: "Do these [role] landmarks have the same or equivalent content?";
        };
        readonly "has-focus-indicator": {
            readonly type: "boolean";
            readonly message: "Does the element have a visible focus indicator?";
        };
        readonly "background-colors": {
            readonly type: "color[]";
            readonly message: "What are the background colors of the text node?";
        };
        readonly "foreground-colors": {
            readonly type: "color[]";
            readonly message: "What are the foreground colors of the text node?";
        };
        readonly "ignored-interposed-elements": {
            readonly type: "node[]";
            readonly message: "Which of these interposed descendants should be ignored?";
        };
        readonly "first-tabbable-is-internal-link": {
            readonly type: "boolean";
            readonly message: "Is the first tabbable element of the document an internal link?";
        };
        readonly "first-tabbable-is-visible": {
            readonly type: "boolean";
            readonly message: "Is the first tabbable element of the document visible if it's focused?";
        };
        readonly "first-tabbable-reference": {
            readonly type: "node";
            readonly message: "Where in the document does the first tabbable element point?";
        };
        readonly "first-tabbable-reference-is-main": {
            readonly type: "boolean";
            readonly message: "Does the first tabbable element of the document point to the main content?";
        };
        readonly "error-indicators": {
            readonly type: "node[]";
            readonly message: "Where are (all) the error indicators, if any, for the form field?";
        };
        readonly "error-indicator-describing-resolution": {
            readonly type: "node";
            readonly message: "Which of these error indicators describes, in text, the cause of the error or how to resolve it?";
        };
        readonly "error-indicator-identifying-form-field": {
            readonly type: "node";
            readonly message: "Which of these error indicators identifies, in text, the form field it relates to?";
        };
        readonly "internal-reference": {
            readonly type: "node";
            readonly message: "Where in the document does this element point?";
        };
        readonly "is-start-of-main": {
            readonly type: "boolean";
            readonly message: "Is this element at the start of the main content of the document?";
        };
        readonly "is-visible-when-focused": {
            readonly type: "boolean";
            readonly message: "Is this element visible when it's focused?";
        };
        readonly "document-language": {
            readonly type: "string";
            readonly message: "What is the main language of the document?";
        };
    };
        {};
}

// @public (undocumented)
export type Rules = typeof Rules;

// @public
export const Rules: Record_2<typeof rules>;

// @public (undocumented)
export class Scope<S extends string = string> extends Tag<"scope"> {
    // (undocumented)
    equals(value: Scope): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<S extends string>(scope: S): Scope<S>;
    // (undocumented)
    get scope(): S;
    // (undocumented)
    toJSON(): Scope.JSON<S>;
    // (undocumented)
    get type(): "scope";
}

// @public (undocumented)
export namespace Scope {
    // (undocumented)
    export interface JSON<S extends string = string> extends Tag.JSON<"scope"> {
        // (undocumented)
        scope: S;
    }
    const Page: Scope<"page">;
    const Component: Scope<"component">;
}

// @public (undocumented)
export class Stability<S extends string = string> extends Tag<"stability"> {
    // (undocumented)
    equals(value: Stability): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<S extends string>(stability: S): Stability<S>;
    // (undocumented)
    get stability(): S;
    // (undocumented)
    toJSON(): Stability.JSON<S>;
    // (undocumented)
    get type(): "stability";
}

// @public (undocumented)
export namespace Stability {
    // (undocumented)
    export interface JSON<S extends string = string> extends Tag.JSON<"stability"> {
        // (undocumented)
        stability: S;
    }
    const Experimental: Stability<"experimental">;
    const Stable: Stability<"stable">;
    const Deprecated: Stability<"deprecated">;
}

// @public (undocumented)
export class Version<N extends number = number> extends Tag<"version"> {
    // (undocumented)
    equals(value: Version): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of<N extends number>(version: N): Version<N>;
    // (undocumented)
    toJSON(): Version.JSON<N>;
    // (undocumented)
    get type(): "version";
    // (undocumented)
    get version(): N;
}

// @public (undocumented)
export namespace Version {
    // (undocumented)
    export function isVersion<T extends string>(value: unknown): value is Version;
    // (undocumented)
    export interface JSON<N extends number = number> extends Tag.JSON<"version"> {
        // (undocumented)
        version: N;
    }
}

// (No @packageDocumentation comment for this package)

```
