## API Report File for "@siteimprove/alfa-tuple"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Callback } from '@siteimprove/alfa-callback';
import { Comparer } from '@siteimprove/alfa-comparable';
import { Hash } from '@siteimprove/alfa-hash';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Option } from '@siteimprove/alfa-option';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Reducer } from '@siteimprove/alfa-reducer';
import { Refinement } from '@siteimprove/alfa-refinement';

// @public (undocumented)
export type Tuple<T extends ReadonlyArray<unknown> = ReadonlyArray<unknown>> = T;

// @public (undocumented)
export namespace Tuple {
    // (undocumented)
    export type Append<T extends Tuple, V> = [...T, V];
    // (undocumented)
    export function append<T extends Tuple, V>(tuple: T, value: V): Append<T, V>;
    // (undocumented)
    export function collect<T extends Tuple, U>(tuple: T, mapper: Mapper<Item<T>, Option<U>, [index: number]>): Array_2<U>;
    // (undocumented)
    export function collectFirst<T extends Tuple, U>(tuple: T, mapper: Mapper<Item<T>, Option<U>, [index: number]>): Option<U>;
    // (undocumented)
    export type Copy<T extends Tuple> = T extends readonly [...infer T] ? T : Empty;
    // (undocumented)
    export function copy<T extends Tuple>(tuple: T): Copy<T>;
    // (undocumented)
    export function count<T extends Tuple>(tuple: T, predicate: Predicate<Item<T>, [index: number]>): number;
    // (undocumented)
    export type Empty = [];
    // (undocumented)
    export function empty(): Empty;
    // (undocumented)
    export function equals<T extends Tuple>(a: T, b: T): boolean;
    // (undocumented)
    export function every<T extends Tuple>(tuple: T, predicate: Predicate<Item<T>, [index: number]>): boolean;
    // (undocumented)
    export type Filter<T extends Tuple, U extends Item<T>> = T extends readonly [
    infer H,
    ...infer R
    ] ? H extends U ? [H, ...Filter<R, U>] : Filter<R, U> : Empty;
    // (undocumented)
    export function filter<T extends Tuple, U extends Item<T>>(tuple: T, refinement: Refinement<Item<T>, U, [index: number]>): Filter<T, U>;
    // (undocumented)
    export function filter<T extends Tuple>(tuple: T, predicate: Predicate<Item<T>, [index: number]>): Array_2<Item<T>>;
    // (undocumented)
    export function find<T extends Tuple, U extends Item<T>>(tuple: T, refinement: Refinement<Item<T>, U, [index: number]>): Option<U>;
    // (undocumented)
    export function find<T extends Tuple>(tuple: T, predicate: Predicate<Item<T>, [index: number]>): Option<Item<T>>;
    // (undocumented)
    export function findLast<T extends Tuple, U extends Item<T>>(tuple: T, refinement: Refinement<Item<T>, U, [index: number]>): Option<U>;
    // (undocumented)
    export function findLast<T extends Tuple>(tuple: T, predicate: Predicate<Item<T>, [index: number]>): Option<Item<T>>;
    // (undocumented)
    export type First<T extends Tuple> = T extends readonly [infer H, ...infer _] ? H : never;
    // (undocumented)
    export function first<T extends Tuple>(tuple: T): Option<First<T>>;
    // (undocumented)
    export function forEach<T extends Tuple>(tuple: T, callback: Callback<Item<T>, void, [index: number]>): void;
    // (undocumented)
    export type Get<T extends Tuple, I extends number> = GetInner<T, I, Empty>;
    // (undocumented)
    export function get<T extends Tuple, I extends number>(tuple: T, index: I): Option<Get<T, I>>;
    // (undocumented)
    export type GetInner<T extends Tuple, I extends number, S extends Tuple> = T extends readonly [infer H, ...infer R] ? I extends Size<S> ? H : GetInner<R, I, Append<S, H>> : never;
    // (undocumented)
    export type Has<T extends Tuple, I extends number> = Get<T, I> extends never ? false : true;
    // (undocumented)
    export function has<T extends Tuple, I extends number>(tuple: T, index: I): Has<T, I>;
    // (undocumented)
    export function hash<T extends Tuple>(tuple: T, hash: Hash): void;
    // (undocumented)
    export function includes<T extends Tuple>(tuple: T, value: Item<T>): boolean;
    // (undocumented)
    export type Insert<T extends Tuple, I extends number, V> = InsertInner<T, I, V, Empty>;
    // (undocumented)
    export function insert<T extends Tuple, I extends number, V>(tuple: T, index: I, value: V): Insert<T, I, V>;
    // (undocumented)
    export type InsertInner<T extends Tuple, I extends number, V, S extends Tuple> = I extends Size<T> ? Append<T, V> : T extends readonly [infer H, ...infer R] ? I extends Size<S> ? [V, H, ...R] : [H, ...InsertInner<R, I, V, Append<S, H>>] : T;
    // (undocumented)
    export type Item<T extends Tuple> = T[number];
    // (undocumented)
    export function iterator<T extends Tuple>(tuple: T): Iterator<Item<T>>;
    // (undocumented)
    export type Last<T extends Tuple> = T extends readonly [infer H, ...infer R] ? R extends Empty ? H : Last<R> : never;
    // (undocumented)
    export function last<T extends Tuple>(tuple: T): Option<Last<T>>;
    // (undocumented)
    export type Map<T extends Tuple, U> = T extends readonly [infer _, ...infer R] ? [U, ...Map<R, U>] : Empty;
    // (undocumented)
    export function map<T extends Tuple, U>(tuple: T, mapper: Mapper<Item<T>, U, [index: number]>): Map<T, U>;
    // (undocumented)
    export function none<T extends Tuple>(tuple: T, predicate: Predicate<Item<T>, [index: number]>): boolean;
    // (undocumented)
    export function of<T extends Tuple>(...values: T): T;
    // (undocumented)
    export type Prepend<T extends Tuple, V> = [V, ...T];
    // (undocumented)
    export function prepend<T extends Tuple, V>(tuple: T, value: V): Prepend<T, V>;
    // (undocumented)
    export function reduce<T extends Tuple, U>(tuple: T, reducer: Reducer<Item<T>, U, [index: number]>, accumulator: U): U;
    // (undocumented)
    export function reduceUntil<T extends Tuple, U>(tuple: T, predicate: Predicate<Item<T>, [index: number]>, reducer: Reducer<Item<T>, U, [index: number]>, accumulator: U): U;
    // (undocumented)
    export function reduceWhile<T extends Tuple, U>(tuple: T, predicate: Predicate<Item<T>, [index: number]>, reducer: Reducer<Item<T>, U, [index: number]>, accumulator: U): U;
    // (undocumented)
    export type Reject<T extends Tuple, U extends Item<T>> = Filter<T, Exclude<Item<T>, U>>;
    // (undocumented)
    export function reject<T extends Tuple, U extends Item<T>>(tuple: T, refinement: Refinement<Item<T>, U, [index: number]>): Reject<T, U>;
    // (undocumented)
    export function reject<T extends Tuple>(tuple: T, predicate: Predicate<Item<T>, [index: number]>): Array_2<Item<T>>;
    // (undocumented)
    export type Rest<T extends Tuple> = T extends readonly [infer _, ...infer R] ? R : Empty;
    // (undocumented)
    export type Reverse<T extends Tuple> = T extends readonly [
    infer H,
    ...infer R
    ] ? [...Reverse<R>, H] : Empty;
    // (undocumented)
    export function search<T extends Tuple>(tuple: T, value: Item<T>, comparer: Comparer<Item<T>>): number;
    // (undocumented)
    export type Set<T extends Tuple, I extends number, V> = SetInner<T, I, V, Empty>;
    // (undocumented)
    export function set<T extends Tuple, I extends number, V>(tuple: T, index: I, value: V): Set<T, I, V>;
    // (undocumented)
    export type SetInner<T extends Tuple, I extends number, V, S extends Tuple> = T extends readonly [infer H, ...infer R] ? I extends Size<S> ? [V, ...R] : [H, ...SetInner<R, I, V, Append<S, H>>] : T;
    // (undocumented)
    export type Size<T extends Tuple> = T["length"];
    // (undocumented)
    export function size<T extends Tuple>(tuple: T): Size<T>;
    // (undocumented)
    export type Skip<T extends Tuple, N extends number> = SkipInner<T, N, Empty>;
    // (undocumented)
    export type SkipInner<T extends Tuple, N extends number, A extends Tuple> = T extends readonly [infer H, ...infer R] ? N extends Size<A> ? T : SkipInner<R, N, Append<A, H>> : Empty;
    // (undocumented)
    export function some<T extends Tuple>(tuple: T, predicate: Predicate<Item<T>, [index: number]>): boolean;
    // (undocumented)
    export type Take<T extends Tuple, N extends number> = TakeInner<T, N, Empty>;
    // (undocumented)
    export type TakeInner<T extends Tuple, N extends number, A extends Tuple> = T extends readonly [infer H, ...infer R] ? N extends Size<A> ? A : TakeInner<R, N, Append<A, H>> : Empty;
        {};
}

// (No @packageDocumentation comment for this package)

```
