## API Report File for "@siteimprove/alfa-css"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Comparable } from '@siteimprove/alfa-comparable';
import { Comparison } from '@siteimprove/alfa-comparable';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Option } from '@siteimprove/alfa-option';
import { Parser } from '@siteimprove/alfa-parser';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Record as Record_2 } from '@siteimprove/alfa-record';
import { Result } from '@siteimprove/alfa-result';
import { Serializable } from '@siteimprove/alfa-json';
import { Slice } from '@siteimprove/alfa-slice';

// @public (undocumented)
export class Angle<U extends Unit.Angle = Unit.Angle> extends Dimension<"angle", Unit.Angle, U> {
    // (undocumented)
    get canonicalUnit(): "deg";
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    hasUnit<U extends Unit.Angle>(unit: U): this is Angle<U>;
    // (undocumented)
    static of<U extends Unit.Angle>(value: number, unit: U): Angle<U>;
    // (undocumented)
    scale(factor: number): Angle<U>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    withUnit<U extends Unit.Angle>(unit: U): Angle<U>;
}

// @public (undocumented)
export namespace Angle {
    // (undocumented)
    export function isAngle(value: unknown): value is Angle;
    // (undocumented)
    export interface JSON<U extends Unit.Angle = Unit.Angle> extends Dimension.JSON<"angle", U> {
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Angle, string>;
}

// @public (undocumented)
export class Block implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(token: Block.Open, value: Iterable<Token>): Block;
    // (undocumented)
    toJSON(): Block.JSON;
    // (undocumented)
    get token(): Block.Open;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): Array<Token>;
}

// @public (undocumented)
export namespace Block {
    export type Close = Token.CloseParenthesis | Token.CloseSquareBracket | Token.CloseCurlyBracket;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        token: Token.JSON;
        // (undocumented)
        value: Array<Token.JSON>;
    }
    export type Open = Token.OpenParenthesis | Token.OpenSquareBracket | Token.OpenCurlyBracket;
    const // (undocumented)
    consume: Parser<Slice<Token>, Block>;
}

// @public (undocumented)
export type Box = Keyword<"border-box"> | Keyword<"padding-box"> | Keyword<"content-box">;

// @public (undocumented)
export namespace Box {
    // (undocumented)
    export type Geometry = Shape | Keyword<"fill-box"> | Keyword<"stroke-box"> | Keyword<"view-box">;
    const // (undocumented)
    parse: Parser<Slice<Token>, Box, string>;
    // (undocumented)
    export namespace Geometry {
        // (undocumented)
        export type JSON = Shape.JSON | Keyword.JSON<"fill-box"> | Keyword.JSON<"stroke-box"> | Keyword.JSON<"view-box">;
    }
    // (undocumented)
    export type JSON = Keyword.JSON<"border-box"> | Keyword.JSON<"padding-box"> | Keyword.JSON<"content-box">;
    const // (undocumented)
    parseShape: Parser<Slice<Token>, Shape, string>;
    // (undocumented)
    export type Shape = Box | Keyword<"margin-box">;
    // (undocumented)
    export namespace Shape {
        // (undocumented)
        export type JSON = Box.JSON | Keyword.JSON<"margin-box">;
    }
    const // (undocumented)
    parseGeometry: Parser<Slice<Token>, Geometry, string>;
}

// @public (undocumented)
export class Calculation<D extends Calculation.Dimension = "unknown"> extends Value<"calculation"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get expression(): Calculation.Expression;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    isLength(): this is Calculation<"length">;
    // (undocumented)
    isLengthPercentage(): this is Calculation<"length" | "percentage">;
    // (undocumented)
    static of(expression: Calculation.Expression): Calculation;
    // (undocumented)
    reduce(resolver: Calculation.Resolver): Calculation;
    resolve(this: Calculation<"length" | "percentage">, resolver: Calculation.Resolver<"px", Length<"px">>): Length<"px">;
    // (undocumented)
    toJSON(): Calculation.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "calculation";
}

// @public (undocumented)
export namespace Calculation {
    // @internal (undocumented)
    export type Dimension = Kind.Base | "scalar" | "unknown";
    // (undocumented)
    export abstract class Expression implements Equatable, Serializable {
        // (undocumented)
        abstract equals(value: unknown): value is this;
        // (undocumented)
        abstract get kind(): Kind;
        // Warning: (ae-incompatible-release-tags) The symbol "reduce" is marked as @public, but its signature references "Resolver" which is marked as @internal
        //
        // (undocumented)
        abstract reduce<L extends Unit.Length = "px", P extends Numeric = Numeric>(resolver: Resolver<L, P>): Expression;
        // (undocumented)
        toJSON(): Expression.JSON;
        // (undocumented)
        toLength(): Option<Length>;
        // (undocumented)
        toPercentage(): Option<Percentage>;
        // (undocumented)
        abstract toString(): string;
        // (undocumented)
        abstract get type(): string;
    }
    // (undocumented)
    export namespace Expression {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: string;
        }
    }
    // (undocumented)
    export class Invert extends Operation.Unary {
        // (undocumented)
        get kind(): Kind;
        // (undocumented)
        static of(operand: Expression): Invert;
        // Warning: (ae-incompatible-release-tags) The symbol "reduce" is marked as @public, but its signature references "Resolver" which is marked as @internal
        //
        // (undocumented)
        reduce<L extends Unit.Length = "px", P extends Numeric = Numeric>(resolver: Resolver<L, P>): Expression;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "invert";
    }
    // (undocumented)
    export function isCalculation(value: unknown): value is Calculation;
    // (undocumented)
    export function isInvertExpression(value: unknown): value is Invert;
    // (undocumented)
    export function isNegateExpression(value: unknown): value is Negate;
    // (undocumented)
    export function isProductExpression(value: unknown): value is Product;
    // (undocumented)
    export function isSumExpression(value: unknown): value is Sum;
    // (undocumented)
    export function isValueExpression(value: unknown): value is Value;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        expression: Expression.JSON;
        // (undocumented)
        type: "calculation";
    }
    // (undocumented)
    export class Kind implements Equatable, Serializable {
        // (undocumented)
        add(kind: Kind): Result<Kind, string>;
        // (undocumented)
        apply(hint: Kind.Hint): Kind;
        // (undocumented)
        static empty(): Kind;
        // (undocumented)
        equals(value: this): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get hint(): Option<Kind.Hint>;
        // (undocumented)
        invert(): Kind;
        // (undocumented)
        is(kind?: Kind.Base, value?: number, hinted?: boolean): boolean;
        // (undocumented)
        get kinds(): Kind.Map;
        // (undocumented)
        multiply(kind: Kind): Result<Kind, string>;
        // (undocumented)
        static of(kind?: Kind.Base): Kind;
        // (undocumented)
        toJSON(): Kind.JSON;
    }
    // (undocumented)
    export namespace Kind {
        // (undocumented)
        export type Base = Numeric.Dimension | "percentage";
        // (undocumented)
        export type Hint = Exclude<Kind.Base, "percentage">;
        // (undocumented)
        export function isKind(value: unknown): value is Kind;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            hint: Hint | null;
            // (undocumented)
            kinds: Array<[Base, number]>;
        }
        // (undocumented)
        export type Map = Record_2<{
            [K in Base]: number;
        }>;
    }
    // (undocumented)
    export class Negate extends Operation.Unary {
        // (undocumented)
        static of(operand: Expression): Negate;
        // Warning: (ae-incompatible-release-tags) The symbol "reduce" is marked as @public, but its signature references "Resolver" which is marked as @internal
        //
        // (undocumented)
        reduce<L extends Unit.Length = "px", P extends Numeric = Numeric>(resolver: Resolver<L, P>): Expression;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "negate";
    }
    // (undocumented)
    export abstract class Operation<O extends Array<Expression> = Array<Expression>> extends Expression {
        protected constructor(operands: Readonly<O>, kind: Kind);
        // (undocumented)
        equals(value: Operation<O>): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get kind(): Kind;
        // (undocumented)
        protected readonly _kind: Kind;
        // (undocumented)
        get operands(): Readonly<O>;
        // (undocumented)
        protected readonly _operands: Readonly<O>;
        // (undocumented)
        toJSON(): Operation.JSON;
    }
    // (undocumented)
    export namespace Operation {
        // (undocumented)
        export abstract class Binary extends Operation<[Expression, Expression]> {
            protected constructor(operands: [Expression, Expression], kind: Kind);
        }
        // (undocumented)
        export interface JSON extends Expression.JSON {
            // (undocumented)
            operands: Array<Expression.JSON>;
        }
        // (undocumented)
        export abstract class Unary extends Operation<[Expression]> {
            protected constructor(operands: [Expression], kind: Kind);
        }
    }
    // (undocumented)
    export class Product extends Operation.Binary {
        // (undocumented)
        static of(...operands: [Expression, Expression]): Result<Product, string>;
        // Warning: (ae-incompatible-release-tags) The symbol "reduce" is marked as @public, but its signature references "Resolver" which is marked as @internal
        //
        // (undocumented)
        reduce<L extends Unit.Length = "px", P extends Numeric = Numeric>(resolver: Resolver<L, P>): Expression;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "product";
    }
    // @internal
    export interface Resolver<L extends Unit.Length = "px", P extends Numeric = Numeric> {
        // (undocumented)
        length(value: Length<Unit.Length.Relative>): Length<L>;
        // (undocumented)
        percentage(value: Percentage): P;
    }
    // (undocumented)
    export class Sum extends Operation.Binary {
        // (undocumented)
        static of(...operands: [Expression, Expression]): Result<Sum, string>;
        // Warning: (ae-incompatible-release-tags) The symbol "reduce" is marked as @public, but its signature references "Resolver" which is marked as @internal
        //
        // (undocumented)
        reduce<L extends Unit.Length = "px", P extends Numeric = Numeric>(resolver: Resolver<L, P>): Expression;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "sum";
    }
    // (undocumented)
    export class Value extends Expression {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get kind(): Kind;
        // (undocumented)
        static of(value: Numeric): Value;
        // Warning: (ae-incompatible-release-tags) The symbol "reduce" is marked as @public, but its signature references "Resolver" which is marked as @internal
        //
        // (undocumented)
        reduce<L extends Unit.Length = "px", P extends Numeric = Numeric>(resolver: Resolver<L, P>): Value;
        // (undocumented)
        toJSON(): Value.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "value";
        // (undocumented)
        get value(): Numeric;
    }
    // (undocumented)
    export namespace Value {
        // (undocumented)
        export interface JSON extends Expression.JSON {
            // (undocumented)
            type: "value";
            // (undocumented)
            value: Numeric.JSON;
        }
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Calculation<"unknown">, string, []>;
}

// @public (undocumented)
export class Circle<R extends Radius = Radius, P extends Position = Position> extends Value<"basic-shape"> {
    // (undocumented)
    get center(): P;
    // (undocumented)
    equals(value: Circle): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "circle";
    // (undocumented)
    static of<R extends Radius, P extends Position>(radius: R, center: P): Circle<R, P>;
    // (undocumented)
    get radius(): R;
    // (undocumented)
    toJSON(): Circle.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "basic-shape";
}

// @public (undocumented)
export namespace Circle {
    // (undocumented)
    export function isCircle(value: unknown): value is Circle;
    // (undocumented)
    export interface JSON extends Value.JSON<"basic-shape"> {
        // (undocumented)
        center: Position.JSON;
        // (undocumented)
        kind: "circle";
        // (undocumented)
        radius: Radius.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Circle, string>;
}

// @public (undocumented)
export type Color = Hex | Named | HSL | RGB | Current | System;

// @public (undocumented)
export namespace Color {
    // (undocumented)
    export function hex(value: number): Hex;
    const // (undocumented)
    current: Current;
    // (undocumented)
    export function hsl<H extends Number_2 | Angle, A extends Number_2 | Percentage>(hue: H, saturation: Percentage, lightness: Percentage, alpha: A): HSL<H, A>;
    // (undocumented)
    export function isTransparent(color: Color): boolean;
    // (undocumented)
    export type JSON = Hex.JSON | Named.JSON | HSL.JSON | RGB.JSON | Keyword.JSON;
    // (undocumented)
    export function named<C extends Named.Color>(color: C): Named<C>;
    // (undocumented)
    export function rgb<C extends Number_2 | Percentage, A extends Number_2 | Percentage>(red: C, green: C, blue: C, alpha: A): RGB<C, A>;
    const // (undocumented)
    parse: Parser<Slice<Token>, Color, string>;
    // (undocumented)
    export function system(keyword: System.Keyword): System;
}

// @public (undocumented)
export class Component implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(value: Iterable<Token>): Component;
    // (undocumented)
    toJSON(): Component.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): Array<Token>;
}

// @public (undocumented)
export namespace Component {
    // (undocumented)
    export type JSON = Array<Token.JSON>;
    const // (undocumented)
    consume: Parser<Slice<Token>, Component, string>;
    const // (undocumented)
    parse: Parser<Slice<Token>, Component, string>;
}

// @public
export type Converter<U extends string> = (value: number, from: U, to: U) => number;

// @public (undocumented)
export namespace Converter {
    const // (undocumented)
    length: Converter<Unit.Length.Absolute>;
    const // (undocumented)
    angle: Converter<Unit.Angle>;
    const // (undocumented)
    time: Converter<Unit.Time>;
    const // (undocumented)
    frequency: Converter<Unit.Frequency>;
}

// @public
export interface Convertible<U extends string> {
    // (undocumented)
    withUnit<V extends U>(unit: V): Convertible<V>;
}

// @public (undocumented)
export type Current = Keyword<"currentcolor">;

// @public (undocumented)
export namespace Current {
    const // (undocumented)
    parse: Parser<Slice<Token>, Current, string>;
}

// @public (undocumented)
export class Declaration implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get important(): boolean;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(name: string, value: Iterable<Token>, important?: boolean): Declaration;
    // (undocumented)
    toJSON(): Declaration.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): Array<Token>;
}

// @public (undocumented)
export namespace Declaration {
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        important: boolean;
        // (undocumented)
        name: string;
        // (undocumented)
        value: Array<Token.JSON>;
    }
    const // (undocumented)
    consume: Parser<Slice<Token>, Declaration, string>;
    const // (undocumented)
    parse: Parser<Slice<Token>, Declaration, string>;
    const // (undocumented)
    consumeList: Parser<Slice<Token>, Iterable<Declaration>, string>;
    const // (undocumented)
    parseList: Parser<Slice<Token>, Iterable<Declaration>, string>;
}

// @public (undocumented)
export abstract class Dimension<T extends Numeric.Dimension = Numeric.Dimension, U extends Unit = Unit, V extends U = U> extends Numeric<T> implements Convertible<U>, Comparable<Dimension<T, U>> {
    protected constructor(value: number, unit: V, type: T);
    // (undocumented)
    abstract get canonicalUnit(): U;
    // (undocumented)
    compare(value: Dimension<T, U>): Comparison;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hasUnit<V extends U>(unit: V): this is Dimension<T, U, V>;
    // (undocumented)
    toJSON(): Dimension.JSON<T, U>;
    // (undocumented)
    get unit(): V;
    // (undocumented)
    protected readonly _unit: V;
    // (undocumented)
    abstract withUnit<V extends U>(unit: V): Dimension<T, U, V>;
}

// @public (undocumented)
export namespace Dimension {
    // (undocumented)
    export function isDimension(value: unknown): value is Dimension;
    // (undocumented)
    export interface JSON<T extends Numeric.Dimension = Numeric.Dimension, U extends Unit = Unit> extends Numeric.JSON<T> {
        // (undocumented)
        unit: U;
    }
}

// @public (undocumented)
export class Ellipse<R extends Radius = Radius, P extends Position = Position> extends Value<"basic-shape"> {
    // (undocumented)
    get center(): P;
    // (undocumented)
    equals(value: Ellipse): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "ellipse";
    // (undocumented)
    static of<R extends Radius = Radius, P extends Position = Position>(rx: R, ry: R, center: P): Ellipse<R, P>;
    // (undocumented)
    get rx(): R;
    // (undocumented)
    get ry(): R;
    // (undocumented)
    toJSON(): Ellipse.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "basic-shape";
}

// @public (undocumented)
export namespace Ellipse {
    // (undocumented)
    export function isEllipse(value: unknown): value is Ellipse;
    // (undocumented)
    export interface JSON extends Value.JSON<"basic-shape"> {
        // (undocumented)
        center: Position.JSON;
        // (undocumented)
        kind: "ellipse";
        // (undocumented)
        rx: Radius.JSON;
        // (undocumented)
        ry: Radius.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Ellipse, string>;
}

// @public (undocumented)
class Function_2 implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(name: string, value: Iterable<Token>): Function_2;
    // (undocumented)
    toJSON(): Function_2.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): Array<Token>;
}

// @public (undocumented)
namespace Function_2 {
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        name: string;
        // (undocumented)
        value: Array<Token.JSON>;
    }
    const // (undocumented)
    consume: Parser<Slice<Token>, Function_2>;
    const // (undocumented)
    parse: <T>(name?: string, body?: Parser<Slice<Token>, T, string, []> | undefined) => Parser<Slice<Token>, readonly [Function_2, T], string, []>;
}
export { Function_2 as Function }

// @public (undocumented)
export type Gradient = Linear | Radial;

// @public (undocumented)
export namespace Gradient {
    // (undocumented)
    export class Hint<P extends Length | Percentage = Length | Percentage> implements Equatable, Hashable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of<P extends Length | Percentage>(position: P): Hint<P>;
        // (undocumented)
        get position(): P;
        // (undocumented)
        toJSON(): Hint.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "hint";
    }
    // (undocumented)
    export namespace Hint {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            position: Length.JSON | Percentage.JSON;
            // (undocumented)
            type: "hint";
        }
    }
    // (undocumented)
    export type Item = Stop | Hint;
    const // (undocumented)
    parseStop: Parser<Slice<Token>, Stop, string>;
    // (undocumented)
    export namespace Item {
        // (undocumented)
        export type JSON = Stop.JSON | Hint.JSON;
    }
    // (undocumented)
    export type JSON = Linear.JSON | Radial.JSON;
    const // (undocumented)
    parseHint: Parser<Slice<Token>, Hint, string>;
    // (undocumented)
    export class Stop<C extends Color = Color, P extends Length | Percentage = Length | Percentage> implements Equatable, Hashable, Serializable {
        // (undocumented)
        get color(): C;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of<C extends Color, P extends Length | Percentage>(color: C, position?: Option<P>): Stop<C, P>;
        // (undocumented)
        get position(): Option<P>;
        // (undocumented)
        toJSON(): Stop.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "stop";
    }
    // (undocumented)
    export namespace Stop {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            color: Color.JSON;
            // (undocumented)
            position: Length.JSON | Percentage.JSON | null;
            // (undocumented)
            type: "stop";
        }
    }
    const // (undocumented)
    parseItem: Parser<Slice<Token>, Item, string>;
    const // (undocumented)
    parseItemList: Parser<Slice<Token>, Array<Item>, string>;
    const // (undocumented)
    parse: Parser<Slice<Token>, Gradient, string>;
}

// @public (undocumented)
export class Hex extends Value<"color"> {
    // (undocumented)
    get alpha(): Number_2;
    // (undocumented)
    get blue(): Number_2;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get format(): "hex";
    // (undocumented)
    get green(): Number_2;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(value: number): Hex;
    // (undocumented)
    get red(): Number_2;
    // (undocumented)
    toJSON(): Hex.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "color";
    // (undocumented)
    get value(): number;
}

// @public (undocumented)
export namespace Hex {
    // (undocumented)
    export function isHex(value: unknown): value is Hex;
    // (undocumented)
    export interface JSON extends Value.JSON<"color"> {
        // (undocumented)
        format: "hex";
        // (undocumented)
        value: number;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Hex, string>;
}

// @public (undocumented)
export class HSL<H extends Number_2 | Angle = Number_2 | Angle, A extends Number_2 | Percentage = Number_2 | Percentage> extends Value<"color"> {
    // (undocumented)
    get alpha(): A;
    // (undocumented)
    get blue(): Percentage;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get format(): "hsl";
    // (undocumented)
    get green(): Percentage;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get hue(): H;
    // (undocumented)
    get lightness(): Percentage;
    // (undocumented)
    static of<H extends Number_2 | Angle, A extends Number_2 | Percentage>(hue: H, saturation: Percentage, lightness: Percentage, alpha: A): HSL<H, A>;
    // (undocumented)
    get red(): Percentage;
    // (undocumented)
    get saturation(): Percentage;
    // (undocumented)
    toJSON(): HSL.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "color";
}

// @public (undocumented)
export namespace HSL {
    // (undocumented)
    export function isHSL<H extends Number_2 | Angle, A extends Number_2 | Percentage>(value: unknown): value is HSL<H, A>;
    // (undocumented)
    export interface JSON extends Value.JSON<"color"> {
        // (undocumented)
        alpha: Number_2.JSON | Percentage.JSON;
        // (undocumented)
        format: "hsl";
        // (undocumented)
        hue: Number_2.JSON | Angle.JSON;
        // (undocumented)
        lightness: Percentage.JSON;
        // (undocumented)
        saturation: Percentage.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, HSL, string>;
}

// @public (undocumented)
export class Image<I extends URL | Gradient = URL | Gradient> extends Value<"image"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get image(): I;
    // (undocumented)
    static of<I extends URL | Gradient>(image: I): Image<I>;
    // (undocumented)
    toJSON(): Image.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "image";
}

// @public (undocumented)
export namespace Image {
    // (undocumented)
    export function isImage<I extends URL | Gradient>(value: unknown): value is Image<I>;
    // (undocumented)
    export interface JSON extends Value.JSON<"image"> {
        // (undocumented)
        image: URL.JSON | Gradient.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Image, string>;
}

// @public (undocumented)
export class Inset<O extends Inset.Offset = Inset.Offset, C extends Inset.Corner = Inset.Corner> extends Value<"basic-shape"> {
    // (undocumented)
    get bottom(): O;
    // (undocumented)
    get bottomLeft(): Option<C>;
    // (undocumented)
    get bottomRight(): Option<C>;
    // (undocumented)
    get corners(): Option<readonly [C, C, C, C]>;
    // (undocumented)
    equals(value: Inset): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "inset";
    // (undocumented)
    get left(): O;
    // (undocumented)
    static of<O extends Inset.Offset = Inset.Offset, C extends Inset.Corner = Inset.Corner>(offsets: readonly [O, O, O, O], corners: Option<readonly [C, C, C, C]>): Inset<O, C>;
    // (undocumented)
    get offsets(): readonly [O, O, O, O];
    // (undocumented)
    get right(): O;
    // (undocumented)
    toJSON(): Inset.JSON<O, C>;
    // (undocumented)
    get top(): O;
    // (undocumented)
    get topLeft(): Option<C>;
    // (undocumented)
    get topRight(): Option<C>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "basic-shape";
}

// @public (undocumented)
export namespace Inset {
    // (undocumented)
    export type Corner = Radius | readonly [Radius, Radius];
    // (undocumented)
    export interface JSON<O extends Offset = Offset, C extends Corner = Corner> extends Value.JSON<"basic-shape"> {
        // (undocumented)
        corners: Option.JSON<readonly [C, C, C, C]>;
        // (undocumented)
        kind: "inset";
        // (undocumented)
        offsets: Serializable.ToJSON<readonly [O, O, O, O]>;
    }
    // (undocumented)
    export type Offset = Length | Percentage;
    // (undocumented)
    export type Radius = Length | Percentage;
    const // (undocumented)
    parse: Parser<Slice<Token>, Inset, string>;
}

// @public (undocumented)
export class Integer extends Numeric<"integer"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(value: number): Integer;
    // (undocumented)
    scale(factor: number): Integer;
}

// @public (undocumented)
export namespace Integer {
    // (undocumented)
    export function isInteger(value: unknown): value is Integer;
    // (undocumented)
    export interface JSON extends Numeric.JSON<"integer"> {
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Integer, string>;
}

// @public (undocumented)
export class Keyword<T extends string = string> extends Value<"keyword"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<T extends string>(value: T): Keyword<T>;
    // (undocumented)
    toJSON(): Keyword.JSON<T>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "keyword";
    // (undocumented)
    get value(): T;
}

// @public (undocumented)
export namespace Keyword {
    // (undocumented)
    export function isKeyword(value: unknown): value is Keyword;
    // (undocumented)
    export interface JSON<T extends string = string> extends Value.JSON<"keyword"> {
        // (undocumented)
        value: T;
    }
    // (undocumented)
    export function parse<T extends string>(...keywords: Array<T>): Parser<Slice<Token>, {
        [K in T]: Keyword<K>;
    }[T], string>;
}

// @public (undocumented)
export class Length<U extends Unit.Length = Unit.Length> extends Dimension<"length", Unit.Length, U> implements Convertible<Unit.Length.Absolute> {
    // (undocumented)
    get canonicalUnit(): "px";
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    hasUnit<U extends Unit.Length>(unit: U): this is Length<U>;
    // (undocumented)
    isAbsolute(): this is Length<Unit.Length.Absolute>;
    // (undocumented)
    isFontRelative(): this is Length<Unit.Length.Relative.Font>;
    // (undocumented)
    isRelative(): this is Length<Unit.Length.Relative>;
    // (undocumented)
    isViewportRelative(): this is Length<Unit.Length.Relative.Viewport>;
    // (undocumented)
    static of<U extends Unit.Length>(value: number, unit: U): Length<U>;
    // (undocumented)
    scale(factor: number): Length<U>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    withUnit<U extends Unit.Length>(unit: U): Length<U>;
}

// @public (undocumented)
export namespace Length {
    // (undocumented)
    export function isLength(value: unknown): value is Length;
    // (undocumented)
    export function isZero(length: Length): boolean;
    const // (undocumented)
    parse: Parser<Slice<Token>, Length, string>;
    // (undocumented)
    export interface JSON<U extends Unit.Length = Unit.Length> extends Dimension.JSON<"length", U> {
    }
}

// @public (undocumented)
export namespace Lexer {
    // (undocumented)
    export function lex(input: string): Slice<Token>;
}

// @public (undocumented)
export class Linear<I extends Gradient.Item = Gradient.Item, D extends Linear.Direction = Linear.Direction> extends Value<"gradient"> {
    // (undocumented)
    get direction(): D;
    // (undocumented)
    equals(value: Linear): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get items(): Iterable<I>;
    // (undocumented)
    get kind(): "linear";
    // (undocumented)
    static of<I extends Gradient.Item, D extends Linear.Direction>(direction: D, items: Iterable<I>, repeats: boolean): Linear<I, D>;
    // (undocumented)
    get repeats(): boolean;
    // (undocumented)
    toJSON(): Linear.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "gradient";
}

// @public (undocumented)
export namespace Linear {
    // (undocumented)
    export class Corner implements Equatable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        get horizontal(): Position.Horizontal;
        // (undocumented)
        static of(vertical: Position.Vertical, horizontal: Position.Horizontal): Corner;
        // (undocumented)
        toJSON(): Corner.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "corner";
        // (undocumented)
        get vertical(): Position.Vertical;
    }
    // (undocumented)
    export namespace Corner {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            horizontal: Position.Horizontal;
            // (undocumented)
            type: "corner";
            // (undocumented)
            vertical: Position.Vertical;
        }
    }
    // (undocumented)
    export type Direction = Angle | Side | Corner;
    // (undocumented)
    export namespace Direction {
        // (undocumented)
        export type JSON = Angle.JSON | Side.JSON | Corner.JSON;
    }
    // (undocumented)
    export interface JSON extends Value.JSON<"gradient"> {
        // (undocumented)
        direction: Direction.JSON;
        // (undocumented)
        items: Array<Gradient.Item.JSON>;
        // (undocumented)
        kind: "linear";
        // (undocumented)
        repeats: boolean;
    }
    // (undocumented)
    export type Position = Position.Vertical | Position.Horizontal;
    // (undocumented)
    export namespace Position {
        // (undocumented)
        export type Horizontal = "left" | "right";
        // (undocumented)
        export type Vertical = "top" | "bottom";
        const // (undocumented)
        parseVertical: Parser<Slice<Token>, Vertical, string, []>;
        const // (undocumented)
        parseHorizontal: Parser<Slice<Token>, Horizontal, string, []>;
        const // (undocumented)
        parse: Parser<Slice<Token>, Vertical | Horizontal, string, []>;
    }
    // (undocumented)
    export class Side implements Equatable, Hashable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of(side: Position.Vertical | Position.Horizontal): Side;
        // (undocumented)
        get side(): Position.Vertical | Position.Horizontal;
        // (undocumented)
        toJSON(): Side.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "side";
    }
    // (undocumented)
    export namespace Side {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            side: Position.Vertical | Position.Horizontal;
            // (undocumented)
            type: "side";
        }
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Linear, string>;
}

// @public (undocumented)
export class Matrix extends Value<"transform"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "matrix";
    // (undocumented)
    static of(...values: Matrix.Values<Number_2>): Matrix;
    // (undocumented)
    toJSON(): Matrix.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "transform";
    // (undocumented)
    get values(): Matrix.Values<Number_2>;
}

// @public (undocumented)
export namespace Matrix {
    // (undocumented)
    export function isMatrix(value: unknown): value is Matrix;
    // (undocumented)
    export interface JSON extends Value.JSON<"transform"> {
        // (undocumented)
        kind: "matrix";
        // (undocumented)
        values: Values<Number_2.JSON>;
    }
    // (undocumented)
    export type Values<T> = [
    [
    T,
    T,
    T,
    T
    ],
    [
    T,
    T,
    T,
    T
    ],
    [
    T,
    T,
    T,
    T
    ],
    [
    T,
    T,
    T,
    T
    ]
    ];
    const // (undocumented)
    parse: Parser<Slice<Token>, Matrix, string>;
}

// @public (undocumented)
export class Named<C extends Named.Color = Named.Color> extends Value<"color"> {
    // (undocumented)
    get alpha(): Number_2;
    // (undocumented)
    get blue(): Number_2;
    // (undocumented)
    get color(): C;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get format(): "named";
    // (undocumented)
    get green(): Number_2;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<C extends Named.Color>(color: C): Named<C>;
    // (undocumented)
    get red(): Number_2;
    // (undocumented)
    toJSON(): Named.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "color";
    // (undocumented)
    get value(): number;
}

// @public (undocumented)
export namespace Named {
    // Warning: (ae-forgotten-export) The symbol "Colors" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export type Color = keyof Colors;
    // (undocumented)
    export interface JSON extends Value.JSON<"color"> {
        // (undocumented)
        color: string;
        // (undocumented)
        format: "named";
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Named, string>;
}

// @public (undocumented)
export class Nth implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    for(n: number): number;
    // (undocumented)
    indices(): Iterable<number>;
    matches(index: number): boolean;
    // (undocumented)
    static of(step: number, offset?: number): Nth;
    // (undocumented)
    get offset(): number;
    // (undocumented)
    get step(): number;
    // (undocumented)
    toJSON(): Nth.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Nth {
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        offset: number;
        // (undocumented)
        step: number;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Nth, string>;
}

// @public (undocumented)
class Number_2 extends Numeric<"number"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(value: number): Number_2;
    // (undocumented)
    scale(factor: number): Number_2;
}

// @public (undocumented)
namespace Number_2 {
    // (undocumented)
    function isNumber(value: unknown): value is Number_2;
    // (undocumented)
    interface JSON extends Numeric.JSON<"number"> {
    }
    const // (undocumented)
    parseZero: Parser<Slice<Token>, Number_2, string>;
    const // (undocumented)
    parse: Parser<Slice<Token>, Number_2, string>;
}
export { Number_2 as Number }

// @public (undocumented)
export abstract class Numeric<T extends Numeric.Type = Numeric.Type> extends Value<T> implements Comparable<Numeric<T>> {
    protected constructor(value: number, type: T);
    // (undocumented)
    compare(value: Numeric<T>): Comparison;
    static readonly Decimals = 7;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    abstract scale(factor: number): Numeric<T>;
    // (undocumented)
    toJSON(): Numeric.JSON<T>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): T;
    // (undocumented)
    protected readonly _type: T;
    // (undocumented)
    get value(): number;
    // (undocumented)
    protected readonly _value: number;
}

// @public (undocumented)
export namespace Numeric {
    // (undocumented)
    export type Dimension = "angle" | "length";
    // (undocumented)
    export function isNumeric(value: unknown): value is Numeric;
    // Warning: (ae-incompatible-release-tags) The symbol "JSON" is marked as @public, but its signature references "Type" which is marked as @internal
    //
    // (undocumented)
    export interface JSON<T extends Type = Type> extends Value.JSON<T> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: T;
        // (undocumented)
        value: number;
    }
    // (undocumented)
    export type Ratio = "percentage";
    // (undocumented)
    export type Scalar = "integer" | "number";
    // @internal (undocumented)
    export type Type = Scalar | Ratio | Dimension;
}

// @public (undocumented)
export class Percentage extends Numeric<"percentage"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(value: number): Percentage;
    // (undocumented)
    scale(factor: number): Percentage;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Percentage {
    // (undocumented)
    export function isPercentage(value: unknown): value is Percentage;
    // (undocumented)
    export interface JSON extends Numeric.JSON<"percentage"> {
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Percentage, string>;
}

// @public (undocumented)
export class Perspective<D extends Length = Length> extends Value<"transform"> {
    // (undocumented)
    get depth(): D;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "perspective";
    // (undocumented)
    static of<D extends Length>(depth: D): Perspective<D>;
    // (undocumented)
    toJSON(): Perspective.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "transform";
}

// @public (undocumented)
export namespace Perspective {
    // (undocumented)
    export function isPerspective<D extends Length>(value: unknown): value is Perspective<D>;
    // (undocumented)
    export interface JSON extends Value.JSON<"transform"> {
        // (undocumented)
        depth: Length.JSON;
        // (undocumented)
        kind: "perspective";
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Perspective, string>;
}

// @public (undocumented)
export class Polygon<F extends Polygon.Fill = Polygon.Fill, V extends Length | Percentage = Length | Percentage> extends Value<"basic-shape"> {
    // (undocumented)
    equals(value: Polygon): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get fill(): Option<F>;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "polygon";
    // (undocumented)
    static of<F extends Polygon.Fill = Polygon.Fill, V extends Length | Percentage = Length | Percentage>(fill: Option<F>, vertices: Iterable_2<Polygon.Vertex<V>>): Polygon<F, V>;
    // (undocumented)
    toJSON(): Polygon.JSON<F, V>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "basic-shape";
    // (undocumented)
    get vertices(): ReadonlyArray<Polygon.Vertex<V>>;
}

// @public (undocumented)
export namespace Polygon {
    // (undocumented)
    export type Fill = Keyword<"nonzero"> | Keyword<"evenodd">;
    // (undocumented)
    export interface JSON<F extends Fill = Fill, V extends Length | Percentage = Length | Percentage> extends Value.JSON<"basic-shape"> {
        // (undocumented)
        fill: Option.JSON<F>;
        // (undocumented)
        kind: "polygon";
        // (undocumented)
        vertices: Array_2<Serializable.ToJSON<Vertex<V>>>;
    }
    // (undocumented)
    export type Vertex<V extends Length | Percentage = Length | Percentage> = readonly [V, V];
    const // (undocumented)
    parse: Parser<Slice<Token>, Polygon, string>;
}

// @public (undocumented)
export class Position<H extends Position.Component<Position.Horizontal> = Position.Component<Position.Horizontal>, V extends Position.Component<Position.Vertical> = Position.Component<Position.Vertical>> extends Value<"position"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get horizontal(): H;
    // (undocumented)
    static of<H extends Position.Component<Position.Horizontal>, V extends Position.Component<Position.Vertical>>(horizontal: H, vertical: V): Position<H, V>;
    // (undocumented)
    toJSON(): Position.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "position";
    // (undocumented)
    get vertical(): V;
}

// @public (undocumented)
export namespace Position {
    // (undocumented)
    export type Center = Keyword<"center">;
    // (undocumented)
    export type Component<S extends Horizontal | Vertical = Horizontal | Vertical, U extends Unit.Length = Unit.Length> = Center | Offset<U> | Side<S, Offset<U>>;
    const // (undocumented)
    parseCenter: Parser<Slice<Token>, Keyword<"center">, string, []>;
    // (undocumented)
    export namespace Component {
        // (undocumented)
        export type JSON = Keyword.JSON | Length.JSON | Percentage.JSON | Side.JSON;
    }
    // (undocumented)
    export type Horizontal = Keyword<"left"> | Keyword<"right">;
    // (undocumented)
    export interface JSON extends Value.JSON<"position"> {
        // (undocumented)
        horizontal: Component.JSON;
        // (undocumented)
        vertical: Component.JSON;
    }
    // (undocumented)
    export type Offset<U extends Unit.Length = Unit.Length> = Length<U> | Percentage;
    // (undocumented)
    export function parse(legacySyntax?: boolean): Parser<Slice<Token>, Position, string>;
    // (undocumented)
    export class Side<S extends Vertical | Horizontal = Vertical | Horizontal, O extends Offset = Offset> extends Value<"side"> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        isCenter(): boolean;
        // (undocumented)
        static of<S extends Vertical | Horizontal, O extends Offset>(side: S, offset?: Option<O>): Side<S, O>;
        // (undocumented)
        get offset(): Option<O>;
        // (undocumented)
        get side(): S;
        // (undocumented)
        toJSON(): Side.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "side";
    }
    // (undocumented)
    export namespace Side {
        // (undocumented)
        export interface JSON extends Value.JSON<"side"> {
            // (undocumented)
            offset: Length.JSON | Percentage.JSON | null;
            // (undocumented)
            side: Keyword.JSON;
        }
    }
    // (undocumented)
    export type Vertical = Keyword<"top"> | Keyword<"bottom">;
        {};
}

// @public (undocumented)
export class Radial<I extends Gradient.Item = Gradient.Item, S extends Radial.Shape = Radial.Shape, P extends Position = Position> extends Value<"gradient"> {
    // (undocumented)
    equals(value: Radial): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get items(): Iterable<I>;
    // (undocumented)
    get kind(): "radial";
    // (undocumented)
    static of<I extends Gradient.Item = Gradient.Item, S extends Radial.Shape = Radial.Shape, P extends Position = Position>(shape: S, position: P, items: Iterable<I>, repeats: boolean): Radial<I, S, P>;
    // (undocumented)
    get position(): P;
    // (undocumented)
    get repeats(): boolean;
    // (undocumented)
    get shape(): S;
    // (undocumented)
    toJSON(): Radial.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "gradient";
}

// @public (undocumented)
export namespace Radial {
    // (undocumented)
    export class Circle<R extends Length = Length> implements Equatable, Hashable, Serializable<Circle.JSON> {
        // (undocumented)
        equals(value: Circle): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of<R extends Length>(radius: R): Circle<R>;
        // (undocumented)
        get radius(): R;
        // (undocumented)
        toJSON(): Circle.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "circle";
    }
    // (undocumented)
    export namespace Circle {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            radius: Length.JSON;
            // (undocumented)
            type: "circle";
        }
    }
    // (undocumented)
    export class Ellipse<R extends Length | Percentage = Length | Percentage> implements Equatable, Hashable, Serializable<Ellipse.JSON> {
        // (undocumented)
        equals(value: Ellipse): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        get horizontal(): R;
        // (undocumented)
        static of<R extends Length | Percentage>(horizontal: R, vertical: R): Ellipse<R>;
        // (undocumented)
        toJSON(): Ellipse.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "ellipse";
        // (undocumented)
        get vertical(): R;
    }
    // (undocumented)
    export namespace Ellipse {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            horizontal: Length.JSON | Percentage.JSON;
            // (undocumented)
            type: "ellipse";
            // (undocumented)
            vertical: Length.JSON | Percentage.JSON;
        }
    }
    // (undocumented)
    export class Extent implements Equatable, Hashable, Serializable<Extent.JSON> {
        // (undocumented)
        equals(value: Extent): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of(shape?: Extent.Shape, size?: Extent.Size): Extent;
        // (undocumented)
        get shape(): Extent.Shape;
        // (undocumented)
        get size(): Extent.Size;
        // (undocumented)
        toJSON(): Extent.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "extent";
    }
    // (undocumented)
    export namespace Extent {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            shape: `${Shape}`;
            // (undocumented)
            size: `${Size}`;
            // (undocumented)
            type: "extent";
        }
        // (undocumented)
        export enum Shape {
            // (undocumented)
            Circle = "circle",
            // (undocumented)
            Ellipse = "ellipse"
        }
        // (undocumented)
        export enum Size {
            // (undocumented)
            ClosestCorner = "closest-corner",
            // (undocumented)
            ClosestSide = "closest-side",
            // (undocumented)
            FarthestCorner = "farthest-corner",
            // (undocumented)
            FarthestSide = "farthest-side"
        }
    }
    // (undocumented)
    export interface JSON extends Value.JSON<"gradient"> {
        // (undocumented)
        items: Array<Gradient.Item.JSON>;
        // (undocumented)
        kind: "radial";
        // (undocumented)
        position: Position.JSON;
        // (undocumented)
        repeats: boolean;
        // (undocumented)
        shape: Shape.JSON;
    }
    // (undocumented)
    export type Shape = Circle | Ellipse | Extent;
    // (undocumented)
    export namespace Shape {
        // (undocumented)
        export type JSON = Circle.JSON | Ellipse.JSON | Extent.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Radial, string>;
}

// @public (undocumented)
export class Radius<R extends Length | Percentage | Radius.Side = Length | Percentage | Radius.Side> extends Value<"basic-shape"> {
    // (undocumented)
    equals(value: Radius): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "radius";
    // (undocumented)
    static of<R extends Length | Percentage | Radius.Side>(value: R): Radius<R>;
    // (undocumented)
    toJSON(): Radius.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "basic-shape";
    // (undocumented)
    get value(): R;
}

// @public (undocumented)
export namespace Radius {
    // (undocumented)
    export function isRadius(value: unknown): value is Radius;
    // (undocumented)
    export interface JSON extends Value.JSON<"basic-shape"> {
        // (undocumented)
        kind: "radius";
        // (undocumented)
        value: Length.JSON | Percentage.JSON | Keyword.JSON;
    }
    // (undocumented)
    export type Side = Side.Closest | Side.Farthest;
    // (undocumented)
    export namespace Side {
        // (undocumented)
        export type Closest = Keyword<"closest-side">;
        // (undocumented)
        export type Farthest = Keyword<"farthest-side">;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Radius, string>;
}

// @public @deprecated (undocumented)
export class Rectangle<O extends Length | Rectangle.Auto = Length | Rectangle.Auto> extends Value<"basic-shape"> {
    // (undocumented)
    get bottom(): O;
    // (undocumented)
    readonly _bottom: O;
    // (undocumented)
    equals(value: Rectangle): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "rectangle";
    // (undocumented)
    get left(): O;
    // (undocumented)
    readonly _left: O;
    // (undocumented)
    static of<O extends Length | Rectangle.Auto = Length | Rectangle.Auto>(top: O, right: O, bottom: O, left: O): Rectangle<O>;
    // (undocumented)
    get right(): O;
    // (undocumented)
    readonly _right: O;
    // (undocumented)
    toJSON(): Rectangle.JSON;
    // (undocumented)
    get top(): O;
    // (undocumented)
    readonly _top: O;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "basic-shape";
}

// @public @deprecated (undocumented)
export namespace Rectangle {
    // (undocumented)
    export type Auto = Keyword<"auto">;
    // (undocumented)
    export function isRectangle(value: unknown): value is Rectangle;
    // (undocumented)
    export interface JSON extends Value.JSON<"basic-shape"> {
        // (undocumented)
        bottom: Length.JSON | Keyword.JSON;
        // (undocumented)
        kind: "rectangle";
        // (undocumented)
        left: Length.JSON | Keyword.JSON;
        // (undocumented)
        right: Length.JSON | Keyword.JSON;
        // (undocumented)
        top: Length.JSON | Keyword.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Rectangle, string>;
}

// @public (undocumented)
export class RGB<C extends Number_2 | Percentage = Number_2 | Percentage, A extends Number_2 | Percentage = Number_2 | Percentage> extends Value<"color"> {
    // (undocumented)
    get alpha(): A;
    // (undocumented)
    get blue(): C;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get format(): "rgb";
    // (undocumented)
    get green(): C;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<C extends Number_2 | Percentage, A extends Number_2 | Percentage>(red: C, green: C, blue: C, alpha: A): RGB<C, A>;
    // (undocumented)
    get red(): C;
    // (undocumented)
    toJSON(): RGB.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "color";
}

// @public (undocumented)
export namespace RGB {
    // (undocumented)
    export function isRGB<C extends Number_2 | Percentage, A extends Number_2 | Percentage>(value: unknown): value is RGB<C, A>;
    // (undocumented)
    export interface JSON extends Value.JSON<"color"> {
        // (undocumented)
        alpha: Number_2.JSON | Percentage.JSON;
        // (undocumented)
        blue: Number_2.JSON | Percentage.JSON;
        // (undocumented)
        format: "rgb";
        // (undocumented)
        green: Number_2.JSON | Percentage.JSON;
        // (undocumented)
        red: Number_2.JSON | Percentage.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, RGB, string>;
}

// @public (undocumented)
export class Rotate<A extends Angle = Angle> extends Value<"transform"> {
    // (undocumented)
    get angle(): A;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "rotate";
    // (undocumented)
    static of<A extends Angle>(x: Number_2, y: Number_2, z: Number_2, angle: A): Rotate<A>;
    // (undocumented)
    toJSON(): Rotate.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "transform";
    // (undocumented)
    get x(): Number_2;
    // (undocumented)
    get y(): Number_2;
    // (undocumented)
    get z(): Number_2;
}

// @public (undocumented)
export namespace Rotate {
    // (undocumented)
    export function isRotate<A extends Angle>(value: unknown): value is Rotate<A>;
    // (undocumented)
    export interface JSON extends Value.JSON<"transform"> {
        // (undocumented)
        angle: Angle.JSON;
        // (undocumented)
        kind: "rotate";
        // (undocumented)
        x: Number_2.JSON;
        // (undocumented)
        y: Number_2.JSON;
        // (undocumented)
        z: Number_2.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Rotate, string>;
}

// @public (undocumented)
export class Scale extends Value<"transform"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "scale";
    // (undocumented)
    static of(x: Number_2, y: Number_2): Scale;
    // (undocumented)
    toJSON(): Scale.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "transform";
    // (undocumented)
    get x(): Number_2;
    // (undocumented)
    get y(): Number_2;
}

// @public (undocumented)
export namespace Scale {
    // (undocumented)
    export function isScale(value: unknown): value is Scale;
    // (undocumented)
    export interface JSON extends Value.JSON<"transform"> {
        // (undocumented)
        kind: "scale";
        // (undocumented)
        x: Number_2.JSON;
        // (undocumented)
        y: Number_2.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Scale, string>;
}

// @public (undocumented)
export class Shadow<H extends Length = Length, V extends Length = H, B extends Length = Length, S extends Length = Length, C extends Color = Color> extends Value<"shadow"> {
    // (undocumented)
    get blur(): B;
    // (undocumented)
    get color(): C;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get horizontal(): H;
    // (undocumented)
    get isInset(): boolean;
    // (undocumented)
    static of<H extends Length = Length, V extends Length = H, B extends Length = Length, S extends Length = Length, C extends Color = Color>(horizontal: H, vertical: V, blur: B, spread: S, color: C, isInset: boolean): Shadow<H, V, B, S, C>;
    // (undocumented)
    get spread(): S;
    // (undocumented)
    toJSON(): Shadow.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "shadow";
    // (undocumented)
    get vertical(): V;
}

// @public (undocumented)
export namespace Shadow {
    // (undocumented)
    export interface JSON extends Value.JSON<"shadow"> {
        // (undocumented)
        blur: Length.JSON;
        // (undocumented)
        color: Color.JSON;
        // (undocumented)
        horizontal: Length.JSON;
        // (undocumented)
        isInset: boolean;
        // (undocumented)
        spread: Length.JSON;
        // (undocumented)
        vertical: Length.JSON;
    }
}

// @public (undocumented)
export class Shape<S extends Shape.Basic = Shape.Basic, B extends Box.Geometry = Box.Geometry> extends Value<"shape"> {
    // (undocumented)
    get box(): B;
    // (undocumented)
    equals(value: Shape): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<S extends Shape.Basic = Shape.Basic, B extends Box.Geometry = Box.Geometry>(shape: S, box: B): Shape<S, B>;
    // (undocumented)
    get shape(): S;
    // (undocumented)
    toJSON(): Shape.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "shape";
}

// @public (undocumented)
export namespace Shape {
    // (undocumented)
    export type Basic = Circle | Ellipse | Inset | Polygon | Rectangle;
    // (undocumented)
    export interface JSON extends Value.JSON<"shape"> {
        // (undocumented)
        box: Box.Geometry.JSON;
        // (undocumented)
        shape: Circle.JSON | Ellipse.JSON | Inset.JSON | Polygon.JSON | Rectangle.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Shape<Circle | Ellipse | Inset | Polygon>, string>;
}

// @public (undocumented)
export class Skew<X extends Angle = Angle, Y extends Angle = Angle> extends Value<"transform"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "skew";
    // (undocumented)
    static of<X extends Angle, Y extends Angle>(x: X, y: Y): Skew<X, Y>;
    // (undocumented)
    toJSON(): Skew.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "transform";
    // (undocumented)
    get x(): X;
    // (undocumented)
    get y(): Y;
}

// @public (undocumented)
export namespace Skew {
    // (undocumented)
    export function isSkew<X extends Angle, Y extends Angle>(value: unknown): value is Skew<X, Y>;
    // (undocumented)
    export interface JSON extends Value.JSON<"transform"> {
        // (undocumented)
        kind: "skew";
        // (undocumented)
        x: Angle.JSON;
        // (undocumented)
        y: Angle.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Skew, string>;
}

// @public (undocumented)
class String_2 extends Value<"string"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(value: string): String_2;
    // (undocumented)
    toJSON(): String_2.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "string";
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
namespace String_2 {
    // (undocumented)
    function isString(value: unknown): value is String_2;
    // (undocumented)
    interface JSON extends Value.JSON<"string"> {
        // (undocumented)
        value: string;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, String_2, string>;
}
export { String_2 as String }

// @public (undocumented)
export type System = Keyword<System.Keyword>;

// @public (undocumented)
export namespace System {
    // (undocumented)
    export type Keyword = "canvas" | "canvastext" | "linktext" | "visitedtext" | "activetext" | "buttonface" | "buttontext" | "field" | "fieldtext" | "highlight" | "highlighttext" | "graytext";
    const // (undocumented)
    parse: Parser<Slice<Token>, System, string>;
}

// @public (undocumented)
export type Token = Token.Ident | Token.Function | Token.AtKeyword | Token.Hash | Token.String | Token.URL | Token.BadURL | Token.Delim | Token.Number | Token.Percentage | Token.Dimension | Token.Whitespace | Token.Colon | Token.Semicolon | Token.Comma | Token.OpenParenthesis | Token.CloseParenthesis | Token.OpenSquareBracket | Token.CloseSquareBracket | Token.OpenCurlyBracket | Token.CloseCurlyBracket | Token.OpenComment | Token.CloseComment;

// @public (undocumented)
export namespace Token {
    // (undocumented)
    export class AtKeyword implements Equatable, Serializable<AtKeyword.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): AtKeyword;
        // (undocumented)
        toJSON(): AtKeyword.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "at-keyword";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace AtKeyword {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "at-keyword";
            // (undocumented)
            value: string;
        }
    }
    // (undocumented)
    export class BadURL implements Equatable, Serializable<BadURL.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): BadURL;
        // (undocumented)
        toJSON(): BadURL.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "bad-url";
    }
    const // (undocumented)
    ident: typeof Ident.of, // (undocumented)
    isIdent: typeof Ident.isIdent;
    // (undocumented)
    export namespace BadURL {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "bad-url";
        }
    }
    // (undocumented)
    export class CloseComment implements Equatable, Serializable<CloseComment.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): CloseComment;
        // (undocumented)
        toJSON(): CloseComment.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "close-comment";
    }
    // (undocumented)
    export namespace CloseComment {
        // (undocumented)
        export function isCloseComment(value: unknown): value is CloseComment;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "close-comment";
        }
    }
    const // (undocumented)
    func: typeof Function.of, // (undocumented)
    isFunction: typeof Function.isFunction;
    // (undocumented)
    export class CloseCurlyBracket implements Equatable, Serializable<CloseCurlyBracket.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): OpenCurlyBracket;
        // (undocumented)
        static of(): CloseCurlyBracket;
        // (undocumented)
        toJSON(): CloseCurlyBracket.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "close-curly-bracket";
    }
    // (undocumented)
    export namespace CloseCurlyBracket {
        // (undocumented)
        export function isCloseCurlyBracket(value: unknown): value is CloseCurlyBracket;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "close-curly-bracket";
        }
    }
    // (undocumented)
    export class CloseParenthesis implements Equatable, Serializable<CloseParenthesis.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): OpenParenthesis;
        // (undocumented)
        static of(): CloseParenthesis;
        // (undocumented)
        toJSON(): CloseParenthesis.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "close-parenthesis";
    }
    const // (undocumented)
    atKeyword: typeof AtKeyword.of;
    // (undocumented)
    export namespace CloseParenthesis {
        // (undocumented)
        export function isCloseParenthesis(value: unknown): value is CloseParenthesis;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "close-parenthesis";
        }
    }
    // (undocumented)
    export class CloseSquareBracket implements Equatable, Serializable<CloseSquareBracket.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): OpenSquareBracket;
        // (undocumented)
        static of(): CloseSquareBracket;
        // (undocumented)
        toJSON(): CloseSquareBracket.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "close-square-bracket";
    }
    const // (undocumented)
    hash: typeof Hash.of, // (undocumented)
    isHash: typeof Hash.isHash;
    // (undocumented)
    export namespace CloseSquareBracket {
        // (undocumented)
        export function isCloseSquareBracket(value: unknown): value is CloseSquareBracket;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "close-square-bracket";
        }
    }
    // (undocumented)
    export class Colon implements Equatable, Serializable<Colon.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): Colon;
        // (undocumented)
        toJSON(): Colon.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "colon";
    }
    // (undocumented)
    export namespace Colon {
        // (undocumented)
        export function isColon(value: unknown): value is Colon;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "colon";
        }
    }
    const // (undocumented)
    string: typeof String.of, // (undocumented)
    isString: typeof String.isString;
    // (undocumented)
    export class Comma implements Equatable, Serializable<Comma.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): Comma;
        // (undocumented)
        toJSON(): Comma.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "comma";
    }
    // (undocumented)
    export namespace Comma {
        // (undocumented)
        export function isComma(value: unknown): value is Comma;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "comma";
        }
    }
    // (undocumented)
    export class Delim implements Equatable, Serializable<Delim.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number): Delim;
        // (undocumented)
        toJSON(): Delim.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "delim";
        // (undocumented)
        get value(): number;
    }
    const // (undocumented)
    url: typeof URL.of, // (undocumented)
    isURL: typeof URL.isURL;
    // (undocumented)
    export namespace Delim {
        // (undocumented)
        export function isDelim(value: unknown): value is Delim;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "delim";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export class Dimension implements Equatable, Serializable<Dimension.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get isInteger(): boolean;
        // (undocumented)
        get isSigned(): boolean;
        // (undocumented)
        static of(value: number, unit: string, isInteger: boolean, isSigned: boolean): Dimension;
        // (undocumented)
        toJSON(): Dimension.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "dimension";
        // (undocumented)
        get unit(): string;
        // (undocumented)
        get value(): number;
    }
    // (undocumented)
    export namespace Dimension {
        // (undocumented)
        export function isDimension(value: unknown): value is Dimension;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            isInteger: boolean;
            // (undocumented)
            isSigned: boolean;
            // (undocumented)
            type: "dimension";
            // (undocumented)
            unit: string;
            // (undocumented)
            value: number;
        }
    }
    const // (undocumented)
    badURL: typeof BadURL.of;
    // (undocumented)
    export class Function implements Equatable, Serializable<Function.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): CloseParenthesis;
        // (undocumented)
        static of(value: string): Function;
        // (undocumented)
        toJSON(): Function.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "function";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace Function {
        // (undocumented)
        export function isFunction(value: unknown): value is Function;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "function";
            // (undocumented)
            value: string;
        }
    }
    const // (undocumented)
    delim: typeof Delim.of, // (undocumented)
    isDelim: typeof Delim.isDelim;
    // (undocumented)
    export class Hash implements Equatable, Serializable<Hash.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get isIdentifier(): boolean;
        // (undocumented)
        static of(value: string, isIdentifier: boolean): Hash;
        // (undocumented)
        toJSON(): Hash.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "hash";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace Hash {
        // (undocumented)
        export function isHash(value: unknown): value is Hash;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            isIdentifier: boolean;
            // (undocumented)
            type: "hash";
            // (undocumented)
            value: string;
        }
    }
    // (undocumented)
    export class Ident implements Equatable, Serializable<Ident.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): Ident;
        // (undocumented)
        toJSON(): Ident.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "ident";
        // (undocumented)
        get value(): string;
    }
    const // (undocumented)
    number: typeof Number.of, // (undocumented)
    isNumber: typeof Number.isNumber;
    // (undocumented)
    export namespace Ident {
        // (undocumented)
        export function isIdent(value: unknown): value is Ident;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "ident";
            // (undocumented)
            value: string;
        }
    }
    // (undocumented)
    export type JSON = Ident.JSON | Function.JSON | AtKeyword.JSON | Hash.JSON | String.JSON | URL.JSON | BadURL.JSON | Delim.JSON | Number.JSON | Percentage.JSON | Dimension.JSON | Whitespace.JSON | Colon.JSON | Semicolon.JSON | Comma.JSON | OpenParenthesis.JSON | CloseParenthesis.JSON | OpenSquareBracket.JSON | CloseSquareBracket.JSON | OpenCurlyBracket.JSON | CloseCurlyBracket.JSON | OpenComment.JSON | CloseComment.JSON;
    // (undocumented)
    export class Number implements Equatable, Serializable<Number.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get isInteger(): boolean;
        // (undocumented)
        get isSigned(): boolean;
        // (undocumented)
        static of(value: number, isInteger: boolean, isSigned: boolean): Number;
        // (undocumented)
        toJSON(): Number.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "number";
        // (undocumented)
        get value(): number;
    }
    const // (undocumented)
    percentage: typeof Percentage.of, // (undocumented)
    isPercentage: typeof Percentage.isPercentage;
    // (undocumented)
    export namespace Number {
        // (undocumented)
        export function isNumber(value: unknown): value is Number;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            isInteger: boolean;
            // (undocumented)
            isSigned: boolean;
            // (undocumented)
            type: "number";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export class OpenComment implements Equatable, Serializable<OpenComment.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): OpenComment;
        // (undocumented)
        toJSON(): OpenComment.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "open-comment";
    }
    // (undocumented)
    export namespace OpenComment {
        // (undocumented)
        export function isOpenComment(value: unknown): value is OpenComment;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "open-comment";
        }
    }
    const // (undocumented)
    dimension: typeof Dimension.of, // (undocumented)
    isDimension: typeof Dimension.isDimension;
    // (undocumented)
    export class OpenCurlyBracket implements Equatable, Serializable<OpenCurlyBracket.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): CloseCurlyBracket;
        // (undocumented)
        static of(): OpenCurlyBracket;
        // (undocumented)
        toJSON(): OpenCurlyBracket.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "open-curly-bracket";
    }
    // (undocumented)
    export namespace OpenCurlyBracket {
        // (undocumented)
        export function isOpenCurlyBracket(value: unknown): value is OpenCurlyBracket;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "open-curly-bracket";
        }
    }
    // (undocumented)
    export class OpenParenthesis implements Equatable, Serializable<OpenParenthesis.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): CloseParenthesis;
        // (undocumented)
        static of(): OpenParenthesis;
        // (undocumented)
        toJSON(): OpenParenthesis.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "open-parenthesis";
    }
    const // (undocumented)
    whitespace: typeof Whitespace.of, // (undocumented)
    isWhitespace: typeof Whitespace.isWhitespace;
    const // (undocumented)
    parseWhitespace: Parser<Slice<Token>, Whitespace, string, []>;
    // (undocumented)
    export namespace OpenParenthesis {
        // (undocumented)
        export function isOpenParenthesis(value: unknown): value is OpenParenthesis;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "open-parenthesis";
        }
    }
    // (undocumented)
    export class OpenSquareBracket implements Equatable, Serializable<OpenSquareBracket.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): CloseSquareBracket;
        // (undocumented)
        static of(): OpenSquareBracket;
        // (undocumented)
        toJSON(): OpenSquareBracket.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "open-square-bracket";
    }
    const // (undocumented)
    colon: typeof Colon.of, // (undocumented)
    isColon: typeof Colon.isColon;
    const // (undocumented)
    parseColon: Parser<Slice<Token>, Colon, string, []>;
    // (undocumented)
    export namespace OpenSquareBracket {
        // (undocumented)
        export function isOpenSquareBracket(value: unknown): value is OpenSquareBracket;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "open-square-bracket";
        }
    }
    // (undocumented)
    export function parseDelim(query?: string | number | Predicate<Delim>): Parser<Slice<Token>, Delim, string, []>;
    const // (undocumented)
    semicolon: typeof Semicolon.of, // (undocumented)
    isSemicolon: typeof Semicolon.isSemicolon;
    const // (undocumented)
    parseSemicolon: Parser<Slice<Token>, Semicolon, string, []>;
    // (undocumented)
    export function parseDimension(predicate?: Predicate<Dimension>): Parser<Slice<Token>, Dimension, string, []>;
    // (undocumented)
    export function parseFunction(query?: string | Predicate<Function>): Parser<Slice<Token>, Function, string, []>;
    const // (undocumented)
    comma: typeof Comma.of, // (undocumented)
    isComma: typeof Comma.isComma;
    const // (undocumented)
    parseComma: Parser<Slice<Token>, Comma, string, []>;
    // (undocumented)
    export function parseHash(predicate?: Predicate<Hash>): Parser<Slice<Token>, Hash, string, []>;
    // (undocumented)
    export function parseIdent(query?: string | Predicate<Ident>): Parser<Slice<Token>, Ident, string, []>;
    const // (undocumented)
    openParenthesis: typeof OpenParenthesis.of, // (undocumented)
    isOpenParenthesis: typeof OpenParenthesis.isOpenParenthesis;
    const // (undocumented)
    parseOpenParenthesis: Parser<Slice<Token>, OpenParenthesis, string, []>;
    // (undocumented)
    export function parseNumber(predicate?: Predicate<Number>): Parser<Slice<Token>, Number, string, []>;
    // (undocumented)
    export function parsePercentage(predicate?: Predicate<Percentage>): Parser<Slice<Token>, Percentage, string, []>;
    const // (undocumented)
    closeParenthesis: typeof CloseParenthesis.of, // (undocumented)
    isCloseParenthesis: typeof CloseParenthesis.isCloseParenthesis;
    const // (undocumented)
    parseCloseParenthesis: Parser<Slice<Token>, CloseParenthesis, string, []>;
    // (undocumented)
    export function parseString(predicate?: Predicate<String>): Parser<Slice<Token>, String, string, []>;
    // (undocumented)
    export function parseURL(predicate?: Predicate<URL>): Parser<Slice<Token>, URL, string, []>;
    const // (undocumented)
    openSquareBracket: typeof OpenSquareBracket.of, // (undocumented)
    isOpenSquareBracket: typeof OpenSquareBracket.isOpenSquareBracket;
    const // (undocumented)
    parseOpenSquareBracket: Parser<Slice<Token>, OpenSquareBracket, string, []>;
    // (undocumented)
    export class Percentage implements Equatable, Serializable<Percentage.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get isInteger(): boolean;
        // (undocumented)
        static of(value: number, isInteger: boolean): Percentage;
        // (undocumented)
        toJSON(): Percentage.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "percentage";
        // (undocumented)
        get value(): number;
    }
    // (undocumented)
    export namespace Percentage {
        // (undocumented)
        export function isPercentage(value: unknown): value is Percentage;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            isInteger: boolean;
            // (undocumented)
            type: "percentage";
            // (undocumented)
            value: number;
        }
    }
    const // (undocumented)
    closeSquareBracket: typeof CloseSquareBracket.of, // (undocumented)
    isCloseSquareBracket: typeof CloseSquareBracket.isCloseSquareBracket;
    const // (undocumented)
    parseCloseSquareBracket: Parser<Slice<Token>, CloseSquareBracket, string, []>;
    // (undocumented)
    export class Semicolon implements Equatable, Serializable<Semicolon.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): Semicolon;
        // (undocumented)
        toJSON(): Semicolon.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "semicolon";
    }
    // (undocumented)
    export namespace Semicolon {
        // (undocumented)
        export function isSemicolon(value: unknown): value is Semicolon;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "semicolon";
        }
    }
    const // (undocumented)
    openCurlyBracket: typeof OpenCurlyBracket.of, // (undocumented)
    isOpenCurlyBracket: typeof OpenCurlyBracket.isOpenCurlyBracket;
    const // (undocumented)
    parseOpenCurlyBracket: Parser<Slice<Token>, OpenCurlyBracket, string, []>;
    // (undocumented)
    export class String implements Equatable, Serializable<String.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): String;
        // (undocumented)
        toJSON(): String.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "string";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace String {
        // (undocumented)
        export function isString(value: unknown): value is String;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "string";
            // (undocumented)
            value: string;
        }
    }
    const // (undocumented)
    closeCurlyBracket: typeof CloseCurlyBracket.of, // (undocumented)
    isCloseCurlyBracket: typeof CloseCurlyBracket.isCloseCurlyBracket;
    const // (undocumented)
    parseCloseCurlyBracket: Parser<Slice<Token>, CloseCurlyBracket, string, []>;
    // (undocumented)
    export class URL implements Equatable, Serializable<URL.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): URL;
        // (undocumented)
        toJSON(): URL.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "url";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace URL {
        // (undocumented)
        export function isURL(value: unknown): value is URL;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "url";
            // (undocumented)
            value: string;
        }
    }
    const // (undocumented)
    openComment: typeof OpenComment.of, // (undocumented)
    isOpenComment: typeof OpenComment.isOpenComment;
    const // (undocumented)
    parseOpenComment: Parser<Slice<Token>, OpenComment, string, []>;
    // (undocumented)
    export class Whitespace implements Equatable, Serializable<Whitespace.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): Whitespace;
        // (undocumented)
        toJSON(): Whitespace.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "whitespace";
    }
    // (undocumented)
    export namespace Whitespace {
        // (undocumented)
        export function isWhitespace(value: unknown): value is Whitespace;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "whitespace";
        }
    }
    const // (undocumented)
    closeComment: typeof CloseComment.of, // (undocumented)
    isCloseComment: typeof CloseComment.isCloseComment;
    const // (undocumented)
    parseCloseComment: Parser<Slice<Token>, CloseComment, string, []>;
}

// @public (undocumented)
export type Transform = Matrix | Perspective | Rotate | Scale | Skew | Translate;

// @public (undocumented)
export namespace Transform {
    // (undocumented)
    export function matrix(...values: Matrix.Values<Number_2>): Matrix;
    // (undocumented)
    export function perspective<D extends Length>(depth: D): Perspective<D>;
    // (undocumented)
    export function rotate<A extends Angle>(x: Number_2, y: Number_2, z: Number_2, angle: A): Rotate<A>;
    // (undocumented)
    export function scale(x: Number_2, y: Number_2): Scale;
    // (undocumented)
    export function skew<X extends Angle, Y extends Angle>(x: X, y: Y): Skew<X, Y>;
    // (undocumented)
    export function translate<X extends Length | Percentage, Y extends Length | Percentage, Z extends Length>(x: X, y: Y, z: Z): Translate<X, Y, Z>;
    const // (undocumented)
    parse: Parser<Slice<Token>, Transform, string, []>;
    const // (undocumented)
    parseList: Parser<Slice<Token>, Array<Transform>, string>;
}

// @public (undocumented)
export class Translate<X extends Length | Percentage = Length | Percentage, Y extends Length | Percentage = Length | Percentage, Z extends Length = Length> extends Value<"transform"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "translate";
    // (undocumented)
    static of<X extends Length | Percentage, Y extends Length | Percentage, Z extends Length>(x: X, y: Y, z: Z): Translate<X, Y, Z>;
    // (undocumented)
    toJSON(): Translate.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "transform";
    // (undocumented)
    get x(): X;
    // (undocumented)
    get y(): Y;
    // (undocumented)
    get z(): Z;
}

// @public (undocumented)
export namespace Translate {
    // (undocumented)
    export function isTranslate<X extends Length | Percentage, Y extends Length | Percentage, Z extends Length>(value: unknown): value is Translate<X, Y, Z>;
    // (undocumented)
    export interface JSON extends Value.JSON<"transform"> {
        // (undocumented)
        kind: "translate";
        // (undocumented)
        x: Length.JSON | Percentage.JSON;
        // (undocumented)
        y: Length.JSON | Percentage.JSON;
        // (undocumented)
        z: Length.JSON;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, Translate, string>;
}

// @public (undocumented)
export type Unit = Unit.Length | Unit.Angle | Unit.Time | Unit.Frequency | Unit.Resolution;

// @public (undocumented)
export namespace Unit {
    // (undocumented)
    export type Angle = "deg" | "grad" | "rad" | "turn";
    const // (undocumented)
    isRelativeLength: typeof Length.isRelative, // (undocumented)
    isFontRelativeLength: typeof Length.isFontRelative, // (undocumented)
    isViewportRelativeLength: typeof Length.isViewportRelative, // (undocumented)
    isAbsoluteLength: typeof Length.isAbsolute;
    // (undocumented)
    export type Frequency = "hz" | "kHz";
    // (undocumented)
    export function isAngle(unit: string): unit is Angle;
    // (undocumented)
    export function isFrequency(unit: string): unit is Frequency;
    // (undocumented)
    export function isLength(unit: string): unit is Length;
    // (undocumented)
    export function isResolution(unit: string): unit is Resolution;
    // (undocumented)
    export function isTime(unit: string): unit is Time;
    // (undocumented)
    export namespace Length {
        // (undocumented)
        export type Absolute = "cm" | "mm" | "Q" | "in" | "pc" | "pt" | "px";
        // (undocumented)
        export function isAbsolute(unit: string): unit is Absolute;
        // (undocumented)
        export function isFontRelative(unit: string): unit is Relative.Font;
        // (undocumented)
        export function isRelative(unit: string): unit is Relative;
        // (undocumented)
        export function isViewportRelative(unit: string): unit is Relative.Viewport;
        // (undocumented)
        export type Relative = Relative.Font | Relative.Viewport;
        // (undocumented)
        export namespace Relative {
            // (undocumented)
            export type Font = "em" | "ex" | "ch" | "rem";
            // (undocumented)
            export type Viewport = "vw" | "vh" | "vmin" | "vmax";
        }
    }
    // (undocumented)
    export type Length = Length.Relative | Length.Absolute;
    // (undocumented)
    export type Resolution = "dpi" | "dpcm" | "dppx";
    // (undocumented)
    export type Time = "s" | "ms";
}

// @public (undocumented)
export class URL extends Value<"url"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(url: string): URL;
    // (undocumented)
    toJSON(): URL.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "url";
    // (undocumented)
    get url(): string;
}

// @public (undocumented)
export namespace URL {
    // (undocumented)
    export function isURL(value: unknown): value is URL;
    // (undocumented)
    export interface JSON extends Value.JSON<"url"> {
        // (undocumented)
        url: string;
    }
    const // (undocumented)
    parse: Parser<Slice<Token>, URL, string>;
}

// @public (undocumented)
export abstract class Value<T extends string = string> implements Equatable, Hashable, Serializable<Value.JSON<T>> {
    protected constructor();
    // (undocumented)
    abstract equals(value: unknown): value is this;
    // (undocumented)
    abstract hash(hash: Hash): void;
    // (undocumented)
    abstract toJSON(): Value.JSON<T>;
    // (undocumented)
    abstract toString(): string;
    // (undocumented)
    abstract get type(): T;
}

// @public (undocumented)
export namespace Value {
    // (undocumented)
    export function isValue<T extends string>(value: unknown, type?: T): value is Value<T>;
    // (undocumented)
    export interface JSON<T extends string = string> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: T;
    }
}

// (No @packageDocumentation comment for this package)

```
