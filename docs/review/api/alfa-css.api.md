## API Report File for "@siteimprove/alfa-css"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Array as Array_2 } from '@siteimprove/alfa-array';
import { Comparable } from '@siteimprove/alfa-comparable';
import { Comparison } from '@siteimprove/alfa-comparable';
import { Equatable } from '@siteimprove/alfa-equatable';
import { Hash } from '@siteimprove/alfa-hash';
import { Hashable } from '@siteimprove/alfa-hash';
import { Iterable as Iterable_2 } from '@siteimprove/alfa-iterable';
import * as json from '@siteimprove/alfa-json';
import { Mapper } from '@siteimprove/alfa-mapper';
import { Option } from '@siteimprove/alfa-option';
import { Parser as Parser_2 } from '@siteimprove/alfa-parser';
import { Predicate } from '@siteimprove/alfa-predicate';
import { Record as Record_2 } from '@siteimprove/alfa-record';
import { Result } from '@siteimprove/alfa-result';
import { Serializable } from '@siteimprove/alfa-json';
import { Slice } from '@siteimprove/alfa-slice';

// @public (undocumented)
export type Angle<U extends Unit.Angle = Unit.Angle> = Angle.Calculated | Angle.Fixed<U>;

// @public (undocumented)
export namespace Angle {
    export class Calculated extends Dimension.Calculated<"angle"> implements IAngle<true> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        static of(value: Math_2<"angle">): Calculated;
        // (undocumented)
        resolve(): Canonical;
    }
    // (undocumented)
    export namespace Calculated {
        // (undocumented)
        export interface JSON extends Dimension.Calculated.JSON<"angle"> {
        }
    }
    // (undocumented)
    export type Canonical = Fixed<"deg">;
    export class Fixed<U extends Unit.Angle = Unit.Angle> extends Dimension.Fixed<"angle", U> implements IAngle<false>, Comparable<Fixed<U>> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is never;
        // (undocumented)
        hasUnit<U extends Unit.Angle>(unit: U): this is Fixed<U>;
        // (undocumented)
        static of<U extends Unit.Angle>(value: number, unit: U): Fixed<U>;
        // (undocumented)
        static of<U extends Unit.Angle>(value: Angle_2<U>): Fixed<U>;
        // (undocumented)
        resolve(): Canonical;
        // (undocumented)
        scale(factor: number): Fixed<U>;
        // (undocumented)
        withUnit<U extends Unit.Angle>(unit: U): Fixed<U>;
    }
    // (undocumented)
    export namespace Fixed {
        // (undocumented)
        export interface JSON<U extends Unit.Angle = Unit.Angle> extends Dimension.Fixed.JSON<"angle", U> {
        }
    }
    // Warning: (ae-forgotten-export) The symbol "Resolvable" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export interface IAngle<CALC extends boolean = boolean> extends Value<"angle", CALC>, Resolvable<Canonical, never> {
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        resolve(): Canonical;
    }
    // (undocumented)
    export function isAngle(value: unknown): value is Angle;
    // (undocumented)
    export function isCalculated(value: unknown): value is Calculated;
    // (undocumented)
    export function isFixed(value: unknown): value is Fixed;
    // (undocumented)
    export type JSON = Calculated.JSON | Fixed.JSON;
    // (undocumented)
    export function of<U extends Unit.Angle>(value: number, unit: U): Fixed<U>;
    // (undocumented)
    export function of<U extends Unit.Angle>(value: Angle_2<U>): Fixed<U>;
    // (undocumented)
    export function of(value: Math_2<"angle">): Calculated;
    const // (undocumented)
    parse: Parser<Angle>;
    const // @internal (undocumented)
    parseBase: Parser_2<Slice<Token>, Fixed<Unit.Angle>, string, []>;
        {};
}

// @public (undocumented)
class Angle_2<U extends Unit.Angle = Unit.Angle> extends Dimension_2<"angle", U> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    hasUnit<U extends Unit.Angle>(unit: U): this is Angle_2<U>;
    // (undocumented)
    static of<U extends Unit.Angle>(value: number, unit: U): Angle_2<U>;
    // (undocumented)
    scale(factor: number): Angle_2<U>;
    // (undocumented)
    toJSON(): Angle_2.JSON<U>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    withUnit<U extends Unit.Angle>(unit: U): Angle_2<U>;
}

// @public (undocumented)
namespace Angle_2 {
    // (undocumented)
    function isAngle(value: unknown): value is Angle_2;
    // (undocumented)
    interface JSON<U extends Unit.Angle = Unit.Angle> extends Dimension_2.JSON<"angle", U> {
    }
    const // (undocumented)
    parse: Parser<Angle_2>;
}

// @public (undocumented)
export type AnglePercentage<U extends Unit.Angle = Unit.Angle> = AnglePercentage.Calculated | Angle.Calculated | Angle.Fixed<U> | Percentage.Calculated | Percentage.Fixed;

// @public (undocumented)
export namespace AnglePercentage {
    export class Calculated extends Dimension.Calculated<"angle-percentage"> implements IAnglePercentage<true> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        static of(value: Math_2<"angle-percentage">): Calculated;
        // (undocumented)
        resolve(resolver: Resolver): Canonical;
    }
    // (undocumented)
    export namespace Calculated {
        // (undocumented)
        export interface JSON extends Dimension.Calculated.JSON<"angle-percentage"> {
        }
    }
    // (undocumented)
    export type Canonical = Angle.Canonical;
    // (undocumented)
    export interface IAnglePercentage<CALC extends boolean = boolean> extends Value<"angle-percentage", CALC, "angle">, Resolvable<Canonical, Resolver> {
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        resolve(resolver: Resolver): Canonical;
    }
    // (undocumented)
    export function isAnglePercentage(value: unknown): value is AnglePercentage;
    // (undocumented)
    export function isCalculated(value: unknown): value is Calculated | Angle.Calculated | Percentage.Calculated;
    // (undocumented)
    export function isFixed(value: unknown): value is Angle.Fixed;
    // (undocumented)
    export function isPercentage(value: unknown): value is Percentage.Fixed;
    // (undocumented)
    export type JSON = Calculated.JSON | Angle.Calculated.JSON | Angle.Fixed.JSON | Percentage.Calculated.JSON | Percentage.Fixed.JSON;
    // (undocumented)
    export function of<U extends Unit.Angle>(value: number, unit: U): Angle.Fixed<U>;
    // Warning: (ae-forgotten-export) The symbol "Base" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export function of<U extends Unit.Angle>(value: Base.Angle<U>): Angle.Fixed<U>;
    // (undocumented)
    export function of(value: number): Percentage.Fixed;
    // (undocumented)
    export function of(value: Base.Percentage): Percentage.Fixed;
    // (undocumented)
    export function of(value: Math_2<"angle">): Angle.Calculated;
    // (undocumented)
    export function of(value: Math_2<"angle-percentage">): Calculated;
    // (undocumented)
    export function of(value: Math_2<"percentage">): Percentage.Calculated;
    // (undocumented)
    export type Resolver = Percentage.Resolver<"angle", Canonical>;
    const // (undocumented)
    parse: Parser_2<Slice<Token>, AnglePercentage<Unit.Angle>, string, []>;
        {};
}

// @public (undocumented)
export class Block implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(token: Block.Open, value: Iterable<Token>): Block;
    // (undocumented)
    toJSON(): Block.JSON;
    // (undocumented)
    get token(): Block.Open;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): Array<Token>;
}

// @public (undocumented)
export namespace Block {
    export type Close = Token.CloseParenthesis | Token.CloseSquareBracket | Token.CloseCurlyBracket;
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        token: Token.JSON;
        // (undocumented)
        value: Array<Token.JSON>;
    }
    export type Open = Token.OpenParenthesis | Token.OpenSquareBracket | Token.OpenCurlyBracket;
    const // (undocumented)
    consume: Parser<Block>;
}

// @public (undocumented)
export type Box = Keyword<"border-box"> | Keyword<"padding-box"> | Keyword<"content-box">;

// @public (undocumented)
export namespace Box {
    // (undocumented)
    export type Geometry = Shape | Keyword<"fill-box"> | Keyword<"stroke-box"> | Keyword<"view-box">;
    const // (undocumented)
    parse: Parser<Box>;
    // (undocumented)
    export namespace Geometry {
        // (undocumented)
        export type JSON = Shape.JSON | Keyword.JSON<"fill-box"> | Keyword.JSON<"stroke-box"> | Keyword.JSON<"view-box">;
    }
    // (undocumented)
    export type JSON = Keyword.JSON<"border-box"> | Keyword.JSON<"padding-box"> | Keyword.JSON<"content-box">;
    const // (undocumented)
    parseShape: Parser<Shape>;
    // (undocumented)
    export type Shape = Box | Keyword<"margin-box">;
    // (undocumented)
    export namespace Shape {
        // (undocumented)
        export type JSON = Box.JSON | Keyword.JSON<"margin-box">;
    }
    const // (undocumented)
    parseGeometry: Parser<Geometry>;
}

// Warning: (ae-forgotten-export) The symbol "BasicShape" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class Circle<R extends Radius = Radius, P extends Position.Fixed = Position.Fixed> extends BasicShape<"circle"> {
    // (undocumented)
    get center(): P;
    // (undocumented)
    equals(value: Circle): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<R extends Radius, P extends Position.Fixed>(radius: R, center: P): Circle<R, P>;
    // (undocumented)
    get radius(): R;
    // (undocumented)
    resolve(): Circle<R, P>;
    // (undocumented)
    toJSON(): Circle.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Circle {
    // (undocumented)
    export function isCircle(value: unknown): value is Circle;
    // (undocumented)
    export interface JSON extends BasicShape.JSON<"circle"> {
        // (undocumented)
        center: Position.JSON;
        // (undocumented)
        radius: Radius.JSON;
    }
    const // (undocumented)
    parse: Parser<Circle>;
}

// @public (undocumented)
export type Color = Hex | Named | HSL | RGB | Current | System;

// @public (undocumented)
export namespace Color {
    // (undocumented)
    export type Canonical = Current | System | RGB.Canonical;
    // (undocumented)
    export function hex(value: number): Hex;
    const // (undocumented)
    current: Current;
    // (undocumented)
    export function hsl<H extends Number_2.Canonical | Angle.Canonical, A extends Number_2.Canonical | Percentage.Canonical>(hue: H, saturation: Percentage, lightness: Percentage, alpha: A): HSL<H, A>;
    // (undocumented)
    export function isTransparent(color: Color): boolean;
    // (undocumented)
    export type JSON = Hex.JSON | Named.JSON | HSL.JSON | RGB.JSON | Keyword.JSON;
    // (undocumented)
    export function named<C extends Named.Color>(color: C): Named<C>;
    // (undocumented)
    export function rgb<C extends Number_2.Canonical | Percentage.Canonical, A extends Number_2.Canonical | Percentage.Canonical>(red: C, green: C, blue: C, alpha: A): RGB<C, A>;
    const // (undocumented)
    parse: Parser_2<Slice<Token>, Color, string, []>;
    // (undocumented)
    export function system(keyword: System.Keyword): System;
}

// @public (undocumented)
export class Component implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(value: Iterable<Token>): Component;
    // (undocumented)
    toJSON(): Component.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): Array<Token>;
}

// @public (undocumented)
export namespace Component {
    // (undocumented)
    export type JSON = Array<Token.JSON>;
    const // (undocumented)
    consume: Parser<Component>;
    const // (undocumented)
    parse: Parser_2<Slice<Token>, Component, string, []>;
}

// @public
export type Converter<U extends string> = (value: number, from: U, to: U) => number;

// @public (undocumented)
export namespace Converter {
    const // (undocumented)
    length: Converter<Unit.Length.Absolute>;
    const // (undocumented)
    angle: Converter<Unit.Angle>;
    const // (undocumented)
    time: Converter<Unit.Time>;
    const // (undocumented)
    frequency: Converter<Unit.Frequency>;
}

// @public
export interface Convertible<U extends string> {
    // (undocumented)
    withUnit<V extends U>(unit: V): Convertible<V>;
}

// @public (undocumented)
export type Current = Keyword<"currentcolor">;

// @public (undocumented)
export namespace Current {
    const // (undocumented)
    parse: Parser<Current>;
}

// @public (undocumented)
export class Declaration implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get important(): boolean;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(name: string, value: Iterable<Token>, important?: boolean): Declaration;
    // (undocumented)
    toJSON(): Declaration.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): Array<Token>;
}

// @public (undocumented)
export namespace Declaration {
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        important: boolean;
        // (undocumented)
        name: string;
        // (undocumented)
        value: Array<Token.JSON>;
    }
    const // (undocumented)
    consume: Parser<Declaration>;
    const // (undocumented)
    parse: Parser<Declaration>;
    const // (undocumented)
    consumeList: Parser<Iterable<Declaration>>;
    const // (undocumented)
    parseList: Parser<Iterable<Declaration>>;
}

// Warning: (ae-forgotten-export) The symbol "Type" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "Dimensions" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Dimension<T extends Type = Type> = Dimension.Calculated<T> | Dimension.Fixed<Dimensions<T>[0]>;

// @public (undocumented)
export namespace Dimension {
    export abstract class Calculated<T extends Type = Type> extends Numeric.Calculated<T, Dimensions<T>[0]> implements IDimension<T, true> {
        protected constructor(math: Numeric.ToMath<T>, type: T);
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is Calculated<T>;
        // (undocumented)
        abstract resolve(resolver?: unknown): Fixed<Dimensions<T>[0], Dimensions<T>[2]>;
    }
    // (undocumented)
    export namespace Calculated {
        // (undocumented)
        export interface JSON<T extends Type = Type> extends Numeric.Calculated.JSON<T> {
        }
    }
    export abstract class Fixed<T extends Numeric_2.Dimension = Numeric_2.Dimension, U extends Dimensions<T>[1] = Dimensions<T>[1]> extends Numeric.Fixed<T> implements IDimension<T, false>, Convertible<Dimensions<T>[1]>, Comparable<Fixed<T>> {
        protected constructor(value: number, unit: U, type: T);
        // (undocumented)
        get canonicalUnit(): Dimensions<T>[2];
        // (undocumented)
        compare(value: Fixed<T>): Comparison;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is never;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        abstract hasUnit<V extends Dimensions<T>[1]>(unit: V): this is Fixed<T, V>;
        // (undocumented)
        abstract resolve(resolver?: unknown): Fixed<T, Dimensions<T>[2]>;
        // (undocumented)
        toJSON(): Fixed.JSON<T, U>;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get unit(): U;
        // (undocumented)
        protected readonly _unit: U;
        // (undocumented)
        abstract withUnit<V extends Dimensions<T>[1]>(unit: V): Fixed<T, V>;
    }
    // (undocumented)
    export namespace Fixed {
        // (undocumented)
        export interface JSON<T extends Type = Type, U extends Dimensions<T>[1] = Dimensions<T>[1]> extends Numeric.Fixed.JSON<T> {
            // (undocumented)
            unit: U;
        }
    }
    // (undocumented)
    export interface IDimension<T extends Type = Type, CALC extends boolean = boolean> extends Value<T, CALC, Dimensions<T>[0]>, Resolvable<Fixed<Dimensions<T>[0], Dimensions<T>[2]>, unknown> {
        // (undocumented)
        hasCalculation(): this is Calculated<T>;
        // (undocumented)
        resolve(resolver?: unknown): Fixed<Dimensions<T>[0], Dimensions<T>[2]>;
    }
    // (undocumented)
    export function isCalculated(value: unknown): value is Calculated;
    // (undocumented)
    export function isDimension(value: unknown): value is Numeric;
    // (undocumented)
    export function isFixed(value: unknown): value is Fixed;
        {};
}

// Warning: (ae-forgotten-export) The symbol "ToDimension" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
abstract class Dimension_2<T extends Numeric_2.Dimension = Numeric_2.Dimension, U extends ToDimension<T> = ToDimension<T>> extends Numeric_2<T> {
    protected constructor(value: number, unit: U, type: T);
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hasUnit<V extends ToDimension<T>>(unit: V): this is Dimension_2<T, V>;
    // (undocumented)
    toJSON(): Dimension_2.JSON<T, U>;
    // (undocumented)
    get unit(): U;
    // (undocumented)
    protected readonly _unit: U;
    // (undocumented)
    abstract withUnit<V extends ToDimension<T>>(unit: V): Dimension_2<T, V>;
}

// @public (undocumented)
namespace Dimension_2 {
    // (undocumented)
    function isDimension(value: unknown): value is Dimension_2;
    // (undocumented)
    interface JSON<T extends Numeric_2.Dimension = Numeric_2.Dimension, U extends ToDimension<T> = ToDimension<T>> extends Numeric_2.JSON<T> {
        // (undocumented)
        unit: U;
    }
}

// @public (undocumented)
export class Ellipse<R extends Radius = Radius, P extends Position.Fixed = Position.Fixed> extends BasicShape<"ellipse"> {
    // (undocumented)
    get center(): P;
    // (undocumented)
    equals(value: Ellipse): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<R extends Radius = Radius, P extends Position.Fixed = Position.Fixed>(rx: R, ry: R, center: P): Ellipse<R, P>;
    // (undocumented)
    resolve(): Ellipse<R, P>;
    // (undocumented)
    get rx(): R;
    // (undocumented)
    get ry(): R;
    // (undocumented)
    toJSON(): Ellipse.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Ellipse {
    // (undocumented)
    export function isEllipse(value: unknown): value is Ellipse;
    // (undocumented)
    export interface JSON extends BasicShape.JSON<"ellipse"> {
        // (undocumented)
        center: Position.JSON;
        // (undocumented)
        rx: Radius.JSON;
        // (undocumented)
        ry: Radius.JSON;
    }
    const // (undocumented)
    parse: Parser<Ellipse>;
}

// @public (undocumented)
class Function_2 implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get name(): string;
    // (undocumented)
    static of(name: string, value: Iterable<Token>): Function_2;
    // (undocumented)
    toJSON(): Function_2.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): Array<Token>;
}

// @public (undocumented)
namespace Function_2 {
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        name: string;
        // (undocumented)
        value: Array<Token.JSON>;
    }
    const // (undocumented)
    consume: Parser<Function_2>;
    const // (undocumented)
    parse: <T>(query?: string | Predicate<Token.Function>, body?: Parser<T> | undefined) => Parser_2<Slice<Token>, readonly [Function_2, T], string, []>;
}
export { Function_2 as Function }

// @public (undocumented)
export type Gradient = Linear | Radial;

// @public (undocumented)
export namespace Gradient {
    // (undocumented)
    export type Canonical = Linear.Canonical | Radial.Canonical;
    // (undocumented)
    export class Hint<P extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed> implements Equatable, Hashable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of<P extends Length.Fixed | Percentage.Fixed>(position: P): Hint<P>;
        // (undocumented)
        get position(): P;
        // (undocumented)
        toJSON(): Hint.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "hint";
    }
    // (undocumented)
    export namespace Hint {
        // (undocumented)
        export type Canonical = Hint<Percentage.Canonical | Length.Canonical>;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            position: Length.Fixed.JSON | Percentage.Fixed.JSON;
            // (undocumented)
            type: "hint";
        }
    }
    // (undocumented)
    export type Item = Stop | Hint;
    const // (undocumented)
    parseStop: Parser<Stop>;
    // (undocumented)
    export namespace Item {
        // (undocumented)
        export type JSON = Stop.JSON | Hint.JSON;
    }
    // (undocumented)
    export type JSON = Linear.JSON | Radial.JSON;
    const // (undocumented)
    parseHint: Parser<Hint>;
    // (undocumented)
    export class Stop<C extends Color = Color, P extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed> implements Equatable, Hashable, Serializable {
        // (undocumented)
        get color(): C;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of<C extends Color, P extends Length.Fixed | Percentage.Fixed>(color: C, position?: Option<P>): Stop<C, P>;
        // (undocumented)
        get position(): Option<P>;
        // (undocumented)
        toJSON(): Stop.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "stop";
    }
    // (undocumented)
    export namespace Stop {
        // (undocumented)
        export type Canonical = Stop<Color.Canonical, Percentage.Canonical | Length.Canonical>;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            color: Color.JSON;
            // (undocumented)
            position: Length.Fixed.JSON | Percentage.Fixed.JSON | null;
            // (undocumented)
            type: "stop";
        }
    }
    const // (undocumented)
    parseItemList: Parser<Array<Item>>;
    const // (undocumented)
    parse: Parser<Gradient>;
}

// Warning: (ae-forgotten-export) The symbol "Format" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class Hex extends Format<"hex"> {
    // (undocumented)
    get alpha(): Number_2.Fixed;
    // (undocumented)
    get blue(): Number_2.Fixed;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get green(): Number_2.Fixed;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(value: number): Hex;
    // (undocumented)
    get red(): Number_2.Fixed;
    // (undocumented)
    resolve(): RGB.Canonical;
    // (undocumented)
    toJSON(): Hex.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): number;
}

// @public (undocumented)
export namespace Hex {
    // (undocumented)
    export function isHex(value: unknown): value is Hex;
    // (undocumented)
    export interface JSON extends Format.JSON<"hex"> {
        // (undocumented)
        value: number;
    }
    const // (undocumented)
    parse: Parser<Hex>;
}

// @public (undocumented)
export class HSL<H extends Number_2.Fixed | Angle.Fixed = Number_2.Fixed | Angle.Fixed, A extends Number_2.Fixed | Percentage.Fixed = Number_2.Fixed | Percentage.Fixed> extends Format<"hsl"> {
    // (undocumented)
    get alpha(): A;
    // (undocumented)
    get blue(): Percentage.Fixed;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get green(): Percentage.Fixed;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get hue(): H;
    // (undocumented)
    get lightness(): Percentage.Fixed;
    // (undocumented)
    static of<H extends Number_2.Canonical | Angle.Canonical, A extends Number_2.Canonical | Percentage.Canonical, S extends Percentage, L extends Percentage>(hue: H, saturation: S, lightness: L, alpha: A): HSL<H, A>;
    // Warning: (ae-forgotten-export) The symbol "ToCanonical" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static of<H extends Number_2 | Angle, A extends Number_2 | Percentage, S extends Percentage, L extends Percentage>(hue: H, saturation: S, lightness: L, alpha: A): HSL<ToCanonical_2<H>, ToCanonical_2<A>>;
    // (undocumented)
    get red(): Percentage.Fixed;
    // (undocumented)
    resolve(): RGB.Canonical;
    // (undocumented)
    get saturation(): Percentage.Fixed;
    // (undocumented)
    toJSON(): HSL.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace HSL {
    // (undocumented)
    export function isHSL<H extends Number_2.Fixed | Angle.Fixed, A extends Number_2.Fixed | Percentage.Fixed>(value: unknown): value is HSL<H, A>;
    // (undocumented)
    export interface JSON extends Format.JSON<"hsl"> {
        // (undocumented)
        alpha: Number_2.Fixed.JSON | Percentage.Fixed.JSON;
        // (undocumented)
        hue: Number_2.Fixed.JSON | Angle.Fixed.JSON;
        // (undocumented)
        lightness: Percentage.Fixed.JSON;
        // (undocumented)
        saturation: Percentage.Fixed.JSON;
    }
    const // (undocumented)
    parse: Parser<HSL>;
}

// @public (undocumented)
export class Image<I extends URL | Gradient = URL | Gradient> extends Value<"image", false> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get image(): I;
    // (undocumented)
    static of<I extends URL | Gradient>(image: I): Image<I>;
    // (undocumented)
    resolve(): Image<I>;
    // (undocumented)
    toJSON(): Image.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Image {
    // (undocumented)
    export type Canonical = Image<URL | Gradient.Canonical>;
    // (undocumented)
    export function isImage<I extends URL | Gradient>(value: unknown): value is Image<I>;
    // (undocumented)
    export interface JSON extends Value.JSON<"image"> {
        // (undocumented)
        image: URL.JSON | Gradient.JSON;
    }
    const // (undocumented)
    parse: Parser<Image>;
}

// @public (undocumented)
export class Inset<O extends Inset.Offset = Inset.Offset, C extends Inset.Corner = Inset.Corner> extends BasicShape<"inset"> {
    // (undocumented)
    get bottom(): O;
    // (undocumented)
    get bottomLeft(): Option<C>;
    // (undocumented)
    get bottomRight(): Option<C>;
    // (undocumented)
    get corners(): Option<readonly [C, C, C, C]>;
    // (undocumented)
    equals(value: Inset): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get left(): O;
    // (undocumented)
    static of<O extends Inset.Offset = Inset.Offset, C extends Inset.Corner = Inset.Corner>(offsets: readonly [O, O, O, O], corners: Option<readonly [C, C, C, C]>): Inset<O, C>;
    // (undocumented)
    get offsets(): readonly [O, O, O, O];
    // (undocumented)
    resolve(): Inset<O, C>;
    // (undocumented)
    get right(): O;
    // (undocumented)
    toJSON(): Inset.JSON<O, C>;
    // (undocumented)
    get top(): O;
    // (undocumented)
    get topLeft(): Option<C>;
    // (undocumented)
    get topRight(): Option<C>;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Inset {
    // (undocumented)
    export type Corner = Radius | readonly [Radius, Radius];
    // (undocumented)
    export interface JSON<O extends Offset = Offset, C extends Corner = Corner> extends BasicShape.JSON<"inset"> {
        // (undocumented)
        corners: Option.JSON<readonly [C, C, C, C]>;
        // (undocumented)
        offsets: Serializable.ToJSON<readonly [O, O, O, O]>;
    }
    // (undocumented)
    export type Offset = Length.Fixed | Percentage.Fixed;
    // (undocumented)
    export type Radius = Length.Fixed | Percentage.Fixed;
    const // (undocumented)
    parse: Parser<Inset>;
}

// @public (undocumented)
export type Integer = Integer.Calculated | Integer.Fixed;

// @public (undocumented)
export namespace Integer {
    export class Calculated extends Numeric.Calculated<"number"> implements IInteger<true> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: Math_2<"number">): Calculated;
        // (undocumented)
        resolve(): Canonical;
        // (undocumented)
        toJSON(): Calculated.JSON;
    }
    // (undocumented)
    export namespace Calculated {
        // (undocumented)
        export interface JSON extends Numeric.Calculated.JSON<"number"> {
        }
    }
    // (undocumented)
    export type Canonical = Fixed;
    export class Fixed extends Numeric.Fixed<"number"> implements IInteger<false> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of(value: number | Integer_2): Fixed;
        // (undocumented)
        resolve(): this;
        // (undocumented)
        scale(factor: number): Fixed;
        // (undocumented)
        toJSON(): Fixed.JSON;
    }
    // (undocumented)
    export namespace Fixed {
        // (undocumented)
        export interface JSON extends Numeric.Fixed.JSON<"number"> {
        }
    }
    // (undocumented)
    export interface IInteger<CALC extends boolean = boolean> extends Value<"number", CALC>, Resolvable<Canonical, never> {
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        resolve(): Canonical;
    }
    // (undocumented)
    export function isCalculated(value: unknown): value is Calculated;
    // (undocumented)
    export function isFixed(value: unknown): value is Fixed;
    // (undocumented)
    export function isInteger(value: unknown): value is Integer;
    // (undocumented)
    export function of(value: number): Fixed;
    // (undocumented)
    export function of(value: Integer_2): Fixed;
    // (undocumented)
    export function of(value: Math_2<"number">): Calculated;
    const // (undocumented)
    parse: Parser<Integer>;
    const // @internal (undocumented)
    parseBase: Parser_2<Slice<Token>, Fixed, string, []>;
        {};
}

// @public (undocumented)
class Integer_2 extends Numeric_2<"integer"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(value: number): Integer_2;
    // (undocumented)
    scale(factor: number): Integer_2;
    // (undocumented)
    toJSON(): Integer_2.JSON;
}

// @public (undocumented)
namespace Integer_2 {
    // (undocumented)
    function isInteger(value: unknown): value is Integer_2;
    // (undocumented)
    interface JSON extends Numeric_2.JSON<"integer"> {
    }
    const // (undocumented)
    parse: Parser<Integer_2>;
}

// @public (undocumented)
export class Keyword<T extends string = string> extends Value<"keyword", false> implements Resolvable<Keyword<T>, never> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<T extends string>(value: T): Keyword<T>;
    // (undocumented)
    resolve(): Keyword<T>;
    // (undocumented)
    toJSON(): Keyword.JSON<T>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): T;
}

// @public (undocumented)
export namespace Keyword {
    // (undocumented)
    export function isKeyword(value: unknown): value is Keyword;
    // (undocumented)
    export interface JSON<T extends string = string> extends Value.JSON<"keyword"> {
        // (undocumented)
        value: T;
    }
    // (undocumented)
    export function parse<T extends string>(...keywords: Array<T>): Parser<ToKeywords<T>>;
    export type ToKeywords<Words extends string> = {
        [K in Words]: Keyword<K>;
    }[Words];
}

// @public (undocumented)
export type Length<U extends Unit.Length = Unit.Length> = Length.Calculated | Length.Fixed<U>;

// @public (undocumented)
export namespace Length {
    export class Calculated extends Dimension.Calculated<"length"> implements ILength<true> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        static of(value: Math_2<"length">): Calculated;
        // (undocumented)
        resolve(resolver: Resolver): Canonical;
    }
    // (undocumented)
    export namespace Calculated {
        // (undocumented)
        export interface JSON extends Dimension.Calculated.JSON<"length"> {
        }
    }
    // (undocumented)
    export type Canonical = Fixed<"px">;
    export class Fixed<U extends Unit.Length = Unit.Length> extends Dimension.Fixed<"length", U> implements ILength<false>, Comparable<Fixed<U>> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is never;
        // (undocumented)
        hasUnit<U extends Unit.Length>(unit: U): this is Fixed<U>;
        // (undocumented)
        isAbsolute(): this is Fixed<Unit.Length.Absolute>;
        // (undocumented)
        isFontRelative(): this is Fixed<Unit.Length.Relative.Font>;
        // (undocumented)
        isRelative(): this is Fixed<Unit.Length.Relative>;
        // (undocumented)
        isViewportRelative(): this is Fixed<Unit.Length.Relative.Viewport>;
        // (undocumented)
        static of<U extends Unit.Length>(value: number, unit: U): Fixed<U>;
        // (undocumented)
        static of<U extends Unit.Length>(value: Length_2<U>): Fixed<U>;
        resolve(resolver: Resolver): Canonical;
        // (undocumented)
        scale(factor: number): Fixed<U>;
        // (undocumented)
        withUnit<U extends Unit.Length>(unit: U): Fixed<U>;
    }
    // (undocumented)
    export namespace Fixed {
        // (undocumented)
        export interface JSON<U extends Unit.Length = Unit.Length> extends Dimension.Fixed.JSON<"length", U> {
        }
    }
    // (undocumented)
    export interface ILength<CALC extends boolean = boolean> extends Value<"length", CALC>, Resolvable<Canonical, Resolver> {
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        resolve(resolver: Resolver): Canonical;
    }
    // (undocumented)
    export function isCalculated(value: unknown): value is Calculated;
    // (undocumented)
    export function isFixed(value: unknown): value is Fixed;
    // (undocumented)
    export function isLength(value: unknown): value is Length;
    // (undocumented)
    export type JSON = Calculated.JSON | Fixed.JSON;
    // (undocumented)
    export function of<U extends Unit.Length>(value: number, unit: U): Fixed<U>;
    // (undocumented)
    export function of<U extends Unit.Length>(value: Length_2<U>): Fixed<U>;
    // (undocumented)
    export function of(value: Math_2<"length">): Calculated;
    // (undocumented)
    export interface Resolver {
        // (undocumented)
        length: Mapper<Fixed<Unit.Length.Relative>, Canonical>;
    }
    export function resolver(emBase: Canonical, remBase: Canonical, vwBase: Canonical, vhBase: Canonical): Mapper<Fixed<Unit.Length.Relative>, Canonical>;
    const // (undocumented)
    parse: Parser<Length>;
    const // @internal (undocumented)
    parseBase: Parser_2<Slice<Token>, Fixed<Unit.Length>, string, []>;
        {};
}

// @public (undocumented)
class Length_2<U extends Unit.Length = Unit.Length> extends Dimension_2<"length", U> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    hasUnit<U extends Unit.Length>(unit: U): this is Length_2<U>;
    // (undocumented)
    isRelative(): this is Length_2<Unit.Length.Relative>;
    // (undocumented)
    static of<U extends Unit.Length>(value: number, unit: U): Length_2<U>;
    // (undocumented)
    scale(factor: number): Length_2<U>;
    // (undocumented)
    toJSON(): Length_2.JSON<U>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    withUnit<U extends Unit.Length>(unit: U): Length_2<U>;
}

// @public (undocumented)
namespace Length_2 {
    // (undocumented)
    function isLength(value: unknown): value is Length_2;
    // (undocumented)
    interface JSON<U extends Unit.Length = Unit.Length> extends Dimension_2.JSON<"length", U> {
    }
    const // (undocumented)
    parse: Parser<Length_2>;
}

// @public (undocumented)
export type LengthPercentage<U extends Unit.Length = Unit.Length, CALC extends boolean = boolean> = CALC extends true ? LengthPercentage.Calculated | Length.Calculated | Percentage.Calculated : CALC extends false ? Length.Fixed<U> | Percentage.Fixed : LengthPercentage.Calculated | Length.Calculated | Percentage.Calculated | Length.Fixed<U> | Percentage.Fixed;

// @public (undocumented)
export namespace LengthPercentage {
    export class Calculated extends Dimension.Calculated<"length-percentage"> implements ILengthPercentage<true> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        static of(value: Math_2<"length-percentage">): Calculated;
        // (undocumented)
        resolve(resolver: Resolver): Canonical;
    }
    // (undocumented)
    export namespace Calculated {
        // (undocumented)
        export interface JSON extends Dimension.Calculated.JSON<"length-percentage"> {
        }
    }
    // (undocumented)
    export type Canonical = Length.Canonical;
    // (undocumented)
    export interface ILengthPercentage<CALC extends boolean = boolean> extends Value<"length-percentage", CALC, "length">, Resolvable<Length.Canonical, Resolver> {
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        resolve(resolver: Resolver): Canonical;
    }
    // (undocumented)
    export function isCalculated(value: unknown): value is Calculated | Length.Calculated | Percentage.Calculated;
    // (undocumented)
    export function isFixed(value: unknown): value is Length.Fixed;
    // (undocumented)
    export function isLengthPercentage(value: unknown): value is LengthPercentage;
    // (undocumented)
    export function isPercentage(value: unknown): value is Percentage.Fixed;
    // (undocumented)
    export type JSON = Calculated.JSON | Length.Calculated.JSON | Length.Fixed.JSON | Percentage.Calculated.JSON | Percentage.Fixed.JSON;
    // (undocumented)
    export function of<U extends Unit.Length>(value: number, unit: U): Length.Fixed<U>;
    // (undocumented)
    export function of<U extends Unit.Length>(value: Base.Length<U>): Length.Fixed<U>;
    // (undocumented)
    export function of(value: number): Percentage.Fixed;
    // (undocumented)
    export function of(value: Base.Percentage): Percentage.Fixed;
    // (undocumented)
    export function of(value: Math_2<"length">): Length.Calculated;
    // (undocumented)
    export function of(value: Math_2<"length-percentage">): Calculated;
    // (undocumented)
    export function of(value: Math_2<"percentage">): Percentage.Calculated;
    export function partiallyResolve(resolver: PartialResolver): (value: LengthPercentage) => PartiallyResolved;
    export type PartiallyResolved = Canonical | Percentage.Canonical | LengthPercentage.Calculated;
    // (undocumented)
    export type PartialResolver = Length.Resolver;
    export function resolve(resolver: Resolver): (value: LengthPercentage) => Canonical;
    // (undocumented)
    export type Resolver = Length.Resolver & Percentage.Resolver<"length", Canonical>;
    const // (undocumented)
    parse: Parser_2<Slice<Token>, Length.Calculated | Length.Fixed<Unit.Length> | Calculated | Percentage.Calculated<Base.Numeric.Type> | Percentage.Fixed<Base.Numeric.Type>, string, []>;
    const // @internal (undocumented)
    parseBase: Parser<LengthPercentage<Unit.Length, false>>;
        {};
}

// @public (undocumented)
export namespace Lexer {
    // (undocumented)
    export function lex(input: string): Slice<Token>;
}

// @public (undocumented)
export class Linear<I extends Gradient.Item = Gradient.Item, D extends Linear.Direction = Linear.Direction> extends Value<"gradient", false> {
    // (undocumented)
    get direction(): D;
    // (undocumented)
    equals(value: Linear): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get items(): Iterable<I>;
    // (undocumented)
    get kind(): "linear";
    // (undocumented)
    static of<I extends Gradient.Item, D extends Linear.Direction>(direction: D, items: Iterable<I>, repeats: boolean): Linear<I, D>;
    // (undocumented)
    get repeats(): boolean;
    // (undocumented)
    resolve(): Linear<I, D>;
    // (undocumented)
    toJSON(): Linear.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Linear {
    // (undocumented)
    export type Canonical = Linear<Gradient.Hint.Canonical | Gradient.Stop.Canonical, Angle.Canonical | Linear.Side | Linear.Corner>;
    // (undocumented)
    export class Corner implements Equatable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        get horizontal(): Position.Horizontal;
        // (undocumented)
        static of(vertical: Position.Vertical, horizontal: Position.Horizontal): Corner;
        // (undocumented)
        toJSON(): Corner.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "corner";
        // (undocumented)
        get vertical(): Position.Vertical;
    }
    // (undocumented)
    export namespace Corner {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            horizontal: Position.Horizontal;
            // (undocumented)
            type: "corner";
            // (undocumented)
            vertical: Position.Vertical;
        }
    }
    // (undocumented)
    export type Direction = Angle.Fixed | Side | Corner;
    // (undocumented)
    export namespace Direction {
        // (undocumented)
        export type JSON = Angle.Fixed.JSON | Side.JSON | Corner.JSON;
    }
    // (undocumented)
    export interface JSON extends Value.JSON<"gradient"> {
        // (undocumented)
        direction: Direction.JSON;
        // (undocumented)
        items: Array<Gradient.Item.JSON>;
        // (undocumented)
        kind: "linear";
        // (undocumented)
        repeats: boolean;
    }
    // (undocumented)
    export function parse(parseItemList: Parser<Array<Gradient.Item>>): Parser<Linear>;
    // (undocumented)
    export type Position = Position.Vertical | Position.Horizontal;
    // (undocumented)
    export namespace Position {
        // (undocumented)
        export type Horizontal = "left" | "right";
        // (undocumented)
        export type Vertical = "top" | "bottom";
        const // (undocumented)
        parseVertical: Parser_2<Slice<Token>, Vertical, string, []>;
        const // (undocumented)
        parseHorizontal: Parser_2<Slice<Token>, Horizontal, string, []>;
        const // (undocumented)
        parse: Parser_2<Slice<Token>, Vertical | Horizontal, string, []>;
    }
    // (undocumented)
    export class Side implements Equatable, Hashable, Serializable {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of(side: Position.Vertical | Position.Horizontal): Side;
        // (undocumented)
        get side(): Position.Vertical | Position.Horizontal;
        // (undocumented)
        toJSON(): Side.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "side";
    }
    // (undocumented)
    export namespace Side {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            side: Position.Vertical | Position.Horizontal;
            // (undocumented)
            type: "side";
        }
    }
}

// @public (undocumented)
export class List<V extends Value, CALC extends boolean = boolean> extends Value<"list", CALC> implements Iterable_2<V>, Resolvable<List<Resolvable.Resolved<V>, false>, Resolvable.Resolver<V>> {
    // (undocumented)
    [Symbol.iterator](): Iterator<V>;
    // (undocumented)
    equals<T extends Value>(value: List<T>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    map<U extends Value>(mapper: Mapper<V, U>): List<U, U extends Value<string, false> ? false : true>;
    // (undocumented)
    static of<V extends Value>(values: Iterable_2<V>, separator?: string): List<V, Value.HasCalculation<V>>;
    // (undocumented)
    resolve(resolver?: Resolvable.Resolver<V>): List<Resolvable.Resolved<V>, false>;
    // (undocumented)
    toJSON(): List.JSON<V>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get values(): ReadonlyArray<V>;
}

// @public (undocumented)
export namespace List {
    // (undocumented)
    export function isList<V extends Value>(value: Iterable_2<V>): value is List<V>;
    // (undocumented)
    export function isList<V extends Value>(value: unknown): value is List<V>;
    // (undocumented)
    export interface JSON<V extends Value> extends Value.JSON<"list"> {
        // (undocumented)
        separator: string;
        // (undocumented)
        values: Array<Serializable.ToJSON<V>>;
    }
    const // (undocumented)
    parseCommaSeparated: <V extends Value<string, boolean, string>>(parseValue: Parser<V>) => Parser<List<V, boolean>>;
}

// @public (undocumented)
class Math_2<out D extends Math_2.Dimension = Math_2.Dimension> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get expression(): Expression;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    isDimension<D extends Numeric_2.Dimension>(dimension: D): this is Math_2<D>;
    // (undocumented)
    isDimensionPercentage<D extends Numeric_2.Dimension>(dimension: D): this is Math_2<`${D}-percentage`>;
    // (undocumented)
    isNumber(): this is Math_2<"number">;
    // (undocumented)
    isPercentage(): this is Math_2<"percentage">;
    // Warning: (ae-forgotten-export) The symbol "Expression" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static of(expression: Expression): Math_2;
    // (undocumented)
    reduce(resolver: Expression.Resolver): Math_2;
    resolve(this: Math_2<"angle">): Result<Angle_2<"deg">, string>;
    // (undocumented)
    resolve(this: Math_2<"angle-percentage">, resolver: Expression.PercentageResolver<Angle_2<"deg">>): Result<Angle_2<"deg">, string>;
    // (undocumented)
    resolve(this: Math_2<"length">, resolver: Expression.LengthResolver): Result<Length_2<"px">, string>;
    // (undocumented)
    resolve(this: Math_2<"length-percentage">, resolver: Expression.Resolver<"px", Length_2<"px">>): Result<Length_2<"px">, string>;
    // (undocumented)
    resolve(this: Math_2<"number">): Result<Number_3, string>;
    // (undocumented)
    resolve<T extends Numeric_2 = Percentage_2>(this: Math_2<"percentage">, resolver?: Expression.PercentageResolver<T>, hint?: T extends Angle_2 ? "angle" : "length"): Result<T, string>;
    // (undocumented)
    toJSON(): Math_2.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): "math expression";
}

// @public (undocumented)
namespace Math_2 {
    // Warning: (ae-forgotten-export) The symbol "Kind" needs to be exported by the entry point index.d.ts
    //
    // @internal (undocumented)
    type Dimension = Kind.Base | `${Numeric_2.Dimension}-percentage` | "number";
    // (undocumented)
    function isCalculation(value: unknown): value is Math_2;
    // (undocumented)
    function isNumber(value: unknown): value is Math_2<"number">;
    // (undocumented)
    function isPercentage(value: unknown): value is Math_2<"percentage">;
    // (undocumented)
    interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        expression: Expression.JSON;
        // (undocumented)
        type: "math expression";
    }
    const // Warning: (ae-incompatible-release-tags) The symbol "parse" is marked as @public, but its signature references "Dimension" which is marked as @internal
    //
    // (undocumented)
    parse: Parser_2<Slice<Token>, Math_2<Dimension>, string, []>;
    const // (undocumented)
    parseAngle: Parser_2<Slice<Token>, Math_2<"angle">, string, []>;
    const // (undocumented)
    parseAnglePercentage: Parser_2<Slice<Token>, Math_2<"angle-percentage">, string, []>;
    const // (undocumented)
    parseLength: Parser_2<Slice<Token>, Math_2<"length">, string, []>;
    const // (undocumented)
    parseLengthPercentage: Parser_2<Slice<Token>, Math_2<"length-percentage">, string, []>;
    const // (undocumented)
    parseNumber: Parser_2<Slice<Token>, Math_2<"number">, string, []>;
    const // (undocumented)
    parsePercentage: Parser_2<Slice<Token>, Math_2<"percentage">, string, []>;
}
export { Math_2 as Math }

// Warning: (ae-forgotten-export) The symbol "Function" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class Matrix extends Function_3<"matrix"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(...values: Matrix.Values<Number_2.Fixed>): Matrix;
    // (undocumented)
    resolve(): Matrix;
    // (undocumented)
    toJSON(): Matrix.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get values(): Matrix.Values<Number_2.Fixed>;
}

// @public (undocumented)
export namespace Matrix {
    // (undocumented)
    export function isMatrix(value: unknown): value is Matrix;
    // (undocumented)
    export interface JSON extends Function_3.JSON<"matrix"> {
        // (undocumented)
        values: Values<Number_2.Fixed.JSON>;
    }
    // (undocumented)
    export type Values<T> = [
    [
    T,
    T,
    T,
    T
    ],
    [
    T,
    T,
    T,
    T
    ],
    [
    T,
    T,
    T,
    T
    ],
    [
    T,
    T,
    T,
    T
    ]
    ];
    const // (undocumented)
    parse: Parser<Matrix>;
}

// @public (undocumented)
export class Named<C extends Named.Color = Named.Color> extends Format<"named"> {
    // (undocumented)
    get alpha(): Number_2.Fixed;
    // (undocumented)
    get blue(): Number_2.Fixed;
    // (undocumented)
    get color(): C;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get green(): Number_2.Fixed;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<C extends Named.Color>(color: C): Named<C>;
    // (undocumented)
    get red(): Number_2.Fixed;
    // (undocumented)
    resolve(): RGB.Canonical;
    // (undocumented)
    toJSON(): Named.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): number;
}

// @public (undocumented)
export namespace Named {
    // Warning: (ae-forgotten-export) The symbol "Colors" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export type Color = keyof Colors;
    // (undocumented)
    export interface JSON extends Format.JSON<"named"> {
        // (undocumented)
        color: string;
    }
    const // (undocumented)
    parse: Parser<Named>;
}

// @public (undocumented)
export class Nth implements Iterable<Token>, Equatable, Serializable {
    // (undocumented)
    [Symbol.iterator](): Iterator<Token>;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    for(n: number): number;
    // (undocumented)
    indices(): Iterable<number>;
    matches(index: number): boolean;
    // (undocumented)
    static of(step: number, offset?: number): Nth;
    // (undocumented)
    get offset(): number;
    // (undocumented)
    get step(): number;
    // (undocumented)
    toJSON(): Nth.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Nth {
    // (undocumented)
    export interface JSON {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        offset: number;
        // (undocumented)
        step: number;
    }
    const // (undocumented)
    parse: Parser<Nth>;
}

// @public (undocumented)
type Number_2 = Number_2.Calculated | Number_2.Fixed;

// @public (undocumented)
namespace Number_2 {
    class Calculated extends Numeric.Calculated<"number"> implements INumber<true> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: Math_2<"number">): Calculated;
        // (undocumented)
        resolve(): Canonical;
        // (undocumented)
        toJSON(): Calculated.JSON;
    }
    // (undocumented)
    namespace Calculated {
        // (undocumented)
        interface JSON extends Numeric.Calculated.JSON<"number"> {
        }
    }
    // (undocumented)
    type Canonical = Fixed;
    class Fixed extends Numeric.Fixed<"number"> implements INumber<false> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number | Number_3): Fixed;
        // (undocumented)
        resolve(): this;
        // (undocumented)
        scale(factor: number): Fixed;
        // (undocumented)
        toJSON(): Fixed.JSON;
    }
    // (undocumented)
    namespace Fixed {
        // (undocumented)
        interface JSON extends Numeric.Fixed.JSON<"number"> {
        }
    }
    // (undocumented)
    interface INumber<CALC extends boolean = boolean> extends Value<"number", CALC>, Resolvable<Canonical, never> {
        // (undocumented)
        hasCalculation(): this is Calculated;
        // (undocumented)
        resolve(): Canonical;
    }
    // (undocumented)
    function isCalculated(value: unknown): value is Calculated;
    // (undocumented)
    function isFixed(value: unknown): value is Fixed;
    // (undocumented)
    function isNumber(value: unknown): value is Number_2;
    // (undocumented)
    function of(value: number): Fixed;
    // (undocumented)
    function of(value: Number_3): Fixed;
    // (undocumented)
    function of(value: Math_2<"number">): Calculated;
    const // (undocumented)
    parse: Parser<Number_2>;
    const // (undocumented)
    parseZero: Parser<Fixed>;
    const // @internal (undocumented)
    parseBase: Parser_2<Slice<Token>, Fixed, string, []>;
        {};
}
export { Number_2 as Number }

// @public (undocumented)
class Number_3 extends Numeric_2<"number"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(value: number): Number_3;
    // (undocumented)
    scale(factor: number): Number_3;
    // (undocumented)
    toJSON(): Number_3.JSON;
}

// @public (undocumented)
namespace Number_3 {
    // (undocumented)
    function isNumber(value: unknown): value is Number_3;
    // (undocumented)
    interface JSON extends Numeric_2.JSON<"number"> {
    }
    const // (undocumented)
    parseZero: Parser<Number_3>;
    const // (undocumented)
    parse: Parser<Number_3>;
}

// @public (undocumented)
export type Numeric<T extends Numeric.Type = Numeric.Type> = Numeric.Calculated<T> | Numeric.Fixed<T>;

// @public (undocumented)
export namespace Numeric {
    export abstract class Calculated<T extends Type = Type, R extends Type = T> extends Value<T, true, R> implements INumeric<T, true, R> {
        // Warning: (ae-incompatible-release-tags) The symbol "__constructor" is marked as @public, but its signature references "ToMath" which is marked as @internal
        protected constructor(math: ToMath<T>, type: T);
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is Calculated<T, R>;
        // (undocumented)
        hash(hash: Hash): void;
        // Warning: (ae-incompatible-release-tags) The symbol "math" is marked as @public, but its signature references "ToMath" which is marked as @internal
        //
        // (undocumented)
        get math(): ToMath<T>;
        // Warning: (ae-incompatible-release-tags) The symbol "_math" is marked as @public, but its signature references "ToMath" which is marked as @internal
        //
        // (undocumented)
        protected readonly _math: ToMath<T>;
        // (undocumented)
        abstract resolve(resolver?: unknown): Fixed<R>;
        // (undocumented)
        toJSON(): Calculated.JSON<T>;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace Calculated {
        // (undocumented)
        export interface JSON<T extends Type = Type> extends Value.JSON<T> {
            // Warning: (ae-incompatible-release-tags) The symbol "math" is marked as @public, but its signature references "ToMath" which is marked as @internal
            //
            // (undocumented)
            math: Serializable.ToJSON<ToMath<T>>;
        }
    }
    export abstract class Fixed<T extends Type = Type, R extends Type = T> extends Value<T, false, R> implements INumeric<T, false, R>, Comparable<Fixed> {
        protected constructor(value: number, type: T);
        // (undocumented)
        compare(value: Fixed<T>): Comparison;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is never;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        isZero(): boolean;
        // (undocumented)
        abstract resolve(resolver?: unknown): Fixed<R>;
        // (undocumented)
        abstract scale(factor: number): Fixed<T, R>;
        // (undocumented)
        toJSON(): Fixed.JSON<T>;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get value(): number;
        // (undocumented)
        protected readonly _value: number;
    }
    // (undocumented)
    export namespace Fixed {
        // (undocumented)
        export interface JSON<T extends Type = Type> extends Value.JSON<T> {
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export interface INumeric<T extends Type = Type, CALC extends boolean = boolean, R extends Type = T> extends Value<T, CALC, R>, Resolvable<Fixed<R>, unknown> {
        // (undocumented)
        hasCalculation(): this is Calculated<T, R>;
        // (undocumented)
        resolve(resolver?: unknown): Fixed<R>;
    }
    // (undocumented)
    export function isCalculated(value: unknown): value is Calculated;
    // (undocumented)
    export function isFixed(value: unknown): value is Fixed;
    // (undocumented)
    export function isNumeric(value: unknown): value is Numeric;
    // (undocumented)
    export function isZero(value: Fixed): boolean;
    // @internal (undocumented)
    export type ToMath<T extends Type> = Math_2<T extends Numeric_2.Scalar ? "number" : T>;
    // (undocumented)
    export type Type = Numeric_2.Type | `${Numeric_2.Dimension}-percentage`;
        {};
}

// @public (undocumented)
abstract class Numeric_2<T extends Numeric_2.Type = Numeric_2.Type> implements Equatable, Hashable, Serializable {
    protected constructor(value: number, type: T);
    static readonly Decimals = 7;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    abstract scale(factor: number): Numeric_2<T>;
    // (undocumented)
    toJSON(): Numeric_2.JSON<T>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get type(): T;
    // (undocumented)
    protected readonly _type: T;
    // (undocumented)
    get value(): number;
    // (undocumented)
    protected readonly _value: number;
}

// @public (undocumented)
namespace Numeric_2 {
    // (undocumented)
    type Dimension = "angle" | "length";
    // (undocumented)
    function isNumeric(value: unknown): value is Numeric_2;
    // Warning: (ae-incompatible-release-tags) The symbol "JSON" is marked as @public, but its signature references "Type" which is marked as @internal
    //
    // (undocumented)
    interface JSON<T extends Type = Type> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: T;
        // (undocumented)
        value: number;
    }
    // (undocumented)
    type Ratio = "percentage";
    // (undocumented)
    type Scalar = "integer" | "number";
    // @internal (undocumented)
    type Type = Scalar | Ratio | Dimension;
}

// @public (undocumented)
export type Parser<V> = Parser_2<Slice<Token>, V, string>;

// @public (undocumented)
export type Percentage = Percentage.Calculated | Percentage.Fixed;

// @public (undocumented)
export namespace Percentage {
    export class Calculated<R extends Numeric_2.Type = Numeric_2.Type> extends Numeric.Calculated<"percentage", "percentage" | R> implements IPercentage<true, R> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hasCalculation(): this is Calculated<R>;
        // (undocumented)
        static of(value: Math_2<"percentage">): Calculated;
        // (undocumented)
        resolve(): Fixed<"percentage">;
        // (undocumented)
        resolve<T extends Numeric.Fixed<R>>(resolver: Resolver<R, T>): T;
        // (undocumented)
        toJSON(): Calculated.JSON;
    }
    // (undocumented)
    export namespace Calculated {
        // (undocumented)
        export interface JSON extends Numeric.Calculated.JSON<"percentage"> {
        }
    }
    // (undocumented)
    export type Canonical = Fixed;
    export class Fixed<R extends Numeric_2.Type = Numeric_2.Type> extends Numeric.Fixed<"percentage", "percentage" | R> implements IPercentage<false, R> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of<R extends Numeric_2.Type = Numeric_2.Type>(value: number | Percentage_2): Fixed<R>;
        // (undocumented)
        resolve(): Fixed<"percentage">;
        // (undocumented)
        resolve<T extends Numeric.Fixed<R>>(resolver: Resolver<R, T>): T;
        // (undocumented)
        scale(factor: number): Fixed<R>;
        // (undocumented)
        toJSON(): Fixed.JSON;
        // (undocumented)
        toString(): string;
    }
    // (undocumented)
    export namespace Fixed {
        // (undocumented)
        export interface JSON extends Numeric.Fixed.JSON<"percentage"> {
        }
    }
    // (undocumented)
    export interface IPercentage<CALC extends boolean = boolean, R extends Numeric_2.Type = Numeric_2.Type> extends Value<"percentage", CALC, "percentage" | R>, Resolvable<Canonical | Numeric.Fixed<R>, Resolver<R, Numeric.Fixed<R>>> {
        // (undocumented)
        hasCalculation(): this is Calculated<R>;
        // (undocumented)
        resolve<T extends Numeric.Fixed<R>>(resolver?: Resolver<R, T>): Fixed<"percentage"> | T;
    }
    // (undocumented)
    export function isCalculated(value: unknown): value is Calculated;
    // (undocumented)
    export function isFixed(value: unknown): value is Fixed;
    // (undocumented)
    export function isPercentage(value: unknown): value is Percentage;
    // (undocumented)
    export function of(value: number): Fixed;
    // (undocumented)
    export function of(value: Percentage_2): Fixed;
    // (undocumented)
    export function of(value: Math_2<"percentage">): Calculated;
    // (undocumented)
    export interface Resolver<R extends Numeric_2.Type, T extends Numeric.Fixed<R>> {
        // (undocumented)
        percentageBase: T;
    }
    const // (undocumented)
    parse: Parser<Percentage>;
    const // @internal (undocumented)
    parseBase: Parser_2<Slice<Token>, Fixed<Numeric_2.Type>, string, []>;
        {};
}

// @public (undocumented)
class Percentage_2 extends Numeric_2<"percentage"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    static of(value: number): Percentage_2;
    // (undocumented)
    scale(factor: number): Percentage_2;
    // (undocumented)
    toJSON(): Percentage_2.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
namespace Percentage_2 {
    // (undocumented)
    function isPercentage(value: unknown): value is Percentage_2;
    // (undocumented)
    interface JSON extends Numeric_2.JSON<"percentage"> {
    }
    const // (undocumented)
    parse: Parser<Percentage_2>;
}

// @public (undocumented)
export class Perspective<D extends Length.Fixed = Length.Fixed> extends Function_3<"perspective"> {
    // (undocumented)
    get depth(): D;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<D extends Length.Fixed>(depth: D): Perspective<D>;
    // (undocumented)
    resolve(): Perspective<D>;
    // (undocumented)
    toJSON(): Perspective.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Perspective {
    // (undocumented)
    export type Canonical = Perspective<Length.Canonical>;
    // (undocumented)
    export function isPerspective<D extends Length.Fixed>(value: unknown): value is Perspective<D>;
    // (undocumented)
    export interface JSON extends Function_3.JSON<"perspective"> {
        // (undocumented)
        depth: Length.Fixed.JSON;
    }
    const // (undocumented)
    parse: Parser<Perspective>;
}

// @public (undocumented)
export class Polygon<F extends Polygon.Fill = Polygon.Fill, V extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed> extends BasicShape<"polygon"> {
    // (undocumented)
    equals(value: Polygon): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get fill(): Option<F>;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<F extends Polygon.Fill = Polygon.Fill, V extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed>(fill: Option<F>, vertices: Iterable_2<Polygon.Vertex<V>>): Polygon<F, V>;
    // (undocumented)
    resolve(): Polygon<F, V>;
    // (undocumented)
    toJSON(): Polygon.JSON<F, V>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get vertices(): ReadonlyArray<Polygon.Vertex<V>>;
}

// @public (undocumented)
export namespace Polygon {
    // (undocumented)
    export type Fill = Keyword<"nonzero"> | Keyword<"evenodd">;
    // (undocumented)
    export interface JSON<F extends Fill = Fill, V extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed> extends BasicShape.JSON<"polygon"> {
        // (undocumented)
        fill: Option.JSON<F>;
        // (undocumented)
        vertices: Array_2<Serializable.ToJSON<Vertex<V>>>;
    }
    // (undocumented)
    export type Vertex<V extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed> = readonly [V, V];
    const // (undocumented)
    parse: Parser<Polygon>;
}

// @public (undocumented)
export class Position<H extends Position.Keywords.Horizontal = Position.Keywords.Horizontal, V extends Position.Keywords.Vertical = Position.Keywords.Vertical, HC extends Position.Component<H> = Position.Component<H>, VC extends Position.Component<V> = Position.Component<V>, CALC extends boolean = boolean> extends Value<"position", CALC> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get horizontal(): HC;
    // (undocumented)
    static of<H extends Position.Keywords.Horizontal = Position.Keywords.Horizontal, V extends Position.Keywords.Vertical = Position.Keywords.Vertical, HC extends Position.Component<H> = Position.Component<H>, VC extends Position.Component<V> = Position.Component<V>>(horizontal: HC, vertical: VC): Position<H, V, HC, VC, Value.HasCalculation<[HC, VC]>>;
    // (undocumented)
    resolve(resolver: Position.Resolver): Position.Canonical<H, V>;
    // (undocumented)
    toJSON(): Position.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get vertical(): VC;
}

// @public (undocumented)
export namespace Position {
    // Warning: (ae-forgotten-export) The symbol "Keywords" needs to be exported by the entry point index.d.ts
    // Warning: (ae-forgotten-export) The symbol "Component" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    export type Canonical<H extends Keywords.Horizontal = Keywords.Horizontal, V extends Keywords.Vertical = Keywords.Vertical> = Position<H, V, Component_2.Canonical<H>, Component_2.Canonical<V>, false>;
    // @internal (undocumented)
    export type Fixed<H extends Keywords.Horizontal = Keywords.Horizontal, V extends Keywords.Vertical = Keywords.Vertical> = Position<H, V, Component_2.Fixed<H>, Component_2.Fixed<V>, false>;
    // (undocumented)
    export interface JSON extends Value.JSON<"position"> {
        // (undocumented)
        horizontal: Component_2.JSON;
        // (undocumented)
        vertical: Component_2.JSON;
    }
    export function parse(legacySyntax?: boolean): Parser<Position>;
    import Keywords = keywords.Keywords;
    import Side = side.Side;
    import Component = component.Component;
    // Warning: (ae-incompatible-release-tags) The symbol "parseBase" is marked as @public, but its signature references "Fixed" which is marked as @internal
    //
    // (undocumented)
    export function parseBase(legacySyntax?: boolean): Parser<Fixed>;
    // (undocumented)
    export function partiallyResolve<H extends Keywords.Horizontal, V extends Keywords.Vertical>(resolver: PartialResolver): (value: Position<H, V>) => PartiallyResolved<H, V>;
    // (undocumented)
    export type PartiallyResolved<H extends Keywords.Horizontal = Keywords.Horizontal, V extends Keywords.Vertical = Keywords.Vertical> = Position<H, V, Component_2.PartiallyResolved<H>, Component_2.PartiallyResolved<V>>;
    // (undocumented)
    export type PartialResolver = Component_2.PartialResolver;
    export interface Resolver extends Length.Resolver {
        // (undocumented)
        percentageHBase: Length.Canonical;
        // (undocumented)
        percentageVBase: Length.Canonical;
    }
}

// @public (undocumented)
export class Radial<I extends Gradient.Item = Gradient.Item, S extends Radial.Shape = Radial.Shape, P extends Position.Fixed = Position.Fixed> extends Value<"gradient", false> {
    // (undocumented)
    equals(value: Radial): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get items(): Iterable<I>;
    // (undocumented)
    get kind(): "radial";
    // (undocumented)
    static of<I extends Gradient.Item = Gradient.Item, S extends Radial.Shape = Radial.Shape, P extends Position.Fixed = Position.Fixed>(shape: S, position: P, items: Iterable<I>, repeats: boolean): Radial<I, S, P>;
    // (undocumented)
    get position(): P;
    // (undocumented)
    get repeats(): boolean;
    // (undocumented)
    resolve(): Radial<I, S, P>;
    // (undocumented)
    get shape(): S;
    // (undocumented)
    toJSON(): Radial.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Radial {
    // (undocumented)
    export type Canonical = Radial<Gradient.Hint.Canonical | Gradient.Stop.Canonical, Radial.Circle.Canonical | Radial.Ellipse.Canonical | Radial.Extent, Position.Fixed>;
    // (undocumented)
    export class Circle<R extends Length.Fixed = Length.Fixed> implements Equatable, Hashable, Serializable<Circle.JSON> {
        // (undocumented)
        equals(value: Circle): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of<R extends Length.Fixed>(radius: R): Circle<R>;
        // (undocumented)
        get radius(): R;
        // (undocumented)
        toJSON(): Circle.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "circle";
    }
    // (undocumented)
    export namespace Circle {
        // (undocumented)
        export type Canonical = Circle<Length.Canonical>;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            radius: Length.Fixed.JSON;
            // (undocumented)
            type: "circle";
        }
    }
    // (undocumented)
    export class Ellipse<R extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed> implements Equatable, Hashable, Serializable<Ellipse.JSON> {
        // (undocumented)
        equals(value: Ellipse): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        get horizontal(): R;
        // (undocumented)
        static of<R extends Length.Fixed | Percentage.Fixed>(horizontal: R, vertical: R): Ellipse<R>;
        // (undocumented)
        toJSON(): Ellipse.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "ellipse";
        // (undocumented)
        get vertical(): R;
    }
    // (undocumented)
    export namespace Ellipse {
        // (undocumented)
        export type Canonical = Ellipse<Percentage.Canonical | Length.Canonical>;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            horizontal: Length.Fixed.JSON | Percentage.Fixed.JSON;
            // (undocumented)
            type: "ellipse";
            // (undocumented)
            vertical: Length.Fixed.JSON | Percentage.Fixed.JSON;
        }
    }
    // (undocumented)
    export class Extent implements Equatable, Hashable, Serializable<Extent.JSON> {
        // (undocumented)
        equals(value: Extent): boolean;
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        hash(hash: Hash): void;
        // (undocumented)
        static of(shape?: Extent.Shape, size?: Extent.Size): Extent;
        // (undocumented)
        get shape(): Extent.Shape;
        // (undocumented)
        get size(): Extent.Size;
        // (undocumented)
        toJSON(): Extent.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "extent";
    }
    // (undocumented)
    export namespace Extent {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            shape: `${Shape}`;
            // (undocumented)
            size: `${Size}`;
            // (undocumented)
            type: "extent";
        }
        // (undocumented)
        export enum Shape {
            // (undocumented)
            Circle = "circle",
            // (undocumented)
            Ellipse = "ellipse"
        }
        // (undocumented)
        export enum Size {
            // (undocumented)
            ClosestCorner = "closest-corner",
            // (undocumented)
            ClosestSide = "closest-side",
            // (undocumented)
            FarthestCorner = "farthest-corner",
            // (undocumented)
            FarthestSide = "farthest-side"
        }
    }
    // (undocumented)
    export interface JSON extends Value.JSON<"gradient"> {
        // (undocumented)
        items: Array<Gradient.Item.JSON>;
        // (undocumented)
        kind: "radial";
        // (undocumented)
        position: Position.JSON;
        // (undocumented)
        repeats: boolean;
        // (undocumented)
        shape: Shape.JSON;
    }
    // (undocumented)
    export function parse(parseItemList: Parser<Array<Gradient.Item>>): Parser<Radial>;
    // (undocumented)
    export type Shape = Circle | Ellipse | Extent;
    // (undocumented)
    export namespace Shape {
        // (undocumented)
        export type JSON = Circle.JSON | Ellipse.JSON | Extent.JSON;
    }
}

// @public (undocumented)
export class Radius<R extends Length.Fixed | Percentage.Fixed | Radius.Side = Length.Fixed | Percentage.Fixed | Radius.Side> extends BasicShape<"radius"> {
    // (undocumented)
    equals(value: Radius): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<R extends Length.Fixed | Percentage.Fixed | Radius.Side>(value: R): Radius<R>;
    // (undocumented)
    resolve(): Radius<R>;
    // (undocumented)
    toJSON(): Radius.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): R;
}

// @public (undocumented)
export namespace Radius {
    // (undocumented)
    export function isRadius(value: unknown): value is Radius;
    // (undocumented)
    export interface JSON extends BasicShape.JSON<"radius"> {
        // (undocumented)
        value: Length.Fixed.JSON | Percentage.Fixed.JSON | Keyword.JSON;
    }
    // (undocumented)
    export type Side = Side.Closest | Side.Farthest;
    // (undocumented)
    export namespace Side {
        // (undocumented)
        export type Closest = Keyword<"closest-side">;
        // (undocumented)
        export type Farthest = Keyword<"farthest-side">;
    }
    const // (undocumented)
    parse: Parser<Radius>;
}

// @public @deprecated (undocumented)
export class Rectangle<O extends Length.Fixed | Rectangle.Auto = Length.Fixed | Rectangle.Auto> extends BasicShape<"rectangle"> {
    // (undocumented)
    get bottom(): O;
    // (undocumented)
    readonly _bottom: O;
    // (undocumented)
    equals(value: Rectangle): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get left(): O;
    // (undocumented)
    readonly _left: O;
    // (undocumented)
    static of<O extends Length.Fixed | Rectangle.Auto = Length.Fixed | Rectangle.Auto>(top: O, right: O, bottom: O, left: O): Rectangle<O>;
    // (undocumented)
    resolve(): Rectangle<O>;
    // (undocumented)
    get right(): O;
    // (undocumented)
    readonly _right: O;
    // (undocumented)
    toJSON(): Rectangle.JSON;
    // (undocumented)
    get top(): O;
    // (undocumented)
    readonly _top: O;
    // (undocumented)
    toString(): string;
}

// @public @deprecated (undocumented)
export namespace Rectangle {
    // (undocumented)
    export type Auto = Keyword<"auto">;
    // (undocumented)
    export function isRectangle(value: unknown): value is Rectangle;
    // (undocumented)
    export interface JSON extends BasicShape.JSON<"rectangle"> {
        // (undocumented)
        bottom: Length.Fixed.JSON | Keyword.JSON;
        // (undocumented)
        left: Length.Fixed.JSON | Keyword.JSON;
        // (undocumented)
        right: Length.Fixed.JSON | Keyword.JSON;
        // (undocumented)
        top: Length.Fixed.JSON | Keyword.JSON;
    }
    const // (undocumented)
    parse: Parser<Rectangle>;
}

// @public (undocumented)
export class RGB<C extends Number_2.Canonical | Percentage.Canonical = Number_2.Canonical | Percentage.Fixed, A extends Number_2.Canonical | Percentage.Canonical = Number_2.Canonical | Percentage.Fixed> extends Format<"rgb"> {
    // (undocumented)
    get alpha(): A;
    // (undocumented)
    get blue(): C;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    get green(): C;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<C extends Number_2.Canonical | Percentage.Canonical, A extends Number_2.Canonical | Percentage.Canonical>(red: C, green: C, blue: C, alpha: A): RGB<C, A>;
    // Warning: (ae-forgotten-export) The symbol "ToCanonical" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    static of<C extends Number_2 | Percentage, A extends Number_2 | Percentage>(red: C, green: C, blue: C, alpha: A): RGB<ToCanonical<C>, ToCanonical<A>>;
    // (undocumented)
    get red(): C;
    // (undocumented)
    resolve(): RGB.Canonical;
    // (undocumented)
    toJSON(): RGB.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace RGB {
    // (undocumented)
    export type Canonical = RGB<Percentage.Canonical, Percentage.Canonical>;
    // (undocumented)
    export function isRGB<C extends Number_2.Canonical | Percentage.Canonical, A extends Number_2.Canonical | Percentage.Canonical>(value: unknown): value is RGB<C, A>;
    // (undocumented)
    export interface JSON extends Format.JSON<"rgb"> {
        // (undocumented)
        alpha: Number_2.Fixed.JSON | Percentage.Fixed.JSON;
        // (undocumented)
        blue: Number_2.Fixed.JSON | Percentage.Fixed.JSON;
        // (undocumented)
        green: Number_2.Fixed.JSON | Percentage.Fixed.JSON;
        // (undocumented)
        red: Number_2.Fixed.JSON | Percentage.Fixed.JSON;
    }
    const // (undocumented)
    parse: Parser<RGB>;
}

// @public (undocumented)
export class Rotate<A extends Angle.Fixed = Angle.Fixed> extends Function_3<"rotate"> {
    // (undocumented)
    get angle(): A;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<A extends Angle.Fixed>(x: Number_2.Fixed, y: Number_2.Fixed, z: Number_2.Fixed, angle: A): Rotate<A>;
    // (undocumented)
    resolve(): Rotate<A>;
    // (undocumented)
    toJSON(): Rotate.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get x(): Number_2.Fixed;
    // (undocumented)
    get y(): Number_2.Fixed;
    // (undocumented)
    get z(): Number_2.Fixed;
}

// @public (undocumented)
export namespace Rotate {
    // (undocumented)
    export type Canonical = Rotate<Angle.Canonical>;
    // (undocumented)
    export function isRotate<A extends Angle.Fixed>(value: unknown): value is Rotate<A>;
    // (undocumented)
    export interface JSON extends Function_3.JSON<"rotate"> {
        // (undocumented)
        angle: Angle.Fixed.JSON;
        // (undocumented)
        x: Number_2.Fixed.JSON;
        // (undocumented)
        y: Number_2.Fixed.JSON;
        // (undocumented)
        z: Number_2.Fixed.JSON;
    }
    const // (undocumented)
    parse: Parser<Rotate>;
}

// @public (undocumented)
export class Scale extends Function_3<"scale"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get kind(): "scale";
    // (undocumented)
    static of(x: Number_2.Fixed, y: Number_2.Fixed): Scale;
    // (undocumented)
    resolve(): Scale;
    // (undocumented)
    toJSON(): Scale.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get x(): Number_2.Fixed;
    // (undocumented)
    get y(): Number_2.Fixed;
}

// @public (undocumented)
export namespace Scale {
    // (undocumented)
    export function isScale(value: unknown): value is Scale;
    // (undocumented)
    export interface JSON extends Function_3.JSON<"scale"> {
        // (undocumented)
        x: Number_2.Fixed.JSON;
        // (undocumented)
        y: Number_2.Fixed.JSON;
    }
    const // (undocumented)
    parse: Parser<Scale>;
}

// @public (undocumented)
export class Shadow<H extends Length.Fixed = Length.Fixed, V extends Length.Fixed = H, B extends Length.Fixed = Length.Fixed, S extends Length.Fixed = Length.Fixed, C extends Color = Color> extends Value<"shadow", false> {
    // (undocumented)
    get blur(): B;
    // (undocumented)
    get color(): C;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    get horizontal(): H;
    // (undocumented)
    get isInset(): boolean;
    // (undocumented)
    static of<H extends Length.Fixed = Length.Fixed, V extends Length.Fixed = H, B extends Length.Fixed = Length.Fixed, S extends Length.Fixed = Length.Fixed, C extends Color = Color>(horizontal: H, vertical: V, blur: B, spread: S, color: C, isInset: boolean): Shadow<H, V, B, S, C>;
    // (undocumented)
    resolve(resolver: Length.Resolver): Shadow.Canonical;
    // (undocumented)
    get spread(): S;
    // (undocumented)
    toJSON(): Shadow.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get vertical(): V;
}

// @public (undocumented)
export namespace Shadow {
    // (undocumented)
    export type Canonical = Shadow<Length.Canonical, Length.Canonical, Length.Canonical, Length.Canonical, Color.Canonical>;
    // (undocumented)
    export interface JSON extends Value.JSON<"shadow"> {
        // (undocumented)
        blur: Length.Fixed.JSON;
        // (undocumented)
        color: Color.JSON;
        // (undocumented)
        horizontal: Length.Fixed.JSON;
        // (undocumented)
        isInset: boolean;
        // (undocumented)
        spread: Length.Fixed.JSON;
        // (undocumented)
        vertical: Length.Fixed.JSON;
    }
    // (undocumented)
    export interface Options {
        // (undocumented)
        withInset: boolean;
        // (undocumented)
        withSpread: boolean;
    }
    // (undocumented)
    export function parse(options?: Options): Parser<Shadow>;
        {};
}

// @public (undocumented)
export class Shape<S extends Shape.Basic = Shape.Basic, B extends Box.Geometry = Box.Geometry> extends Value<"shape", false> {
    // (undocumented)
    get box(): B;
    // (undocumented)
    equals(value: Shape): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<S extends Shape.Basic = Shape.Basic, B extends Box.Geometry = Box.Geometry>(shape: S, box: B): Shape<S, B>;
    // (undocumented)
    resolve(): Shape<S, B>;
    // (undocumented)
    get shape(): S;
    // (undocumented)
    toJSON(): Shape.JSON;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export namespace Shape {
    // (undocumented)
    export type Basic = Circle | Ellipse | Inset | Polygon | Rectangle;
    // (undocumented)
    export interface JSON extends Value.JSON<"shape"> {
        // (undocumented)
        box: Box.Geometry.JSON;
        // (undocumented)
        shape: Circle.JSON | Ellipse.JSON | Inset.JSON | Polygon.JSON | Rectangle.JSON;
    }
    const // (undocumented)
    parse: Parser<Shape<Circle | Ellipse | Inset | Polygon>>;
}

// @public (undocumented)
export class Skew<X extends Angle.Fixed = Angle.Fixed, Y extends Angle.Fixed = Angle.Fixed> extends Function_3<"skew"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<X extends Angle.Fixed, Y extends Angle.Fixed>(x: X, y: Y): Skew<X, Y>;
    // (undocumented)
    resolve(): Skew<X, Y>;
    // (undocumented)
    toJSON(): Skew.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get x(): X;
    // (undocumented)
    get y(): Y;
}

// @public (undocumented)
export namespace Skew {
    // (undocumented)
    export type Canonical = Skew<Angle.Canonical, Angle.Canonical>;
    // (undocumented)
    export function isSkew<X extends Angle.Fixed, Y extends Angle.Fixed>(value: unknown): value is Skew<X, Y>;
    // (undocumented)
    export interface JSON extends Function_3.JSON<"skew"> {
        // (undocumented)
        x: Angle.Fixed.JSON;
        // (undocumented)
        y: Angle.Fixed.JSON;
    }
    const // (undocumented)
    parse: Parser<Skew>;
}

// @public (undocumented)
class String_2 extends Value<"string", false> implements Resolvable<String_2, never> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(value: string): String_2;
    // (undocumented)
    resolve(): String_2;
    // (undocumented)
    toJSON(): String_2.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get value(): string;
}

// @public (undocumented)
namespace String_2 {
    // (undocumented)
    function isString(value: unknown): value is String_2;
    // (undocumented)
    interface JSON extends Value.JSON<"string"> {
        // (undocumented)
        value: string;
    }
    const // (undocumented)
    parse: Parser<String_2>;
}
export { String_2 as String }

// @public (undocumented)
export type System = Keyword<System.Keyword>;

// @public (undocumented)
export namespace System {
    // (undocumented)
    export type Keyword = "canvas" | "canvastext" | "linktext" | "visitedtext" | "activetext" | "buttonface" | "buttontext" | "field" | "fieldtext" | "highlight" | "highlighttext" | "graytext";
    const // (undocumented)
    parse: Parser<System>;
}

// @public (undocumented)
export type Token = Token.Ident | Token.Function | Token.AtKeyword | Token.Hash | Token.String | Token.URL | Token.BadURL | Token.Delim | Token.Number | Token.Percentage | Token.Dimension | Token.Whitespace | Token.Colon | Token.Semicolon | Token.Comma | Token.OpenParenthesis | Token.CloseParenthesis | Token.OpenSquareBracket | Token.CloseSquareBracket | Token.OpenCurlyBracket | Token.CloseCurlyBracket | Token.OpenComment | Token.CloseComment;

// @public (undocumented)
export namespace Token {
    // (undocumented)
    export class AtKeyword implements Equatable, Serializable<AtKeyword.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): AtKeyword;
        // (undocumented)
        toJSON(): AtKeyword.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "at-keyword";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace AtKeyword {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "at-keyword";
            // (undocumented)
            value: string;
        }
    }
    // (undocumented)
    export class BadURL implements Equatable, Serializable<BadURL.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): BadURL;
        // (undocumented)
        toJSON(): BadURL.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "bad-url";
    }
    const // (undocumented)
    ident: typeof Ident.of, // (undocumented)
    isIdent: typeof Ident.isIdent;
    // (undocumented)
    export namespace BadURL {
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "bad-url";
        }
    }
    // (undocumented)
    export class CloseComment implements Equatable, Serializable<CloseComment.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): CloseComment;
        // (undocumented)
        toJSON(): CloseComment.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "close-comment";
    }
    // (undocumented)
    export namespace CloseComment {
        // (undocumented)
        export function isCloseComment(value: unknown): value is CloseComment;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "close-comment";
        }
    }
    const // (undocumented)
    func: typeof Function.of, // (undocumented)
    isFunction: typeof Function.isFunction;
    // (undocumented)
    export class CloseCurlyBracket implements Equatable, Serializable<CloseCurlyBracket.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): OpenCurlyBracket;
        // (undocumented)
        static of(): CloseCurlyBracket;
        // (undocumented)
        toJSON(): CloseCurlyBracket.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "close-curly-bracket";
    }
    // (undocumented)
    export namespace CloseCurlyBracket {
        // (undocumented)
        export function isCloseCurlyBracket(value: unknown): value is CloseCurlyBracket;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "close-curly-bracket";
        }
    }
    // (undocumented)
    export class CloseParenthesis implements Equatable, Serializable<CloseParenthesis.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): OpenParenthesis;
        // (undocumented)
        static of(): CloseParenthesis;
        // (undocumented)
        toJSON(): CloseParenthesis.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "close-parenthesis";
    }
    const // (undocumented)
    atKeyword: typeof AtKeyword.of;
    // (undocumented)
    export namespace CloseParenthesis {
        // (undocumented)
        export function isCloseParenthesis(value: unknown): value is CloseParenthesis;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "close-parenthesis";
        }
    }
    // (undocumented)
    export class CloseSquareBracket implements Equatable, Serializable<CloseSquareBracket.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): OpenSquareBracket;
        // (undocumented)
        static of(): CloseSquareBracket;
        // (undocumented)
        toJSON(): CloseSquareBracket.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "close-square-bracket";
    }
    const // (undocumented)
    hash: typeof Hash.of, // (undocumented)
    isHash: typeof Hash.isHash;
    // (undocumented)
    export namespace CloseSquareBracket {
        // (undocumented)
        export function isCloseSquareBracket(value: unknown): value is CloseSquareBracket;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "close-square-bracket";
        }
    }
    // (undocumented)
    export class Colon implements Equatable, Serializable<Colon.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): Colon;
        // (undocumented)
        toJSON(): Colon.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "colon";
    }
    // (undocumented)
    export namespace Colon {
        // (undocumented)
        export function isColon(value: unknown): value is Colon;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "colon";
        }
    }
    const // (undocumented)
    string: typeof String.of, // (undocumented)
    isString: typeof String.isString;
    // (undocumented)
    export class Comma implements Equatable, Serializable<Comma.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): Comma;
        // (undocumented)
        toJSON(): Comma.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "comma";
    }
    // (undocumented)
    export namespace Comma {
        // (undocumented)
        export function isComma(value: unknown): value is Comma;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "comma";
        }
    }
    // (undocumented)
    export class Delim implements Equatable, Serializable<Delim.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: number): Delim;
        // (undocumented)
        toJSON(): Delim.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "delim";
        // (undocumented)
        get value(): number;
    }
    const // (undocumented)
    url: typeof URL.of, // (undocumented)
    isURL: typeof URL.isURL;
    // (undocumented)
    export namespace Delim {
        // (undocumented)
        export function isDelim(value: unknown): value is Delim;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "delim";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export class Dimension implements Equatable, Serializable<Dimension.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get isInteger(): boolean;
        // (undocumented)
        get isSigned(): boolean;
        // (undocumented)
        static of(value: number, unit: string, isInteger: boolean, isSigned: boolean): Dimension;
        // (undocumented)
        toJSON(): Dimension.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "dimension";
        // (undocumented)
        get unit(): string;
        // (undocumented)
        get value(): number;
    }
    // (undocumented)
    export namespace Dimension {
        // (undocumented)
        export function isDimension(value: unknown): value is Dimension;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            isInteger: boolean;
            // (undocumented)
            isSigned: boolean;
            // (undocumented)
            type: "dimension";
            // (undocumented)
            unit: string;
            // (undocumented)
            value: number;
        }
    }
    const // (undocumented)
    badURL: typeof BadURL.of;
    // (undocumented)
    export class Function implements Equatable, Serializable<Function.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): CloseParenthesis;
        // (undocumented)
        static of(value: string): Function;
        // (undocumented)
        toJSON(): Function.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "function";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace Function {
        // (undocumented)
        export function isFunction(value: unknown): value is Function;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "function";
            // (undocumented)
            value: string;
        }
    }
    const // (undocumented)
    delim: typeof Delim.of, // (undocumented)
    isDelim: typeof Delim.isDelim;
    // (undocumented)
    export class Hash implements Equatable, Serializable<Hash.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get isIdentifier(): boolean;
        // (undocumented)
        static of(value: string, isIdentifier: boolean): Hash;
        // (undocumented)
        toJSON(): Hash.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "hash";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace Hash {
        // (undocumented)
        export function isHash(value: unknown): value is Hash;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            isIdentifier: boolean;
            // (undocumented)
            type: "hash";
            // (undocumented)
            value: string;
        }
    }
    // (undocumented)
    export class Ident implements Equatable, Serializable<Ident.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): Ident;
        // (undocumented)
        toJSON(): Ident.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "ident";
        // (undocumented)
        get value(): string;
    }
    const // (undocumented)
    number: typeof Number.of, // (undocumented)
    isNumber: typeof Number.isNumber;
    // (undocumented)
    export namespace Ident {
        // (undocumented)
        export function isIdent(value: unknown): value is Ident;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "ident";
            // (undocumented)
            value: string;
        }
    }
    // (undocumented)
    export type JSON = Ident.JSON | Function.JSON | AtKeyword.JSON | Hash.JSON | String.JSON | URL.JSON | BadURL.JSON | Delim.JSON | Number.JSON | Percentage.JSON | Dimension.JSON | Whitespace.JSON | Colon.JSON | Semicolon.JSON | Comma.JSON | OpenParenthesis.JSON | CloseParenthesis.JSON | OpenSquareBracket.JSON | CloseSquareBracket.JSON | OpenCurlyBracket.JSON | CloseCurlyBracket.JSON | OpenComment.JSON | CloseComment.JSON;
    // (undocumented)
    export class Number implements Equatable, Serializable<Number.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get isInteger(): boolean;
        // (undocumented)
        get isSigned(): boolean;
        // (undocumented)
        static of(value: number, isInteger: boolean, isSigned: boolean): Number;
        // (undocumented)
        toJSON(): Number.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "number";
        // (undocumented)
        get value(): number;
    }
    const // (undocumented)
    percentage: typeof Percentage.of, // (undocumented)
    isPercentage: typeof Percentage.isPercentage;
    // (undocumented)
    export namespace Number {
        // (undocumented)
        export function isNumber(value: unknown): value is Number;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            isInteger: boolean;
            // (undocumented)
            isSigned: boolean;
            // (undocumented)
            type: "number";
            // (undocumented)
            value: number;
        }
    }
    // (undocumented)
    export class OpenComment implements Equatable, Serializable<OpenComment.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): OpenComment;
        // (undocumented)
        toJSON(): OpenComment.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "open-comment";
    }
    // (undocumented)
    export namespace OpenComment {
        // (undocumented)
        export function isOpenComment(value: unknown): value is OpenComment;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "open-comment";
        }
    }
    const // (undocumented)
    dimension: typeof Dimension.of, // (undocumented)
    isDimension: typeof Dimension.isDimension;
    // (undocumented)
    export class OpenCurlyBracket implements Equatable, Serializable<OpenCurlyBracket.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): CloseCurlyBracket;
        // (undocumented)
        static of(): OpenCurlyBracket;
        // (undocumented)
        toJSON(): OpenCurlyBracket.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "open-curly-bracket";
    }
    // (undocumented)
    export namespace OpenCurlyBracket {
        // (undocumented)
        export function isOpenCurlyBracket(value: unknown): value is OpenCurlyBracket;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "open-curly-bracket";
        }
    }
    // (undocumented)
    export class OpenParenthesis implements Equatable, Serializable<OpenParenthesis.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): CloseParenthesis;
        // (undocumented)
        static of(): OpenParenthesis;
        // (undocumented)
        toJSON(): OpenParenthesis.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "open-parenthesis";
    }
    const // (undocumented)
    whitespace: typeof Whitespace.of, // (undocumented)
    isWhitespace: typeof Whitespace.isWhitespace;
    const // (undocumented)
    parseWhitespace: Parser_2<Slice<Token>, Whitespace, string, []>;
    // (undocumented)
    export namespace OpenParenthesis {
        // (undocumented)
        export function isOpenParenthesis(value: unknown): value is OpenParenthesis;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "open-parenthesis";
        }
    }
    // (undocumented)
    export class OpenSquareBracket implements Equatable, Serializable<OpenSquareBracket.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get mirror(): CloseSquareBracket;
        // (undocumented)
        static of(): OpenSquareBracket;
        // (undocumented)
        toJSON(): OpenSquareBracket.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "open-square-bracket";
    }
    const // (undocumented)
    colon: typeof Colon.of, // (undocumented)
    isColon: typeof Colon.isColon;
    const // (undocumented)
    parseColon: Parser_2<Slice<Token>, Colon, string, []>;
    // (undocumented)
    export namespace OpenSquareBracket {
        // (undocumented)
        export function isOpenSquareBracket(value: unknown): value is OpenSquareBracket;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "open-square-bracket";
        }
    }
    // (undocumented)
    export function parseDelim(query?: string | number | Predicate<Delim>): Parser_2<Slice<Token>, Delim, string, []>;
    const // (undocumented)
    semicolon: typeof Semicolon.of, // (undocumented)
    isSemicolon: typeof Semicolon.isSemicolon;
    const // (undocumented)
    parseSemicolon: Parser_2<Slice<Token>, Semicolon, string, []>;
    // (undocumented)
    export function parseDimension(predicate?: Predicate<Dimension>): Parser_2<Slice<Token>, Dimension, string, []>;
    // (undocumented)
    export function parseFunction(query?: string | Predicate<Function>): Parser_2<Slice<Token>, Function, string, []>;
    const // (undocumented)
    comma: typeof Comma.of, // (undocumented)
    isComma: typeof Comma.isComma;
    const // (undocumented)
    parseComma: Parser_2<Slice<Token>, Comma, string, []>;
    // (undocumented)
    export function parseHash(predicate?: Predicate<Hash>): Parser_2<Slice<Token>, Hash, string, []>;
    // (undocumented)
    export function parseIdent(query?: string | Predicate<Ident>): Parser_2<Slice<Token>, Ident, string, []>;
    const // (undocumented)
    openParenthesis: typeof OpenParenthesis.of, // (undocumented)
    isOpenParenthesis: typeof OpenParenthesis.isOpenParenthesis;
    const // (undocumented)
    parseOpenParenthesis: Parser_2<Slice<Token>, OpenParenthesis, string, []>;
    // (undocumented)
    export function parseNumber(predicate?: Predicate<Number>): Parser_2<Slice<Token>, Number, string, []>;
    // (undocumented)
    export function parsePercentage(predicate?: Predicate<Percentage>): Parser_2<Slice<Token>, Percentage, string, []>;
    const // (undocumented)
    closeParenthesis: typeof CloseParenthesis.of, // (undocumented)
    isCloseParenthesis: typeof CloseParenthesis.isCloseParenthesis;
    const // (undocumented)
    parseCloseParenthesis: Parser_2<Slice<Token>, CloseParenthesis, string, []>;
    // (undocumented)
    export function parseString(predicate?: Predicate<String>): Parser_2<Slice<Token>, String, string, []>;
    // (undocumented)
    export function parseURL(predicate?: Predicate<URL>): Parser_2<Slice<Token>, URL, string, []>;
    const // (undocumented)
    openSquareBracket: typeof OpenSquareBracket.of, // (undocumented)
    isOpenSquareBracket: typeof OpenSquareBracket.isOpenSquareBracket;
    const // (undocumented)
    parseOpenSquareBracket: Parser_2<Slice<Token>, OpenSquareBracket, string, []>;
    // (undocumented)
    export class Percentage implements Equatable, Serializable<Percentage.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        get isInteger(): boolean;
        // (undocumented)
        static of(value: number, isInteger: boolean): Percentage;
        // (undocumented)
        toJSON(): Percentage.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "percentage";
        // (undocumented)
        get value(): number;
    }
    // (undocumented)
    export namespace Percentage {
        // (undocumented)
        export function isPercentage(value: unknown): value is Percentage;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            isInteger: boolean;
            // (undocumented)
            type: "percentage";
            // (undocumented)
            value: number;
        }
    }
    const // (undocumented)
    closeSquareBracket: typeof CloseSquareBracket.of, // (undocumented)
    isCloseSquareBracket: typeof CloseSquareBracket.isCloseSquareBracket;
    const // (undocumented)
    parseCloseSquareBracket: Parser_2<Slice<Token>, CloseSquareBracket, string, []>;
    // (undocumented)
    export class Semicolon implements Equatable, Serializable<Semicolon.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): Semicolon;
        // (undocumented)
        toJSON(): Semicolon.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "semicolon";
    }
    // (undocumented)
    export namespace Semicolon {
        // (undocumented)
        export function isSemicolon(value: unknown): value is Semicolon;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "semicolon";
        }
    }
    const // (undocumented)
    openCurlyBracket: typeof OpenCurlyBracket.of, // (undocumented)
    isOpenCurlyBracket: typeof OpenCurlyBracket.isOpenCurlyBracket;
    const // (undocumented)
    parseOpenCurlyBracket: Parser_2<Slice<Token>, OpenCurlyBracket, string, []>;
    // (undocumented)
    export class String implements Equatable, Serializable<String.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): String;
        // (undocumented)
        toJSON(): String.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "string";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace String {
        // (undocumented)
        export function isString(value: unknown): value is String;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "string";
            // (undocumented)
            value: string;
        }
    }
    const // (undocumented)
    closeCurlyBracket: typeof CloseCurlyBracket.of, // (undocumented)
    isCloseCurlyBracket: typeof CloseCurlyBracket.isCloseCurlyBracket;
    const // (undocumented)
    parseCloseCurlyBracket: Parser_2<Slice<Token>, CloseCurlyBracket, string, []>;
    // (undocumented)
    export class URL implements Equatable, Serializable<URL.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(value: string): URL;
        // (undocumented)
        toJSON(): URL.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "url";
        // (undocumented)
        get value(): string;
    }
    // (undocumented)
    export namespace URL {
        // (undocumented)
        export function isURL(value: unknown): value is URL;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "url";
            // (undocumented)
            value: string;
        }
    }
    const // (undocumented)
    openComment: typeof OpenComment.of, // (undocumented)
    isOpenComment: typeof OpenComment.isOpenComment;
    const // (undocumented)
    parseOpenComment: Parser_2<Slice<Token>, OpenComment, string, []>;
    // (undocumented)
    export class Whitespace implements Equatable, Serializable<Whitespace.JSON> {
        // (undocumented)
        equals(value: unknown): value is this;
        // (undocumented)
        static of(): Whitespace;
        // (undocumented)
        toJSON(): Whitespace.JSON;
        // (undocumented)
        toString(): string;
        // (undocumented)
        get type(): "whitespace";
    }
    // (undocumented)
    export namespace Whitespace {
        // (undocumented)
        export function isWhitespace(value: unknown): value is Whitespace;
        // (undocumented)
        export interface JSON {
            // (undocumented)
            [key: string]: json.JSON;
            // (undocumented)
            type: "whitespace";
        }
    }
    const // (undocumented)
    closeComment: typeof CloseComment.of, // (undocumented)
    isCloseComment: typeof CloseComment.isCloseComment;
    const // (undocumented)
    parseCloseComment: Parser_2<Slice<Token>, CloseComment, string, []>;
}

// @public (undocumented)
export type Transform = Matrix | Perspective | Rotate | Scale | Skew | Translate;

// @public (undocumented)
export namespace Transform {
    // (undocumented)
    export type Canonical = Matrix | Perspective.Canonical | Rotate.Canonical | Scale | Skew.Canonical | Translate.Canonical;
    // (undocumented)
    export function matrix(...values: Matrix.Values<Number_2.Fixed>): Matrix;
    // (undocumented)
    export function perspective<D extends Length.Fixed>(depth: D): Perspective<D>;
    // (undocumented)
    export function rotate<A extends Angle.Fixed>(x: Number_2.Fixed, y: Number_2.Fixed, z: Number_2.Fixed, angle: A): Rotate<A>;
    // (undocumented)
    export function scale(x: Number_2.Fixed, y: Number_2.Fixed): Scale;
    // (undocumented)
    export function skew<X extends Angle.Fixed, Y extends Angle.Fixed>(x: X, y: Y): Skew<X, Y>;
    // (undocumented)
    export function translate<X extends Length.Fixed | Percentage.Fixed, Y extends Length.Fixed | Percentage.Fixed, Z extends Length.Fixed>(x: X, y: Y, z: Z): Translate<X, Y, Z>;
    const // (undocumented)
    parse: Parser_2<Slice<Token>, Transform, string, []>;
    const // (undocumented)
    parseList: Parser<Array<Transform>>;
}

// @public (undocumented)
export class Translate<X extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed, Y extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed, Z extends Length.Fixed = Length.Fixed> extends Function_3<"translate"> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<X extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed, Y extends Length.Fixed | Percentage.Fixed = Length.Fixed | Percentage.Fixed, Z extends Length.Fixed = Length.Fixed>(x: X, y: Y, z: Z): Translate<X, Y, Z>;
    // (undocumented)
    resolve(): Translate<X, Y, Z>;
    // (undocumented)
    toJSON(): Translate.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get x(): X;
    // (undocumented)
    get y(): Y;
    // (undocumented)
    get z(): Z;
}

// @public (undocumented)
export namespace Translate {
    // (undocumented)
    export type Canonical = Translate<Length.Canonical | Percentage.Canonical, Length.Canonical | Percentage.Canonical, Length.Canonical>;
    // (undocumented)
    export function isTranslate<X extends Length.Fixed | Percentage.Fixed, Y extends Length.Fixed | Percentage.Fixed, Z extends Length.Fixed>(value: unknown): value is Translate<X, Y, Z>;
    // (undocumented)
    export interface JSON extends Function_3.JSON<"translate"> {
        // (undocumented)
        x: Length.Fixed.JSON | Percentage.Fixed.JSON;
        // (undocumented)
        y: Length.Fixed.JSON | Percentage.Fixed.JSON;
        // (undocumented)
        z: Length.Fixed.JSON;
    }
    const // (undocumented)
    parse: Parser<Translate>;
}

// @public (undocumented)
export class Tuple<T extends Array<Value>, CALC extends boolean = boolean> extends Value<"tuple", CALC> implements Resolvable<Tuple<Tuple.Resolved<T>, false>, Tuple.Resolver<T>> {
    // (undocumented)
    equals<T extends Array<Value>>(value: Tuple<T>): boolean;
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of<T extends Array<Value>>(...values: Readonly<T>): Tuple<T, Value.HasCalculation<T>>;
    // (undocumented)
    resolve(resolver?: Tuple.Resolver<T>): Tuple<Tuple.Resolved<T>, false>;
    // (undocumented)
    toJSON(): Tuple.JSON<T>;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get values(): Readonly<T>;
}

// @public (undocumented)
export namespace Tuple {
    // (undocumented)
    export function isTuple<T extends Array<Value>>(value: unknown): value is Tuple<T>;
    // (undocumented)
    export interface JSON<T extends Array<Value>> extends Value.JSON<"tuple"> {
        // (undocumented)
        values: Serializable.ToJSON<T>;
    }
    // @internal
    export type Resolved<T extends Array<Value>> = T extends [
    infer Head extends Value,
    ...infer Tail extends Array<Value>
    ] ? [Resolvable.Resolved<Head>, ...Resolved<Tail>] : [];
    // @internal
    export type Resolver<T extends Array<Value>> = T extends Array<infer V extends Value> ? Resolvable.Resolver<V> : never;
}

// @public (undocumented)
export type Unit = Unit.Length | Unit.Angle | Unit.Time | Unit.Frequency | Unit.Resolution;

// @public (undocumented)
export namespace Unit {
    // (undocumented)
    export type Angle = "deg" | "grad" | "rad" | "turn";
    const // (undocumented)
    isRelativeLength: typeof Length.isRelative, // (undocumented)
    isFontRelativeLength: typeof Length.isFontRelative, // (undocumented)
    isViewportRelativeLength: typeof Length.isViewportRelative, // (undocumented)
    isAbsoluteLength: typeof Length.isAbsolute;
    // (undocumented)
    export type Frequency = "hz" | "kHz";
    // (undocumented)
    export function isAngle(unit: string): unit is Angle;
    // (undocumented)
    export function isFrequency(unit: string): unit is Frequency;
    // (undocumented)
    export function isLength(unit: string): unit is Length;
    // (undocumented)
    export function isResolution(unit: string): unit is Resolution;
    // (undocumented)
    export function isTime(unit: string): unit is Time;
    // (undocumented)
    export namespace Length {
        // (undocumented)
        export type Absolute = "cm" | "mm" | "Q" | "in" | "pc" | "pt" | "px";
        // (undocumented)
        export function isAbsolute(unit: string): unit is Absolute;
        // (undocumented)
        export function isFontRelative(unit: string): unit is Relative.Font;
        // (undocumented)
        export function isRelative(unit: string): unit is Relative;
        // (undocumented)
        export function isViewportRelative(unit: string): unit is Relative.Viewport;
        // (undocumented)
        export type Relative = Relative.Font | Relative.Viewport;
        // (undocumented)
        export namespace Relative {
            // (undocumented)
            export type Font = "em" | "ex" | "ch" | "rem";
            // (undocumented)
            export type Viewport = "vw" | "vh" | "vmin" | "vmax";
        }
    }
    // (undocumented)
    export type Length = Length.Relative | Length.Absolute;
    // (undocumented)
    export type Resolution = "dpi" | "dpcm" | "dppx";
    // (undocumented)
    export type Time = "s" | "ms";
}

// @public (undocumented)
export class URL extends Value<"url", false> {
    // (undocumented)
    equals(value: unknown): value is this;
    // (undocumented)
    hash(hash: Hash): void;
    // (undocumented)
    static of(url: string): URL;
    // (undocumented)
    resolve(): URL;
    // (undocumented)
    toJSON(): URL.JSON;
    // (undocumented)
    toString(): string;
    // (undocumented)
    get url(): string;
}

// @public (undocumented)
export namespace URL {
    // (undocumented)
    export function isURL(value: unknown): value is URL;
    // (undocumented)
    export interface JSON extends Value.JSON<"url"> {
        // (undocumented)
        url: string;
    }
    const // (undocumented)
    parse: Parser<URL>;
}

// @public
export abstract class Value<T extends string = string, CALC extends boolean = boolean, R extends string = T> implements Equatable, Hashable, Serializable<Value.JSON<T>>, Resolvable<Value<R, false>, Resolvable.Resolver<Value>> {
    protected constructor(type: T, hasCalculation: CALC);
    // (undocumented)
    abstract equals(value: unknown): value is this;
    // (undocumented)
    hasCalculation(): this is Value<T, true, R>;
    // (undocumented)
    protected readonly _hasCalculation: CALC;
    // (undocumented)
    abstract hash(hash: Hash): void;
    // (undocumented)
    abstract resolve(resolver?: unknown): Value<R, false>;
    // (undocumented)
    toJSON(): Value.JSON<T>;
    // (undocumented)
    abstract toString(): string;
    // (undocumented)
    get type(): T;
}

// @public (undocumented)
export namespace Value {
    // @internal (undocumented)
    export type HasCalculation<V extends Value | Array<Value>> = V extends Value<string, false> ? false : V extends Value ? true : V extends Array<Value<string, false>> ? false : true;
    // (undocumented)
    export function isValue<T extends string>(value: unknown, type?: T): value is Value<T>;
    // (undocumented)
    export interface JSON<T extends string = string> {
        // (undocumented)
        [key: string]: json.JSON;
        // (undocumented)
        type: T;
    }
}

// (No @packageDocumentation comment for this package)

```
