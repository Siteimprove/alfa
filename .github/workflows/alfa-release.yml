# Create a release for the Alfa repos.
#
# WARNING! This workflow pushes to main which **does** trigger other workflow (build, scan, …)
# WARNING! Therefore, there is a risk of creating infinite workflow loops if this workflow is
# WARNING! called from another automated workflow.
# WARNING! Therefore, only ever call this workflow from manual ones (only accepting workflow_dispatch
# WARNING! trigger) to avoid problems.
name: Create a new release (generic workflow)

# This workflow creates and publish a new release of an Alfa repo.
#
# This workflow is intended to work on Alfa repos sharing the same structure for code and release.
# Namely:
# * TypeScript (or ECMAScript) mono-repo, with yarn workspaces in `packages/alfa-*`
# * Relying on the `yarn install` / `yarn build` / `yarn test` cycle.
# * Using either yarn PnP or usual node_modules for dependencies.
# * Using changeset for storing local changes as they happen.
# * Sharing version number between all packages (`fixed` in changeset config).
# * One CHANGELOG.md per workspace (this is part of changeset)
# * One top-level CHANGELOG.md (currently with links to the individual ones, but this is something we
#   may want to improve as part of this workflow).
# * Packages published on the Github registry (may be public or restricted).
#
# This workflow is likely to fail on any repository that does not have the same structure.
# Use at your own judgement call.

on:
  workflow_call:
    inputs:
      # Authentication of the user who will commit the changes
      # This user must be able to bypass branch protections as it will commit directly to main.
      user-name:
        required: true
        type: string
      user-email:
        required: true
        type: string
    secrets:
      # A PAT for the user who will commit. Need to have the repo:write permission.
      token:
        required: true

defaults:
  run:
    shell: bash

jobs:
  release:
    name: Release
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          # Only this step needs to be done with the upgraded token, all other actions steps can be done
          # with the regular token generated by Github
          token: ${{ secrets.token }}
      - uses: actions/setup-node@v3
        with:
          node-version: 16
          cache: yarn
          registry-url: 'https://npm.pkg.github.com'
          scope: '@siteimprove'
      - name: Configure token for Alfa packages
        run: >
          yarn config set
          npmScopes.siteimprove.npmAuthToken
          ${{ github.token }}

      # We need to make sure the dependencies are installed *before* running changeset.
      # This differs a bit depending whether yarn PnP is used or not.
      - name: Is this repo using Yarn plug'n'play?
        id: yarn
        # Somehow feeling that there should be a setting in package.json or .yarnrc.yml which would be
        # better to read, but not finding any on yarn 3… Reverting to a low-key detection.
        run: |
          if [[ -f .pnp.cjs ]]; then
            echo "is-pnp=true" >> $GITHUB_OUTPUT
          else
            echo "is-pnp=false" >> $GITHUB_OUTPUT
          fi
      - name: Verify dependencies (yarn PnP)
        if: steps.yarn.outputs.is-pnp == 'true'
        # https://yarnpkg.com/features/zero-installs#does-it-have-security-implications
        run: yarn install --immutable --immutable-cache --check-cache
      - name: Install dependencies (yarn + node_modules)
        if: steps.yarn.outputs.is-pnp != 'true'
        run: yarn install --immutable

      - name: Is current version unique?
        # Check that all packages are at the same version, if not, abort.
        # The grep result looks like:
        #    packages/alfa-foo: "version": "x.y.z",
        # So we want the 4th "-separated field.
        #
        # If not unique, this exits and the workflow fails, which is good as it raises an alert for the caller.
        run: |
          [[ "$(grep \"version\": packages/alfa-*/package.json | cut -d\" -f 4 | sort -u | wc -l)" == 1 ]] || exit 1

      - name: Get current version
        id: current
        # Grepping through all package.json ensure this stays correct even if some packages are moved elsewhere.
        # Other solution would be to hook on a given package, this may become incorrect if that package moves.
        run: |
          echo "version=v$(grep \"version\": packages/alfa-*/package.json | cut -d\" -f 4 | sort -u)" >> $GITHUB_OUTPUT
      - name: Get list of changed packages
        id: changed
        run: |
          # Using a random heredoc delimiter for hardening.
          # See https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "packages<<${EOF}" >> $GITHUB_OUTPUT
          # The grep result looks like:
          #    .changeset/foo.md: "@siteimprove/alfa-foo": increment
          # So we want the second "-separated field.
          grep @siteimprove/alfa- .changeset/*.md | cut -d\" -f2 | sort -u >> $GITHUB_OUTPUT
          echo "${EOF}" >> $GITHUB_OUTPUT

      - name: Gather changes and update packages
        run: yarn changeset version
        env:
          GITHUB_TOKEN: ${{ github.token }}
      - name: Get new version
        id: new
        run: echo "version=v$(grep version packages/alfa-*/package.json | cut -d\" -f 4 | sort -u)" >> $GITHUB_OUTPUT

      - name: Preparing new section for global changelog
        id: changelog
        run: |
          # Using a random heredoc delimiter for hardening.
          # See https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "changelog<<${EOF}" >> $GITHUB_OUTPUT
          # Build the header:
          # # [vx.y.z-new](../../compare/vx.y.z-current...vx.y.z-new) (YYYY-MM-DD)
          echo "# [${{ steps.new.outputs.version }}](../../compare/${{ steps.current.outputs.version }}...${{ steps.new.outputs.version }}) ($(date --iso-8601=date))" >> $GITHUB_OUTPUT
          echo -e "\nPackages changed:" >> $GITHUB_OUTPUT
          # Turn: @siteimprove/alfa-foo
          # into: - [@siteimprove/alfa-foo](packages/alfa-foo/CHANGELOG.md)
          # alfa-foo is the captured group \1
          echo "${{ steps.changed.outputs.packages }}" | sed 's+@siteimprove/\(.*\)+- \[@siteimprove/\1](packages/\1/CHANGELOG.md)+' >> $GITHUB_OUTPUT
          echo -e "\n" >> $GITHUB_OUTPUT
          echo "${EOF}" >> $GITHUB_OUTPUT
      - name: Build global changelog
        # Since we want the new section at the top, we need to prepare it separately so we can cat in order.
        # Bash reads the file first, so we don't need a temp storage.
        run: echo "${{ steps.changelog.outputs.changelog }}$(cat CHANGELOG.md)" > CHANGELOG.md

      - name: Verify changes
        # Install was already done early in the workflow
        run: yarn build && yarn test

      - name: Set up git config
        # We need a user able to bypass branch protection (i.e. admin on the repo).
        run: |
          git config --local core.filemode false
          git config --local user.name "${{ inputs.user-name }}"
          git config --local user.email "${{ inputs.user-email }}"
      - name: Commit and push changes
        # If we made it thus far, we can commit the changes
        # We need to take care to **not** commit .yarnrc.yml which has been updated with a token.
        run: |
          # Removed individual changesets, all changelog (global and local), all package.json (new version number)
          git add .changeset/ CHANGELOG.md **/CHANGELOG.md package.json **/package.json
          git commit -m ${{ steps.new.outputs.version }}
          git tag --annotate ${{ steps.new.outputs.version }} --message=${{ steps.new.outputs.version }}
          git push --follow-tags

      - name: Make npm release
        run: >
          yarn workspaces foreach
          --no-private
          --topological-dev
          npm publish --tolerate-republish

      - name: Make Github release
        run: >
          gh release create ${VERSION}
          --prerelease
          --verify-tag
          --title ${VERSION}
          --notes "[Changelog for this release](CHANGELOG.md)"
        env:
          GH_TOKEN: ${{ github.token }}
          # Passing it as a variable rather than inline hardens against script injection.
          # See https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions#using-an-intermediate-environment-variable
          VERSION: ${{ steps.new.outputs.version }}
